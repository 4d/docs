"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["71739"],{826763:function(e,n,t){t.r(n),t.d(n,{default:()=>B,frontMatter:()=>r,metadata:()=>s,assets:()=>l,toc:()=>d,contentTitle:()=>i});var s=JSON.parse('{"id":"Concepts/blob","title":"BLOB","description":"- A BLOB (Binary Large OBjects) field, variable or expression is a contiguous series of bytes which can be treated as one whole object or whose bytes can be addressed individually. A BLOB can be empty (null length) or contain up to 2147483647 bytes (2 GB).","source":"@site/versioned_docs/version-18/Concepts/dt_blob.md","sourceDirName":"Concepts","slug":"/Concepts/blob","permalink":"/docs/18/Concepts/blob","draft":false,"unlisted":false,"editUrl":"https://github.com/4d/docs/issues/new?title=Comment%20on%20Concepts%2Fdt_blob.md%20(18)&body=Please%20enter%20your%20comment%3A","tags":[],"version":"18","frontMatter":{"id":"blob","title":"BLOB"},"sidebar":"docs","previous":{"title":"Data types overview","permalink":"/docs/18/Concepts/data-types"},"next":{"title":"Boolean","permalink":"/docs/18/Concepts/boolean"}}'),o=t("785893"),a=t("250065");let r={id:"blob",title:"BLOB"},i=void 0,l={},d=[{value:"Parameter passing, Pointers and function results",id:"parameter-passing-pointers-and-function-results",level:2},{value:"Assignment operator",id:"assignment-operator",level:2},{value:"Addressing BLOB contents",id:"addressing-blob-contents",level:2}];function c(e){let n={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A BLOB (Binary Large OBjects) field, variable or expression is a contiguous series of bytes which can be treated as one whole object or whose bytes can be addressed individually. A BLOB can be empty (null length) or contain up to 2147483647 bytes (2 GB)."}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"By default, 4D sets the maximum blob size to 2GB, but this size limit may be lower depending on your OS and how much space is available."}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A BLOB is loaded into memory in its entirety. A BLOB variable is held and exists in memory only. A BLOB field is loaded into memory from the disk, like the rest of the record to which it belongs."}),"\n",(0,o.jsxs)(n.li,{children:["Like the other field types that can retain a large amount of data (such as the Picture field type), BLOB fields are not duplicated in memory when you modify a record. Consequently, the result returned by the ",(0,o.jsx)(n.code,{children:"Old"})," and ",(0,o.jsx)(n.code,{children:"Modified"})," commands is not significant when applied to a BLOB field."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"parameter-passing-pointers-and-function-results",children:"Parameter passing, Pointers and function results"}),"\n",(0,o.jsx)(n.p,{children:"4D BLOBs can be passed as parameters to 4D commands or plug-in routines that expect BLOB parameters. BLOBS can also be passed as parameters to a user method or be returned as a function result."}),"\n",(0,o.jsx)(n.p,{children:"To pass a BLOB to your own methods, you can also define a pointer to the BLOB and pass the pointer as parameter."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-4d",children:"  ` Declare a variable of type BLOB\n C_BLOB(anyBlobVar)\n  ` The BLOB is passed as parameter to a 4D command\n SET BLOB SIZE(anyBlobVar;1024*1024)\n  ` The BLOB is passed as parameter to an external routine\n $errCode:=Do Something With This BLOB(anyBlobVar)\n  ` The BLOB is passed as a parameter to a method that returns a BLOB\n C_BLOB(retrieveBlob)\n retrieveBlob:=Fill_Blob(anyBlobVar)\n  ` A pointer to the BLOB is passed as parameter to a user method\n COMPUTE BLOB(->anyBlobVar)\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note for Plug-in developers:"})," A BLOB parameter is declared as \u201C&O\u201D (the letter \u201CO\u201D, not the digit \u201C0\u201D)."]}),"\n",(0,o.jsx)(n.h2,{id:"assignment-operator",children:"Assignment operator"}),"\n",(0,o.jsx)(n.p,{children:"You can assign BLOBs to each other."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-4d",children:"  ` Declare two variables of type BLOB\n C_BLOB(vBlobA;vBlobB)\n  ` Set the size of the first BLOB to 10K\n SET BLOB SIZE(vBlobA;10*1024)\n  ` Assign the first BLOB to the second one\n vBlobB:=vBlobA\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, no operator can be applied to BLOBs."}),"\n",(0,o.jsx)(n.h2,{id:"addressing-blob-contents",children:"Addressing BLOB contents"}),"\n",(0,o.jsx)(n.p,{children:"You can address each byte of a BLOB individually using the curly brackets symbols {...}. Within a BLOB, bytes are numbered from 0 to N-1, where N is the size of the BLOB. Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-4d",children:"  ` Declare a variable of type BLOB\n C_BLOB(vBlob)\n  ` Set the size of the BLOB to 256 bytes\n SET BLOB SIZE(vBlob;256)\n  ` The loop below initializes the 256 bytes of the BLOB to zero\n For(vByte;0;BLOB size(vBlob)-1)\n    vBlob{vByte}:=0\n End for\n"})}),"\n",(0,o.jsx)(n.p,{children:"Because you can address all the bytes of a BLOB individually, you can actually store whatever you want in a BLOB field or variable."})]})}function B(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return i},a:function(){return r}});var s=t(667294);let o={},a=s.createContext(o);function r(e){let n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);