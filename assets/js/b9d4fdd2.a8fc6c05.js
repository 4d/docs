"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["19620"],{867634:function(e,s,n){n.r(s),n.d(s,{default:()=>d,frontMatter:()=>t,metadata:()=>a,assets:()=>l,toc:()=>h,contentTitle:()=>i});var a=JSON.parse('{"id":"commands-legacy/semaphore","title":"Semaphore","description":"Semaphore ( semaphore {; tickCount} ) : Boolean","source":"@site/versioned_docs/version-20-R7/commands-legacy/semaphore.md","sourceDirName":"commands-legacy","slug":"/commands/semaphore","permalink":"/docs/commands/semaphore","draft":false,"unlisted":false,"editUrl":"https://github.com/4d/docs/issues/new?title=Comment%20on%20commands-legacy%2Fsemaphore.md%20(20-R7)&body=Please%20enter%20your%20comment%3A","tags":[],"version":"20-R7","frontMatter":{"id":"semaphore","title":"Semaphore","slug":"/commands/semaphore","displayed_sidebar":"docs"},"sidebar":"docs","previous":{"title":"New signal","permalink":"/docs/commands/new-signal"},"next":{"title":"SET PROCESS VARIABLE","permalink":"/docs/commands/set-process-variable"}}'),r=n("785893"),o=n("250065");let t={id:"semaphore",title:"Semaphore",slug:"/commands/semaphore",displayed_sidebar:"docs"},i=void 0,l={},h=[{value:"Description",id:"description",level:4},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"Example 3",id:"example-3",level:4},{value:"Example 4",id:"example-4",level:4},{value:"See also",id:"see-also",level:4},{value:"Properties",id:"properties",level:4}];function c(e){let s={a:"a",br:"br",code:"code",em:"em",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Semaphore"})," ( ",(0,r.jsx)(s.em,{children:"semaphore"})," {; ",(0,r.jsx)(s.em,{children:"tickCount"}),"} ) : Boolean"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Parameter"}),(0,r.jsx)(s.th,{children:"Type"}),(0,r.jsx)(s.th,{}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"semaphore"}),(0,r.jsx)(s.td,{children:"Text"}),(0,r.jsx)(s.td,{children:"\u2192"}),(0,r.jsx)(s.td,{children:"Semaphore to test and set"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"tickCount"}),(0,r.jsx)(s.td,{children:"Integer"}),(0,r.jsx)(s.td,{children:"\u2192"}),(0,r.jsx)(s.td,{children:"Maximum waiting time"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Function result"}),(0,r.jsx)(s.td,{children:"Boolean"}),(0,r.jsx)(s.td,{children:"\u2190"}),(0,r.jsx)(s.td,{children:"Semaphore has been successfully set (FALSE) or Semaphore was already set (TRUE)"})]})]})]}),"\n",(0,r.jsx)(s.h4,{id:"description",children:"Description"}),"\n",(0,r.jsx)(s.p,{children:"A semaphore is a flag shared among workstations or among processes on the same workstation. A semaphore simply exists or does not exist. The methods that each user is running can test for the existence of a semaphore. A semaphore can only be removed by the client workstation or process that created it. By creating and testing semaphores, methods can communicate between workstations. You do not use semaphores to protect record access. This is automatically done by 4D and 4D Server. Use semaphores to prevent several users from performing the same operation at the same time."}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.strong,{children:"Semaphore"})," function returns TRUE and does nothing if ",(0,r.jsx)(s.em,{children:"semaphore"})," already exists. If ",(0,r.jsx)(s.em,{children:"semaphore"})," does not exist, ",(0,r.jsx)(s.strong,{children:"Semaphore"})," creates it and returns FALSE. Only one user at a time can create a semaphore. If ",(0,r.jsx)(s.strong,{children:"Semaphore"})," returns FALSE, it means that the semaphore did not exist, but it also means that the semaphore has been set for the process in which the call has been made."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Semaphore"})," returns FALSE if the semaphore was not set. It also returns FALSE if the semaphore is already set by the same process in which the call has been made."]}),"\n",(0,r.jsx)(s.p,{children:'A semaphore is limited to 255 characters, including prefix ($). If you pass a longer string, the semaphore will be tested with the truncated string. Keep in mind that semaphore names are case-sensitive in 4D (for example, the program considers that "MySemaphore" is different from "mysemaphore").'}),"\n",(0,r.jsxs)(s.p,{children:["The optional parameter ",(0,r.jsx)(s.em,{children:"tickCount"})," allows you to specify a waiting time (in ticks) if ",(0,r.jsx)(s.em,{children:"semaphore"})," is already set. In this case, the function will wait either for the semaphore to be freed or the waiting time to expire before returning ",(0,r.jsx)(s.strong,{children:"True"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"There are two types of semaphores in 4D: local semaphores and global semaphores."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"A local semaphore is accessible by all processes on the same workstation and only on the workstation. A local semaphore can be created by prefixing the name of the semaphore with a dollar sign ($). You use local semaphores to monitor operations among processes executing on the same workstation. For example, a local semaphore can be used to monitor access to an interprocess array shared by all the processes in your single-user database or on the workstation."}),"\n",(0,r.jsx)(s.li,{children:"A global semaphore is accessible to all users and all their processes. You use global semaphores to monitor operations among users of a multi-user database."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Global and local semaphores are identical in their logic. The difference resides in their scope."}),"\n",(0,r.jsx)(s.p,{children:"In client-server mode, global semaphores are shared among all the processes running on all clients and servers. A local semaphore is only shared among the processes running on the machine where it has been created."}),"\n",(0,r.jsx)(s.p,{children:"In 4D, global or local semaphores have the same scope because you are the only user. However, if your database is being used in both setups, make sure to use global or local semaphores depending on what you want to do."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note:"})," We recommend using local semaphores when you need a semaphore to manage a local aspect for a client of the application, such as the interface or an array of interprocess variables. If you use a global semaphores in this case, it would not only cause unnecessary network exchanges but could also affect other client machines unnecessarily. Using a local semaphore would avoid these undesirable side effects."]}),"\n",(0,r.jsx)(s.h4,{id:"example-1",children:"Example 1"}),"\n",(0,r.jsx)(s.p,{children:"Here is typical code for using a semaphore:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-4d",children:'\xa0While(Semaphore("MySemaphore";300))\n\xa0\xa0\xa0\xa0IDLE\n\xa0End while\n\xa0\xa0// place code protected by semaphore here\n\xa0CLEAR SEMAPHORE("MySemaphore")\n'})}),"\n",(0,r.jsx)(s.h4,{id:"example-2",children:"Example 2"}),"\n",(0,r.jsx)(s.p,{children:"In this example, you want to prevent two users from doing a global update of the prices in a Products table. The following method uses semaphores to manage this:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-4d",children:'\xa0If(Semaphore("UpdatePrices"))\xa0// Try to create the semaphore\n\xa0\xa0\xa0\xa0ALERT("Another user is already updating prices. Retry later.")\n\xa0Else\n\xa0\xa0\xa0\xa0DoUpdatePrices\xa0// Update all the prices\n\xa0\xa0\xa0\xa0CLEAR SEMAPHORE("UpdatePrices"))\xa0// Clear the semaphore\n\xa0End if\n'})}),"\n",(0,r.jsx)(s.h4,{id:"example-3",children:"Example 3"}),"\n",(0,r.jsx)(s.p,{children:"The following example uses a local semaphore. In a database with several processes, you want to maintain a To Do list. You want to maintain the list in an interprocess array and not in a table. You use a semaphore to prevent simultaneous access. In this situation, you only need to use a local semaphore, because your To Do list is only for your use."}),"\n",(0,r.jsx)(s.p,{children:"The interprocess array is initialized in the Startup method:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-4d",children:"\xa0ARRAY TEXT(\u25CAToDoList;0)\xa0// The To Do list is initially empty\n"})}),"\n",(0,r.jsx)(s.p,{children:"Here is the method used for adding items to the To Do list:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-4d",children:'\xa0\xa0// ADD TO DO LIST project method\n\xa0\xa0// ADD TO DO LIST ( Text )\n\xa0\xa0// ADD TO DO LIST ( To do list item )\n\xa0var $1 : Text\n\xa0If(Not(Semaphore("$AccessToDoList";300)))\n\xa0\xa0// Wait 5 seconds if the semaphore already exists\n\xa0\xa0\xa0\xa0$vlElem:=Size of array(\u25CAToDoList)+1\n\xa0\xa0\xa0\xa0INSERT IN ARAY(\u25CAToDoList;$vlElem)\n\xa0\xa0\xa0\xa0\u25CAToDoList{$vlElem}:=$1\n\xa0\xa0\xa0\xa0CLEAR SEMAPHORE("$AccessToDoList")\xa0// Clear the semaphore\n\xa0End if\n'})}),"\n",(0,r.jsx)(s.p,{children:"You can call the above method from any process."}),"\n",(0,r.jsx)(s.h4,{id:"example-4",children:"Example 4"}),"\n",(0,r.jsx)(s.p,{children:"This method allows you to not execute a method when a semaphore is present; the method alerts the calling method with an error code and plain text."}),"\n",(0,r.jsx)(s.p,{children:"Syntax:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-4d",children:"\xa0$L_Error:=Semaphore_proof(->$T_Text_error)\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-4d",children:'\xa0\xa0// Protective structure using semaphores\n\xa0var $0 : Integer\n\xa0var $1 : Pointer\xa0// error message\n\xa0\n\xa0\xa0// Start of method\n\xa0var $L_MyError : Integer\n\xa0$L_MyError:=1\n\xa0\n\xa0var $T_Sema_local : Text\n\xa0$T_Sema_local:="$tictac"\n\xa0\n\xa0If(Semaphore($T_Sema_local;300))\n\xa0\xa0// We expected 300 ticks but the semaphore\n\xa0\xa0// was not released by the one that placed it:\n\xa0\xa0// we end up here\n\xa0\xa0\xa0\xa0$L_MyError:=-1\n\xa0\n\xa0Else\n\xa0\n\xa0\xa0// This method is only run by one process at a time\n\xa0\n\xa0\xa0// We placed the semaphore as we entered\n\xa0\xa0// so we\'re the only ones that can remove it\n\xa0\n\xa0\xa0// Do something\n\xa0\xa0\xa0\xa0...\n\xa0\xa0// Then finish by removing the semaphore\n\xa0\xa0\xa0\xa0CLEAR SEMAPHORE($T_Sema_local)\n\xa0End if\n\xa0\n\xa0var $T_Message : Text\n\xa0If($L_MyError=-1)\n\xa0\xa0\xa0\xa0$T_Message:="The semaphore "+$T_Sema_local+" has blocked access to the rest of the code"\n\xa0Else\n\xa0\xa0\xa0\xa0$T_Message:="OK"\n\xa0End if\n\xa0\n\xa0$0:=$L_MyError\n\xa0$1->:=$T_Message \xa0// The calling method receives an error code and an explanation in plain text\n'})}),"\n",(0,r.jsx)(s.h4,{id:"see-also",children:"See also"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"/docs/commands/clear-semaphore",children:"CLEAR SEMAPHORE"}),(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.em,{children:"Semaphores and signals"}),(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.a,{href:"/docs/commands/test-semaphore",children:"Test semaphore"})]}),"\n",(0,r.jsx)(s.h4,{id:"properties",children:"Properties"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{}),(0,r.jsx)(s.th,{})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Command number"}),(0,r.jsx)(s.td,{children:"143"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Thread safe"}),(0,r.jsx)(s.td,{children:"\u2713"})]})]})]})]})}function d(e={}){let{wrapper:s}={...(0,o.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},250065:function(e,s,n){n.d(s,{Z:function(){return i},a:function(){return t}});var a=n(667294);let r={},o=a.createContext(r);function t(e){let s=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),a.createElement(o.Provider,{value:s},e.children)}}}]);