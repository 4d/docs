"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[76224],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=s,f=u["".concat(i,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(f,r(r({ref:t},c),{},{components:n})):a.createElement(f,r({ref:t},c))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:s,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6043:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});n(67294);var a=n(3905);function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},s.apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}const r={id:"branching",title:"Branching structures"},l=void 0,i={unversionedId:"Concepts/branching",id:"version-19-R8/Concepts/branching",title:"Branching structures",description:"A branching structure allows methods to test a condition and take alternative paths, depending on the result.",source:"@site/versioned_docs/version-19-R8/Concepts/cf_branching.md",sourceDirName:"Concepts",slug:"/Concepts/branching",permalink:"/docs/Concepts/branching",draft:!1,editUrl:"https://github.com/4d/docs/issues/new?title=Comment%20on%20Concepts%2Fcf_branching.md%20(19-R8)&body=Please%20enter%20your%20comment%3A",tags:[],version:"19-R8",frontMatter:{id:"branching",title:"Branching structures"},sidebar:"docs",previous:{title:"Control flow overview",permalink:"/docs/Concepts/control-flow"},next:{title:"Looping structures",permalink:"/docs/Concepts/looping"}},p={},c=[{value:"If...Else...End if",id:"ifelseend-if",level:2},{value:"Example",id:"example",level:3},{value:"Case of...Else...End case",id:"case-ofelseend-case",level:2},{value:"Example",id:"example-1",level:3}],d={toc:c};function u(e){var{components:t}=e,n=o(e,["components"]);return(0,a.kt)("wrapper",s({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A branching structure allows methods to test a condition and take alternative paths, depending on the result."),(0,a.kt)("h2",s({},{id:"ifelseend-if"}),"If...Else...End if"),(0,a.kt)("p",null,"The formal syntax of the ",(0,a.kt)("inlineCode",{parentName:"p"},"If...Else...End if")," control flow structure is:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," If(Boolean_Expression)\n    statement(s)\n Else\n    statement(s)\n End if\n")),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Else")," part is optional; you can write:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," If(Boolean_Expression)\n    statement(s)\n End if\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"If...Else...End if")," structure lets your method choose between two actions, depending on whether a test (a Boolean expression) is TRUE or FALSE. When the Boolean expression is TRUE, the statements immediately following the test are executed. If the Boolean expression is FALSE, the statements following the Else statement are executed. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Else")," statement is optional; if you omit Else, execution continues with the first statement (if any) following the ",(0,a.kt)("inlineCode",{parentName:"p"},"End if"),"."),(0,a.kt)("p",null,"Note that the Boolean expression is always fully evaluated. Consider in particular the following test:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," If(MethodA & MethodB)\n    ...\n End if\n")),(0,a.kt)("p",null,"The expression is TRUE only if both methods are TRUE. However, even if ",(0,a.kt)("em",{parentName:"p"},"MethodA")," returns FALSE, 4D will still evaluate ",(0,a.kt)("em",{parentName:"p"},"MethodB"),", which is a useless waste of time. In this case, it is more interesting to use a structure like:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," If(MethodA)\n    If(MethodB)\n       ...\n    End if\n End if\n")),(0,a.kt)("p",null,"The result is similar and ",(0,a.kt)("em",{parentName:"p"},"MethodB")," is evaluated only if necessary. "),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," The ",(0,a.kt)("a",s({parentName:"p"},{href:"/docs/Concepts/operators#ternary-operator"}),"ternary operator")," allows writing one-line conditional expressions and can replace a full sequence of If..Else statements.")),(0,a.kt)("h3",s({},{id:"example"}),"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"}),'  // Ask the user to enter a name\n $Find:=Request(Type a name)\n If(OK=1)\n    QUERY([People];[People]LastName=$Find)\n Else\n    ALERT("You did not enter a name.")\n End if \n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tip:")," Branching can be performed without statements to be executed in one case or the other. When developing an algorithm or a specialized application, nothing prevents you from writing:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," If(Boolean_Expression)\n Else\n    statement(s)\n End if\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," If(Boolean_Expression)\n    statement(s)\n Else\n End if\n")),(0,a.kt)("h2",s({},{id:"case-ofelseend-case"}),"Case of...Else...End case"),(0,a.kt)("p",null,"The formal syntax of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Case of...Else...End case")," control flow structure is:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    :(Boolean_Expression)\n       statement(s)\n    :(Boolean_Expression)\n       statement(s)\n       .\n       .\n       .\n \n    :(Boolean_Expression)\n       statement(s)\n    Else\n       statement(s)\n End case\n")),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Else")," part is optional; you can write:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    :(Boolean_Expression)\n       statement(s)\n    :(Boolean_Expression)\n       statement(s)\n       .\n       .\n       .\n \n    :(Boolean_Expression)\n       statement(s)\n End case\n")),(0,a.kt)("p",null,"As with the ",(0,a.kt)("inlineCode",{parentName:"p"},"If...Else...End if")," structure, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Case of...Else...End case")," structure also lets your method choose between alternative actions. Unlike the ",(0,a.kt)("inlineCode",{parentName:"p"},"If...Else...End")," if structure, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Case of...Else...End case")," structure can test a reasonable unlimited number of Boolean expressions and take action depending on which one is TRUE."),(0,a.kt)("p",null,"Each Boolean expression is prefaced by a colon (",(0,a.kt)("inlineCode",{parentName:"p"},":"),"). This combination of the colon and the Boolean expression is called a case. For example, the following line is a case:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"}),":(bValidate=1)\n")),(0,a.kt)("p",null,"Only the statements following the first TRUE case (and up to the next case) will be executed. If none of the cases are TRUE, none of the statements will be executed (if no ",(0,a.kt)("inlineCode",{parentName:"p"},"Else")," part is included)."),(0,a.kt)("p",null,"You can include an Else statement after the last case. If all of the cases are FALSE, the statements following the ",(0,a.kt)("inlineCode",{parentName:"p"},"Else")," will be executed."),(0,a.kt)("h3",s({},{id:"example-1"}),"Example"),(0,a.kt)("p",null,"This example tests a numeric variable and displays an alert box with a word in it:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"}),' Case of\n    :(vResult=1) //Test if the number is 1\n       ALERT("One.") //If it is 1, display an alert\n    :(vResult=2) //Test if the number is 2\n       ALERT("Two.") //If it is 2, display an alert\n    :(vResult=3) //Test if the number is 3\n       ALERT("Three.") //If it is 3, display an alert\n    Else //If it is not 1, 2, or 3, display an alert\n       ALERT("It was not one, two, or three.")\n End case\n')),(0,a.kt)("p",null,"For comparison, here is the ",(0,a.kt)("inlineCode",{parentName:"p"},"If...Else...End if")," version of the same method:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"}),' If(vResult=1) //Test if the number is 1\n    ALERT("One.") //If it is 1, display an alert\n Else\n    If(vResult=2) //Test if the number is 2\n       ALERT("Two.") //If it is 2, display an alert\n    Else\n       If(vResult=3) //Test if the number is 3\n          ALERT("Three.") //If it is 3, display an alert\n       Else //If it is not 1, 2, or 3, display an alert\n          ALERT("It was not one, two, or three.")\n       End if\n    End if\n End if\n')),(0,a.kt)("p",null,"Remember that with a ",(0,a.kt)("inlineCode",{parentName:"p"},"Case of...Else...End case")," structure, only the first TRUE case is executed. Even if two or more cases are TRUE, only the statements following the first TRUE case will be executed."),(0,a.kt)("p",null,"Consequently, when you want to implement hierarchical tests, you should make sure the condition statements that are lower in the hierarchical scheme appear first in the test sequence. For example, the test for the presence of condition1 covers the test for the presence of condition1&condition2 and should therefore be located last in the test sequence. For example, the following code will never see its last condition detected:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    :(vResult=1)\n       ... //statement(s)\n    :((vResult=1) & (vCondition#2)) //this case will never be detected\n       ... //statement(s)\n End case\n")),(0,a.kt)("p",null,'In the code above, the presence of the second condition is not detected since the test "vResult=1" branches off the code before any further testing. For the code to operate properly, you can write it as follows:'),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    :((vResult=1) & (vCondition#2)) //this case will be detected first\n       ... //statement(s)\n    :(vResult=1)\n       ... //statement(s)\n End case\n")),(0,a.kt)("p",null,"Also, if you want to implement hierarchical testing, you may consider using hierarchical code."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tip:")," Branching can be performed without statements to be executed in one case or another. When developing an algorithm or a specialized application, nothing prevents you from writing:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    :(Boolean_Expression)\n    :(Boolean_Expression)\n      ...\n \n    :(Boolean_Expression)\n       statement(s)\n    Else\n       statement(s)\n End case\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    :(Boolean_Expression)\n    :(Boolean_Expression)\n       statement(s)\n       ...\n        \n    :(Boolean_Expression)\n       statement(s)\n    Else\n End case\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-4d"})," Case of\n    Else\n       statement(s)\n End case\n")))}u.isMDXComponent=!0}}]);