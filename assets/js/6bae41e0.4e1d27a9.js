"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["40341"],{546867:function(e,n,t){t.r(n),t.d(n,{metadata:()=>s,contentTitle:()=>i,default:()=>h,assets:()=>a,toc:()=>d,frontMatter:()=>c});var s=JSON.parse('{"id":"commands-legacy/ob-copy","title":"OB Copy","description":"OB Copy ( object {; resolvePtrs | {; option {; groupWith}}} )  : Object","source":"@site/versioned_docs/version-20-R7/commands-legacy/ob-copy.md","sourceDirName":"commands-legacy","slug":"/commands/ob-copy","permalink":"/docs/commands/ob-copy","draft":false,"unlisted":false,"editUrl":"https://github.com/4d/docs/issues/new?title=Comment%20on%20commands-legacy%2Fob-copy.md%20(20-R7)&body=Please%20enter%20your%20comment%3A","tags":[],"version":"20-R7","frontMatter":{"id":"ob-copy","title":"OB Copy","slug":"/commands/ob-copy","displayed_sidebar":"docs"},"sidebar":"docs","previous":{"title":"OB Class","permalink":"/docs/commands/ob-class"},"next":{"title":"OB Entries","permalink":"/docs/commands/ob-entries"}}'),r=t("785893"),o=t("250065");let c={id:"ob-copy",title:"OB Copy",slug:"/commands/ob-copy",displayed_sidebar:"docs"},i=void 0,a={},d=[{value:"Description",id:"description",level:4},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"Example 3",id:"example-3",level:4},{value:"Example 4",id:"example-4",level:4},{value:"Example 5",id:"example-5",level:4},{value:"See also",id:"see-also",level:4},{value:"Properties",id:"properties",level:4}];function l(e){let n={a:"a",br:"br",code:"code",em:"em",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"OB Copy"})," ( ",(0,r.jsx)(n.em,{children:"object"})," {; resolvePtrs | {; ",(0,r.jsx)(n.em,{children:"option"})," {; ",(0,r.jsx)(n.em,{children:"groupWith"}),"}}} )  : Object"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"object"}),(0,r.jsx)(n.td,{children:"Object, Object"}),(0,r.jsx)(n.td,{children:"\u2192"}),(0,r.jsx)(n.td,{children:"Structured object"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"resolvePtrs"}),(0,r.jsx)(n.td,{children:"Boolean"}),(0,r.jsx)(n.td,{children:"\u2192"}),(0,r.jsx)(n.td,{children:"True = resolve pointers, False or omitted = do not resolve pointers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"option"}),(0,r.jsx)(n.td,{children:"Integer"}),(0,r.jsx)(n.td,{children:"\u2192"}),(0,r.jsx)(n.td,{children:"ck shared: return a shared object,ck resolve pointers: resolve pointers before copying"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"groupWith"}),(0,r.jsx)(n.td,{children:"Collection, Object"}),(0,r.jsx)(n.td,{children:"\u2192"}),(0,r.jsx)(n.td,{children:"Shared collection or object to be grouped with the resulting object"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Function result"}),(0,r.jsx)(n.td,{children:"Object"}),(0,r.jsx)(n.td,{children:"\u2190"}),(0,r.jsx)(n.td,{children:"Deep copy of object"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"description",children:"Description"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"OB Copy"})," command returns an object containing a complete (deep) copy of the properties, sub-objects and values for the ",(0,r.jsx)(n.em,{children:"object"}),".\nIf ",(0,r.jsx)(n.em,{children:"object"})," contains pointer type values, by default the copy also contains the pointers. However, you can resolve pointers when copying by passing ",(0,r.jsx)(n.strong,{children:"True"})," in the ",(0,r.jsx)(n.em,{children:"resolvePtrs"})," parameter. In this case, each pointer present as a value in ",(0,r.jsx)(n.em,{children:"object"})," is evaluated when copying and its dereferenced value is used."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," If properties of ",(0,r.jsx)(n.em,{children:"object"})," are shared objects or shared collections, they become regular (not shared) objects or collections in the returned copy. Use the second syntax if you want to return shared elements (see below)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Second syntax: ",(0,r.jsx)(n.strong,{children:"OB Copy(object{; option{; groupWith}})"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If passed, the ",(0,r.jsx)(n.em,{children:"option"})," parameter can contain one or both of the following constants:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"option"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Description"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ck resolve pointers"}),(0,r.jsx)(n.td,{children:"If the original object contains pointer type values, by default the copy also contains the pointers. However, you can resolve pointers when copying by passing the ck resolve pointers constant. In this case, each pointer present in the object is evaluated when copying and its dereferenced value is used."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ck shared"}),(0,r.jsxs)(n.td,{children:["By default, ",(0,r.jsx)(n.strong,{children:"OB Copy"})," returns a regular (not shared) object, even if the command is applied to a shared object. Pass the ck shared constant to create a shared object. In this case, you can use the ",(0,r.jsx)(n.em,{children:"groupWith"})," parameter to associate the shared object with another collection or object (see below)."]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"groupWith"})," parameter allows you to designate a collection or an object with which the resulting object should be associated."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OB Copy"})," can be used with an entity selection object. By default if ck shared is omitted, a ",(0,r.jsx)(n.em,{children:"non-shareable"})," entity selection is returned. If ck shared is passed, a ",(0,r.jsx)(n.em,{children:"shareable"})," entity selection is returned. In this context, the ",(0,r.jsx)(n.em,{children:"groupWith"})," option is useless since an entity selection does not have a ",(0,r.jsx)(n.em,{children:"locking identifier"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The same principle applies to entity selections stored inside properties of ",(0,r.jsx)(n.em,{children:"object"}),". However, the command is optimized when ck shared is passed and a nested entity selection is ",(0,r.jsx)(n.em,{children:"shareable"}),": the same entity selection reference is returned in the resulting object."]}),"\n",(0,r.jsxs)(n.li,{children:["Datastore, dataclass, and entity objects are not copiable. If ",(0,r.jsx)(n.strong,{children:"OB Copy"})," command is called with them, a Null value is returned"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-1",children:"Example 1"}),"\n",(0,r.jsx)(n.p,{children:"You want to duplicate an object containing simple values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-4d",children:'\xa0var $Object : Object\n\xa0var $JsonString : Text\n\xa0\n\xa0ARRAY OBJECT($arraySel;0)\n\xa0ALL RECORDS([Product])\n\xa0While(Not(End selection([Product])))\n\xa0\xa0\xa0\xa0OB SET($Object;"id";[Product]ID_Product)\n\xa0\xa0\xa0\xa0OB SET($Object;"Product Name";[Product]Product_Name)\n\xa0\xa0\xa0\xa0OB SET($Object;"Price";[Product]Price)\n\xa0\xa0\xa0\xa0OB SET($Object;"Tax rate";[Product]Tax_rate)\n\xa0\xa0\xa0\xa0$ref_value:=OB Copy($Object)\xa0//direct copy\n\xa0\xa0\xa0\xa0APPEND TO ARRAY($arraySel;$ref_value)\n\xa0\xa0//the contents of $ref_value are identical to those of $Object\n\xa0\xa0\xa0\xa0NEXT RECORD([Product])\n\xa0End while\n\xa0\xa0//the contents of $ref_value\n\xa0$JsonString:=JSON Stringify array($arraySel)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"example-2",children:"Example 2"}),"\n",(0,r.jsx)(n.p,{children:"You duplicate an object containing pointers (first syntax):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-4d",children:'\xa0var $ref : Object\n\xa0\n\xa0OB SET($ref;"name";->[Company]name)\xa0//object with pointers\n\xa0OB SET($ref;"country";->[Company]country)\n\xa0ARRAY OBJECT($sel;0)\n\xa0ARRAY OBJECT($sel2;0)\n\xa0\n\xa0ALL RECORDS([Company])\n\xa0\n\xa0While(Not(End selection([Company])))\n\xa0\xa0\xa0\xa0$ref_comp:=OB Copy($ref)\xa0// copy without evaluating pointers\n\xa0\xa0// $ref_comp={"name":"->[Company]name","country":"->[Company]Country"}\n\xa0\xa0\xa0\xa0$ref_comp2:=OB Copy($ref;True)\xa0//copy with evaluation of pointers\n\xa0\xa0// $ref_comp={"name":"4D SAS","country":"France"}\n\xa0\xa0\xa0\xa0APPEND TO ARRAY($sel;$ref_comp)\n\xa0\xa0\xa0\xa0APPEND TO ARRAY($sel2;$ref_comp2)\n\xa0\xa0\xa0\xa0NEXT RECORD([Company])\n\xa0End while\n\xa0\n\xa0$Object:=JSON Stringify array($sel)\n\xa0$Object2:=JSON Stringify array($sel2)\n\xa0\n\xa0\xa0// $Object = [{"name":"","country":""},{"name":"","country":""},...]\n\xa0\xa0// $Object2 = [{"name":"4D SAS","country":"France"},{"name":"4D, Inc","country":"USA"},{"name":"Catalan","country":"France"}...]\n'})}),"\n",(0,r.jsx)(n.h4,{id:"example-3",children:"Example 3"}),"\n",(0,r.jsxs)(n.p,{children:["We want to copy the regular (non shared) ",(0,r.jsx)(n.em,{children:"$person"})," object into the ",(0,r.jsx)(n.em,{children:"$sharedObject"})," shared object. To do this, we must create a shared copy of the object (",(0,r.jsx)(n.em,{children:"$sharedObject"}),")."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-4d",children:'\xa0var $person;$copy;$sharedObject : Object\n\xa0var $text : Text\n\xa0\n\xa0$text:=Document to text(Get 4D folder(Current resources folder)+"person.txt")\n\xa0$person:=JSON Parse($text)\xa0//$person is a standard object\n\xa0$sharedObject:=New shared object()\n\xa0$copy:=OB Copy($person;ck shared)\xa0//$copy is a shared object\n\xa0\n\xa0\xa0//So it can be put in $sharedObject\n\xa0Use($sharedObject)\n\xa0\xa0\xa0\xa0$sharedObject.person:=$copy\n\xa0End use\n'})}),"\n",(0,r.jsx)(n.h4,{id:"example-4",children:"Example 4"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"$obj"}),' contains a pointer ("name" property) on the current record "name" field.']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-4d",children:'\xa0var $obj;$objWithPtr;$sharedObjWithPtr : Object\n\xa0$obj:=New object()\n\xa0\n\xa0\xa0//$obj is an object with a pointer\n\xa0OB SET($obj;"name";->[Persons]name)\n\xa0\n\xa0ALL RECORDS([Persons])\n\xa0\xa0//Now there is a current record on [Persons] table so [Persons]name is filled\n\xa0\xa0//\n\xa0\xa0// If we want to copy $obj as a standard object with evaluation of pointers\n\xa0\xa0// We do this:\n\xa0$objWithPtr:=OB Copy($obj;True)\n\xa0\xa0//\n\xa0\xa0// If we want to copy $obj as a shared object with evaluation of pointers\n\xa0\xa0// We do this:\n\xa0$sharedObjWithPtr:=OB Copy($obj;ck resolve pointers+ck shared)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"example-5",children:"Example 5"}),"\n",(0,r.jsxs)(n.p,{children:["We want to copy ",(0,r.jsx)(n.em,{children:"$sharedObj"})," in ",(0,r.jsx)(n.em,{children:"$sharedColl"})," but since they belong to different shared groups, a direct copy would result in an error. We must make a copy of ",(0,r.jsx)(n.em,{children:"$sharedObj"})," and designate ",(0,r.jsx)(n.em,{children:"$sharedColl"})," as shared group for the copy."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-4d",children:'\xa0var $sharedObj;$objCopy : Object\n\xa0var $sharedColl : Collection\n\xa0\n\xa0\xa0//$sharedObj belongs to a shared group\n\xa0$sharedObj:=New shared object("lastname";"Smith";"address";New shared object("city";"New York"))\n\xa0\xa0//$sharedColl belongs to another shared group\n\xa0$sharedColl:=New shared collection(New shared object("lastname";"Brown"))\n\xa0\n\xa0$objCopy:=OB Copy($sharedObj;ck shared;$sharedColl)\n\xa0\xa0//$objCopy is now in the same shared group as $sharedColl\n\xa0\n\xa0\xa0//So $objCopy can be put in $sharedColl without error\n\xa0Use($sharedColl)\n\xa0\xa0\xa0\xa0$sharedColl.push($objCopy)\n\xa0End use\n'})}),"\n",(0,r.jsx)(n.h4,{id:"see-also",children:"See also"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/commands/ob-get",children:"OB Get"}),(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.em,{children:"Shared objects and shared collections"})]}),"\n",(0,r.jsx)(n.h4,{id:"properties",children:"Properties"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Command number"}),(0,r.jsx)(n.td,{children:"1225"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Thread safe"}),(0,r.jsx)(n.td,{children:"\u2713"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return i},a:function(){return c}});var s=t(667294);let r={},o=s.createContext(r);function c(e){let n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);