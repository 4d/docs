{
	"4D": {
		"Blob": {
			"new()": {
				"Syntax": "**4D.Blob.new()** : 4D.Blob<br/>**4D.Blob.new**( *blobScal* : Blob ) : 4D.Blob<br/>**4D.Blob.new**( *blobObj* : 4D.Blob ) : 4D.Blob",
				"Params": [
					[
						"blob",
						"Blob ou 4D.Blob",
						"->",
						"Blob pour copie"
					],
					[
						"Résultat",
						"4D.Blob",
						"<-",
						"Nouveau 4D.Blob"
					]
				],
				"Summary": "crée un nouvel objet `4D.Blob` encapsulant optionnellement une copie des données d'un autre blob (blob scalaire ou `4D.Blob`)"
			}
		},
		"CryptoKey": {
			"new()": {
				"Syntax": "**4D.CryptoKey.new**( *settings* : Object ) : 4D.CryptoKey",
				"Params": [
					[
						"settings",
						"Object",
						"->",
						"Paramètres pour générer ou charger une paire de clés"
					],
					[
						"Résultat",
						"4D.CryptoKey",
						"<-",
						"Objet contenant une paire de clés de chiffrement"
					]
				],
				"Summary": "crée un nouvel objet `4D.CryptoKey` encapsulant une paire de clés de chiffrement"
			}
		},
		"File": {
			"new()": {
				"Syntax": "**4D.File.new** ( *path* : Text { ; *pathType* : Integer } ) : 4D.File<br/>**4D.File.new** ( *fileConstant* : Integer ) : 4D.File",
				"Summary": "crée et retourne un nouvel objet de type `4D.File`"
			}
		},
		"Folder": {
			"new()": {
				"Syntax": "**4D.Folder.new** ( *path* : Text { ; *pathType* : Integer }{ ; \\* } ) : 4D.Folder<br/>**4D.Folder.new** ( *folderConstant* : Integer { ; \\* } ) : 4D.Folder",
				"Summary": "crée et retourne un nouvel objet de type `4D.Folder`"
			}
		},
		"HTTPAgent": {
			"new()": {
				"Syntax": "**4D.HTTPAgent.new**( { *options* : Object } ) : 4D.HTTPAgent",
				"Params": [
					[
						"options",
						"Object",
						"->",
						"options par défaut pour le HTTPAgent"
					],
					[
						"Résultat",
						"4D.HTTPAgent",
						"<-",
						"Nouvel objet HTTPAgent"
					]
				],
				"Summary": "crée un objet HTTPAgent partageable avec les *options* définies, et renvoie un objet `4D.HTTPAgent`"
			}
		},
		"HTTPRequest": {
			"new()": {
				"Syntax": "**4D.HTTPRequest.new**( *url* : Text { ; *options* : Object } ) : 4D.HTTPRequest",
				"Params": [
					[
						"url",
						"Text",
						"->",
						"URL à laquelle envoyer la requête"
					],
					[
						"options",
						"Object",
						"->",
						"Propriétés de configuration de la requête"
					],
					[
						"Résultat",
						"4D.HTTPRequest",
						"<-",
						"Nouvel objet HTTPRequest"
					]
				],
				"Summary": "crée et envoie une requête HTTP au serveur HTTP défini dans *url* avec les *options* définies, et renvoie un objet `4D.HTTPRequest`"
			}
		},
		"IMAPTransporter": {
			"new()": {
				"Syntax": "**4D.IMAPTransporter.new**( *server* : Object ) : 4D.IMAPTransporter",
				"Params": [
					[
						"server",
						"Object",
						"->",
						"Informations sur le serveur de messagerie"
					],
					[
						"Résultat",
						"4D.IMAPTransporter",
						"<-",
						"Objet transporteur IMAP"
					]
				],
				"Summary": "crée et retourne un nouvel objet de type `4D.IMAPTransporter`"
			}
		},
		"MailAttachment": {
			"new()": {
				"Syntax": "**4D.MailAttachment.new**( *file* : 4D.File { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br/>**4D.MailAttachment.new**( *zipFile* : 4D.ZipFile { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br/>**4D.MailAttachment.new**( *blob* : 4D.Blob { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br/>**4D.MailAttachment.new**( *path* : Text { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment",
				"Params": [
					[
						"file",
						"4D.File",
						"->",
						"Fichier joint"
					],
					[
						"zipFile",
						"4D.ZipFile",
						"->",
						"Fichier Zip joint"
					],
					[
						"blob",
						"4D.Blob",
						"->",
						"Blob contenant la pièce jointe"
					],
					[
						"path",
						"Text",
						"->",
						"Chemin de la pièce jointe"
					],
					[
						"name",
						"Text",
						"->",
						"Nom + extension utilisés par le client de messagerie pour désigner la pièce jointe"
					],
					[
						"cid",
						"Text",
						"->",
						"ID de la pièce jointe (messages HTML uniquement) ou \" \" si aucun cid n'est requis"
					],
					[
						"type",
						"Text",
						"->",
						"Valeur de l'en-tête content-type"
					],
					[
						"disposition",
						"Text",
						"->",
						"Valeur de l'en-tête content-disposition : \"inline\" ou \"attachment\""
					],
					[
						"Résultat",
						"4D.MailAttachment",
						"<-",
						"Objet pièce jointe"
					]
				],
				"Summary": "crée et retourne un nouvel objet de type `4D.MailAttachment`"
			}
		},
		"POP3Transporter": {
			"new()": {
				"Syntax": "**4D.POP3Transporter.new**( *server* : Object ) : 4D.POP3Transporter",
				"Params": [
					[
						"server",
						"Object",
						"->",
						"Informations sur le serveur de messagerie"
					],
					[
						"Résultat",
						"4D.POP3Transporter",
						"<-",
						"Objet POP3 Transporter"
					]
				],
				"Summary": "crée et retourne un nouvel objet de type `4D.POP3Transporter`"
			}
		},
		"SMTPTransporter": {
			"new()": {
				"Syntax": "**4D.SMTPTransporter.new**( *server* : Object ) : 4D.SMTPTransporter",
				"Params": [
					[
						"server",
						"Object",
						"->",
						"Informations sur le serveur de messagerie"
					],
					[
						"Résultat",
						"4D.SMTPTransporter",
						"<-",
						"Objet SMTP Transporter"
					]
				],
				"Summary": "crée et retourne un nouvel objet de type `4D.SMTPTransporter`"
			}
		},
		"SystemWorker": {
			"new()": {
				"Syntax": "**4D.SystemWorker.new** ( *commandLine* : Text { ; options : Object } ) : 4D.SystemWorker",
				"Params": [
					[
						"commandLine",
						"Text",
						"->",
						"Ligne de commande à exécuter"
					],
					[
						"options",
						"Object",
						"->",
						"Paramètres du worker"
					],
					[
						"Résultat",
						"4D.SystemWorker",
						"<-",
						"Nouveau System worker asynchrone ou null si le process n'a pas démarré"
					]
				],
				"Summary": "crée et renvoie un objet `4D.SystemWorker` qui exécutera la *commandLine* que vous avez passée en paramètre pour lancer un process externe"
			}
		},
		"TCPConnection": {
			"new()": {
				"Syntax": "**4D.TCPConnection.new**( *serverAddress* : Text ; *serverPort* : Number ; *options* : Object  ) : 4D.TCPConnection",
				"params": [
					[
						"serverAddress",
						"Text",
						"->",
						"Nom de domaine ou adresse IP du serveur"
					],
					[
						"serverPort",
						"Integer",
						"->",
						"Numéro de port du serveur"
					],
					[
						"options",
						"Object",
						"->",
						"options de configuration de la connexion"
					],
					[
						"Résultat",
						"4D.TCPConnection",
						"<-",
						"Nouvel objet TCPConnection"
					]
				],
				"Summary": "creates a new TCP connection to the specified *serverAddress* and *serverPort*, using the defined *options*, and returns a `4D.TCPConnection` object"
			}
		},
		"TCPListener": {
			"new()": {
				"Syntax": "**4D.TCPListener.new**( *port* : Number ; *options* : Object ) : 4D.TCPListener",
				"params": [
					[
						"port",
						"Number",
						"->",
						"Port TCP à écouter"
					],
					[
						"options",
						"Object",
						"->",
						"options de configuration du listener"
					],
					[
						"Résultat",
						"4D.TCPListener",
						"<-",
						"Nouvel objet TCPListener"
					]
				],
				"Summary": "crée un nouveau serveur TCP écoutant le *port* spécifié en utilisant les *options* définies, et renvoie un objet `4D.TCPListener`"
			}
		},
		"UDPSocket": {
			"new()": {
				"Syntax": "**4D.UDPSocket.new**() : 4D.UDPSocket<br/>**4D.UDPSocket.new**( *options* : Object ) : 4D.UDPSocket<br/>**4D.UDPSocket.new**( *port* : Integer ) : 4D.UDPSocket<br/>**4D.UDPSocket.new**( *port* : Integer ; *options* : Object ) : 4D.UDPSocket",
				"params": [
					[
						"port",
						"Integer",
						"->",
						"Port local utilisé pour le socket UDP (0 ou omis = trouver un port inutilisé à utiliser)"
					],
					[
						"options",
						"Object",
						"->",
						"Configuration options pour le socket"
					],
					[
						"Résultat",
						"UDPSocket",
						"<-",
						"Nouvel objet UDPSocket"
					]
				],
				"Summary": "crée un nouveau socket UDP en utilisant les *options* définies (le cas échéant) sur le *port* spécifié (le cas échéant) ou sur un port aléatoire inutilisé, et renvoie un objet `4D.UDPSocket`"
			}
		},
		"Vector": {
			"new()": {
				"Syntax": "**4D.Vector.new** ( *parameter* : Collection ) : 4D.Vector",
				"Params": [
					[
						"paramètres",
						"Collection of reals",
						"->",
						"Collection of real numbers representing a vector"
					],
					[
						"Résultat",
						"4D.Vector",
						"<-",
						"New Vector object"
					]
				],
				"Summary": "creates and returns a new object of the `4D.Vector` type"
			}
		},
		"WebSocket": {
			"new()": {
				"Syntax": "**4D.WebSocket.new**( *url* : Text { ; *connectionHandler* : Object } ) : 4D.WebSocket",
				"Params": [
					[
						"url",
						"Text",
						"->",
						"URL à laquelle se connecter"
					],
					[
						"connectionHandler",
						"Object",
						"->",
						"Objet déclarant les callbacks WebSocket"
					],
					[
						"Résultat",
						"4D.WebSocket",
						"<-",
						"Nouvel objet WebSocket"
					]
				],
				"Summary": "crée et renvoie un nouvel objet `4D.WebSocket` connecté au serveur WebSocket à l'adresse que vous avez spécifiée dans *url*"
			}
		},
		"WebSocketServer": {
			"new()": {
				"Syntax": "**4D.WebSocketServer.new**( *WSSHandler* : Object { ; *options* : Object } ) : 4D.WebSocketServer",
				"Params": [
					[
						"WSSHandler",
						"Object",
						"->",
						"Objet de la classe utilisateur déclarant les callbacks du serveur WebSocket"
					],
					[
						"options",
						"Object",
						"->",
						"Paramètres de configuration du WebSocket"
					],
					[
						"Résultat",
						"4D.WebSocketServer",
						"<-",
						"Nouvel objet WebSocketServer"
					]
				],
				"Summary": "crée et démarre un serveur WebSocket qui utilisera les callbacks *WSSHandler* et les *options* spécifiées (optionnellement), et renvoie un objet `4D.WebSocketServer`"
			}
		}
	},
	"Blob": {
		"size": {
			"Syntax": "**.size** : Real",
			"Summary": "retourne la taille d'un `4D.Blob`, exprimée en octets."
		},
		"slice()": {
			"Syntax": "**.slice()** : 4D.Blob<br/>**.slice**( *start* : Real ) : 4D.Blob<br/>**.slice**( *start* : Real; *end* : Real ) : 4D.Blob",
			"Params": [
				[
					"start",
					"Real",
					"->",
					"indice du premier octet à inclure dans le nouveau `4D.Blob`."
				],
				[
					"end",
					"Real",
					"->",
					"indice du premier octet qui ne sera pas inclus dans le nouveau `4D.Blob`"
				],
				[
					"Résultat",
					"4D.Blob",
					"<-",
					"Nouveau `4D.Blob`"
				]
			],
			"Summary": "crée et retourne un `4D.Blob` qui référence les données d'un sous-ensemble du blob sur lequel il est appelé. Le blob d'origine n'est pas modifié."
		}
	},
	"Class": {
		"isSessionSingleton": {
			"Syntax": "**.isSessionSingleton** : Boolean",
			"Summary": "renvoie `true` si la classe utilisateur a été définie comme une classe singleton de session"
		},
		"isShared": {
			"Syntax": "**.isShared** : Boolean",
			"Summary": "renvoie `true` si la classe utilisateur a été définie comme classe partagée"
		},
		"isSingleton": {
			"Syntax": "**.isSingleton** : Boolean",
			"Summary": "renvoie `true` si la classe utilisateur a été définie comme une classe singleton"
		},
		"me": {
			"Syntax": "**.me** : 4D.Object",
			"Summary": "renvoie l'instance unique de la classe singleton `cs.className`"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "contient le nom de l'objet `4D.Class`"
		},
		"new()": {
			"Syntax": "**.new**( { *...param* : any } ) : 4D.Object",
			"Params": [
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à la fonction constructeur"
				],
				[
					"Résultat",
					"4D.Object",
					"<-",
					"Nouvel objet de la classe"
				]
			],
			"Summary": "crée et retourne un objet `cs.className` qui est une nouvelle instance de la classe sur laquelle elle est appelée"
		},
		"superclass": {
			"Syntax": "**.superclass** : 4D.Class",
			"Summary": "retourne la classe parente de la classe"
		}
	},
	"Collection": {
		"at()": {
			"Syntax": "**.at**( *index* : Integer ) : any",
			"Params": [
				[
					"index",
					"Integer",
					"->",
					"Indice de l'élément à renvoyer"
				],
				[
					"Résultat",
					"any",
					"<-",
					"L'élément à cet indice"
				]
			],
			"Summary": "retourne l'élément à la position *index*, acceptant des entiers positifs et négatifs"
		},
		"average()": {
			"Syntax": "**.average**( {*propertyPath* : Text } ) : Real",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet à utiliser pour évaluer les valeurs"
				],
				[
					"Résultat",
					"Real, Undefined",
					"<-",
					"Moyenne arithmétique des valeurs de la collection"
				]
			],
			"Summary": "retourne la moyenne arithmétique des valeurs définies dans l'instance de collection"
		},
		"clear()": {
			"Syntax": "**.clear()** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'origine dont tous les éléments ont été supprimés"
				]
			],
			"Summary": "supprime tous les éléments de l'instance de collection et retourne une collection vide"
		},
		"combine()": {
			"Syntax": "**.combine**( *col2* : Collection {; *index* : Integer } ) : Collection",
			"Params": [
				[
					"col2",
					"Collection",
					"->",
					"Collection à combiner"
				],
				[
					"index",
					"Integer",
					"->",
					"Emplacement où insérer les éléments à combiner (défaut=length+1)"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'origine incluant les éléments combinés"
				]
			],
			"Summary": "insère *col2* éléments à la fin ou à la position spécifiée par *index* dans l'instance de collection et retourne la collection modifiée"
		},
		"concat()": {
			"Syntax": "**.concat**( *value* : any { *;...valueN* } ) : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Object, Collection, Date, Time, Boolean, Picture",
					"->",
					"Valeur(s) à concaténer. Si *value* est une collection, tous ses éléments sont ajoutés comme de nouveaux éléments à la fin de la collection d'origine."
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Nouvelle collection contenant les valeurs d'origine et les valeurs ajoutées"
				]
			],
			"Summary": "retourne une nouvelle collection contenant les éléments de la collection d'origine avec tous les éléments du paramètre *value* ajoutés à la fin"
		},
		"copy()": {
			"Syntax": "**.copy**() : Collection<br/>**.copy**( *option* : Integer ) : Collection<br/>**.copy**( *option* : Integer ; *groupWithCol* : Collection ) : Collection<br/>**.copy**( *option* : Integer ; *groupWithObj* : Object ) : Collection",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"`ck resolve pointers`: résoudre les pointeurs avant la copie,<br/>`ck shared`: retourner une collection partagée"
				],
				[
					"groupWithCol",
					"Collection",
					"->",
					"Collection partagée à grouper avec la collection résultante"
				],
				[
					"groupWithObj",
					"Object",
					"->",
					"Objet partagé à grouper avec la collection résultante"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Copie de la collection d'origine (deep copy)"
				]
			],
			"Summary": "renvoie une copie profonde (deep copy) de l'instance de collection"
		},
		"count()": {
			"Syntax": "**.count**( { *propertyPath* : Text } ) : Real",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet à utiliser pour évaluer les valeurs"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Nombre d'éléments dans la collection"
				]
			],
			"Summary": "retourne le nombre d'éléments non nuls dans la collection"
		},
		"countValues()": {
			"Syntax": "**.countValues**( *value* : any {; *propertyPath* : Text } ) : Real",
			"Params": [
				[
					"value",
					"Text, Number, Boolean, Date, Object, Collection",
					"->",
					"Valeur à compter"
				],
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet à utiliser pour évaluer les valeurs"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Nombre d'occurrences de la valeur"
				]
			],
			"Summary": "retourne le nombre d'occurences de *value*  dans la collection"
		},
		"distinct()": {
			"Syntax": "**.distinct**( {*options* : Integer} ) : Collection<br/>**.distinct**( *propertyPath* : Text {; *options* : Integer } ) : Collection",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de l'attribut dont vous souhaitez obtenir les valeurs distinctes"
				],
				[
					"options",
					"Integer",
					"->",
					"`ck diacritical`, `ck count values`"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Nouvelle collection contenant uniquement les valeurs distinctes"
				]
			],
			"Summary": "renvoie une collection contenant uniquement les valeurs distinctes (différentes) de la collection originale"
		},
		"equal()": {
			"Syntax": "**.equal**( *collection2* : Collection {; *option* : Integer } ) : Boolean",
			"Params": [
				[
					"collection2",
					"Collection",
					"->",
					"Collection à comparer"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck diacritical`: évaluation diacritique (\"A\" # \"a\" par exemple)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si les collections sont identiques, sinon faux"
				]
			],
			"Summary": "compare récursivement le contenu de la collection et de *collection2* (comparaison profonde)"
		},
		"every()": {
			"Syntax": "**.every**( { *startFrom* : Integer ; } *formula* : 4D.Function { ;*...param* : any } ) : Boolean<br/>**.every**( { *startFrom* : Integer ; } *methodName* : Text { ;*...param* : any } ) : Boolean",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Elément à partir duquel débuter l'évaluation"
				],
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à *formula* ou *methodName*"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si tous les éléments sont évalués à vrai"
				]
			],
			"Summary": "retourne **true** si tous les éléments de la collection ont été évalués à vrai par le test implémenté dans l'objet *formula* ou la méthode *methodName*"
		},
		"extract()": {
			"Syntax": "**.extract**( *propertyPath* : Text { ; *option* : Integer } ) : Collection<br/>**.extract**( *propertyPath* : Text ;  *targetPath* : Text  { ;...*propertyPathOrTargetPathN* : Text } ) : Collection",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet dont les valeurs doivent être extraites dans la nouvelle collection"
				],
				[
					"targetpath",
					"Text",
					"->",
					"Chemin ou nom de propriété cible"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck keep null` : inclure les propriétés null dans la collection retournée (ignorées par défaut). Paramètre ignoré si *targetPath* est passé."
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Nouvelle collection contenant les valeurs extraites"
				]
			],
			"Summary": "crée et renvoie une nouvelle collection contenant les valeurs *propertyPath* extraites de la collection originale d'objets"
		},
		"fill()": {
			"Syntax": "**.fill**( *value* : any ) : Collection<br/>**.fill**( *value* : any ;  *startFrom*  : Integer { ; *end* : Integer } ) : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Object, Collection, Date, Boolean",
					"->",
					"Valeur de remplissage"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Indice l'élément de départ (inclus)"
				],
				[
					"end",
					"Integer",
					"->",
					"Indice de fin (non inclus)"
				],
				[
					"Résultat",
					"collection",
					"<-",
					"Collection d'origine avec valeurs de remplissage"
				]
			],
			"Summary": "remplit la collection avec la *valeur* spécifiée, éventuellement de l'index *startFrom* à l'index *end*, et renvoie la collection résultante"
		},
		"filter()": {
			"Syntax": "**.filter**( *formula* : 4D.Function { ; *...param* : any } ) : Collection<br/>**.filter**( *methodName* : Text { ; *...param* : any } ) : Collection",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à *formula* ou *methodName*"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Nouvelle collection contenant les éléments filtrés (shallow copy)"
				]
			],
			"Summary": "retourne une nouvelle collection contenant tous les éléments de la collection d'origine pour lesquels le résultat de la *formula* ou de la méthode *methodName* est **true**"
		},
		"find()": {
			"Syntax": "**.find**( { *startFrom* : Integer ; }  *formula* : 4D.Function { ; *...param* : any } ) : any<br/>**.find**( { *startFrom* : Integer ; }  *methodName* : Text { ; *...param* : any } ) : any",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Indice d'élément à partir duquel débuter la recherche"
				],
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à *formula* ou *methodName*"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Première valeur trouvée (Undefined si non trouvée)"
				]
			],
			"Summary": "retourne la première valeur dans la collection pour laquelle le résultat de *formula* ou de *methodName*, appliqué à chaque élément, retourne **true**"
		},
		"findIndex()": {
			"Syntax": "**.findIndex**( { *startFrom* : Integer ; }  *formula* : 4D.Function { ; *...param* : any } ) : Integer<br/>**.findIndex**( { *startFrom* : Integer ; }  *methodName* : Text { ; *...param* : any } ) : Integer",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Indice d'élément à partir duquel débuter la recherche"
				],
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à *formula* ou *methodName*"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du premier élément trouvé (-1 si non trouvé)"
				]
			],
			"Summary": "retourne l'indice, dans la collection, du premier élément pour lequel *formula* ou *methodName*, appliqué à chaque élément, retourne **true**"
		},
		"first()": {
			"Syntax": "**.first**() : any",
			"Params": [
				[
					"Résultat",
					"any",
					"<-",
					"Premier élément de collection"
				]
			],
			"Summary": "retourne le premier élément de la collection"
		},
		"flat()": {
			"Syntax": "**.flat**( { *depth* : Integer } ) : Collection",
			"Params": [
				[
					"depth",
					"Integer",
					"->",
					"La profondeur à laquelle une structure de collection imbriquée doit être mise à plat. Par défaut=1"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection mise à plat"
				]
			],
			"Summary": "crée une nouvelle collection avec tous les éléments des sous-collections concaténés de manière récursive jusqu'à la *depth* spécifiée"
		},
		"flatMap()": {
			"Syntax": "**.flatMap**( *formula* : 4D.Function { ; *...param* : any } ) : Collection<br/>**.flatMap**( *methodName* : Text { ; *...param* : any } ) : Collection",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à *formula* ou *methodName*"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de valeurs transformées et mises à plat sur une profondeur de 1"
				]
			],
			"Summary": "crée une nouvelle collection basée sur le résultat de l'appel de la fonction 4D *formula* ou de la méthode *methodName* sur chaque élément de la collection d'origine et mise à plat sur une profondeur de 1"
		},
		"includes()": {
			"Syntax": "**.includes**( *toSearch* : expression { ; *startFrom* : Integer } ) : Boolean",
			"Params": [
				[
					"toSearch",
					"expression",
					"->",
					"Expression à rechercher dans la collection"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Indice d'élément à partir duquel débuter la recherche"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"True si *toSearch* est trouvé dans la collection"
				]
			],
			"Summary": "retourne True si l'expression *toSearch* est trouvée parmi les éléments de la collection, sinon False"
		},
		"indexOf()": {
			"Syntax": "**.indexOf**(  *toSearch* : expression { ; *startFrom* : Integer } ) : Integer",
			"Params": [
				[
					"toSearch",
					"expression",
					"->",
					"Expression à rechercher dans la collection"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Indice d'élément à partir duquel débuter la recherche"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Indice de la première occurrence de toSearch dans la collection, -1 si non trouvée"
				]
			],
			"Summary": "recherche l'expression *toSearch* parmi les éléments de la collection et retourne l'indice de la première occurrence trouvée, ou -1 si aucune occurrence n'a été trouvée"
		},
		"indices()": {
			"Syntax": "**.indices**(  *queryString* : Text { ; *...value* : any } ) : Collection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Critère(s) de recherche"
				],
				[
					"value",
					"any",
					"->",
					"Valeur(s) à comparer lors de l'utilisation de paramètre(s) dans la chaîne"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Indice(s) d'élément(s) de la collection répondant aux critères de queryString"
				]
			],
			"Summary": "renvoie les indices, dans la collection d'origine, des éléments de la collection d'objets qui correspondent aux conditions de recherche *queryString*"
		},
		"insert()": {
			"Syntax": "**.insert**( *index* : Integer ; *element* : any ) : Collection",
			"Params": [
				[
					"index",
					"Integer",
					"->",
					"Où insérer l'élément"
				],
				[
					"element",
					"any",
					"->",
					"Elément à insérer dans la collection"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'origine incluant l'élément inséré"
				]
			],
			"Summary": "insère *element* à la position *index* spécifiée dans l'instance de collection et renvoie la collection modifiée"
		},
		"join()": {
			"Syntax": "**.join**( *delimiter* : Text { ; *option* : Integer } ) : Text",
			"Params": [
				[
					"delimiter",
					"Text",
					"->",
					"Séparateur à utiliser entre les éléments"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck ignore null or empty` : ignorer les chaînes null ou vides dans le résultat"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne contenant tous les éléments de la collection, séparés par delimiter"
				]
			],
			"Summary": "convertit tous les éléments de la collection en chaînes et les concatène en utilisant la chaîne *delimiter* spécifiée comme séparateur"
		},
		"last()": {
			"Syntax": "**.last**() : any",
			"Params": [
				[
					"Résultat",
					"any",
					"<-",
					"Dernier élément de collection"
				]
			],
			"Summary": "renvoie le dernier élément de la collection"
		},
		"lastIndexOf()": {
			"Syntax": "**.lastIndexOf**( *toSearch* : expression { ; *startFrom* : Integer } ) : Integer",
			"Params": [
				[
					"toSearch",
					"expression",
					"->",
					"Elément à chercher dans la collection"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Indice d'élément à partir duquel débuter la recherche"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de la dernière occurrence de toSearch dans la collection, -1 si non trouvé"
				]
			],
			"Summary": "recherche l'expression *toSearch* parmi les éléments de la collection et renvoie l'indice de la dernière occurrence"
		},
		"length": {
			"Syntax": "**.length** : Integer",
			"Summary": "renvoie le nombre d'éléments de la collection"
		},
		"map()": {
			"Syntax": "**.map**( *formula* : 4D.Function { ; *...param* : any } ) : Collection<br/>**.map**( *methodName* : Text { ; *...param* : any } ) : Collection",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer à *formula* ou *methodName*"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de valeurs transformées"
				]
			],
			"Summary": "crée une nouvelle collection basée sur le résultat de l'appel de la fonction 4D *formula* ou de la méthode *methodName* sur chaque élément de la collection d'origine"
		},
		"max()": {
			"Syntax": "**.max**( { *propertyPath* : Text } ) : any",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet à utiliser pour évaluer les valeurs"
				],
				[
					"Résultat",
					"Boolean, Text, Number, Collection, Object, Date",
					"<-",
					"Valeur maximum de la collection"
				]
			],
			"Summary": "renvoie l'élément ayant la valeur la plus élevée dans la collection"
		},
		"min()": {
			"Syntax": "**.min**( { *propertyPath* : Text } ) : any",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet à utiliser pour évaluer les valeurs"
				],
				[
					"Résultat",
					"Boolean, Text, Number, Collection, Object, Date",
					"<-",
					"Valeur minimum de la collection"
				]
			],
			"Summary": "renvoie l'élément ayant la plus petite valeur dans la collection"
		},
		"multiSort()": {
			"Syntax": "**.multiSort**() : Collection<br/>**.multiSort**( *colsToSort* : Collection ) : Collection<br/>**.multiSort**( *formula* : 4D.Function ; *colsToSort* : Collection ) : Collection",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"colsToSort",
					"Collection",
					"->",
					"Collection de collections et/ou d'objets ayant des propriétés {`collection`:*colToSort*;`order`:`ck ascendant` ou `ck descendant`}"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'origine triée"
				]
			],
			"Summary": "vous permet d'effectuer un tri synchronisé à plusieurs niveaux sur un ensemble de collections"
		},
		"orderBy()": {
			"Syntax": "**.orderBy**( ) : Collection<br/>**.orderBy**( *pathStrings* : Text ) : Collection<br/>**.orderBy**( *pathObjects* : Collection ) : Collection<br/>**.orderBy**( *ascOrDesc* : Integer ) : Collection",
			"Params": [
				[
					"pathStrings",
					"Text",
					"->",
					"Chemin(s) de propriété(s) à utiliser pour trier la collection"
				],
				[
					"pathObjects",
					"Collection",
					"->",
					"Collection d'objets critère"
				],
				[
					"ascOrDesc",
					"Integer",
					"->",
					"`ck ascending` ou `ck descending` (valeurs scalaires)"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Copiée triée de la collection (shallow copy)"
				]
			],
			"Summary": "renvoie une nouvelle collection contenant tous les éléments de la collection dans l'ordre spécifié"
		},
		"orderByMethod()": {
			"Syntax": "**.orderByMethod**( *formula* : 4D.Function { ; ...*extraParam* : expression } ) : Collection<br/>**.orderByMethod**( *methodName* : Text { ; ...*extraParam* : expression } ) : Collection",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"extraParam",
					"any",
					"->",
					"Paramètre(s) à passer"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Copie triée de la collection (shallow copy)"
				]
			],
			"Summary": "renvoie une nouvelle collection contenant tous les éléments de la collection dans l'ordre défini par la fonction 4D *formula* ou la méthode *methodName*"
		},
		"pop()": {
			"Syntax": "**.pop()** : any",
			"Params": [
				[
					"Résultat",
					"any",
					"<-",
					"Dernier élément de collection"
				]
			],
			"Summary": "supprime le dernier élément de la collection et le renvoie comme résultat de la fonction"
		},
		"push()": {
			"Syntax": "**.push**( *element* : any { ;...*elementN* } ) : Collection",
			"Params": [
				[
					"element",
					"any",
					"->",
					"Élément(s) à ajouter à la collection"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection originale contenant des éléments ajoutés"
				]
			],
			"Summary": "ajoute un ou plusieurs *element*(s) à la fin de l'instance de collection et renvoie la collection modifiée"
		},
		"query()": {
			"Syntax": "**.query**( *queryString* : Text ) : Collection<br/>**.query**( *queryString* : Text ; *...value* : any ) : Collection<br/>**.query**( *queryString* : Text ; *querySettings* : Object ) : Collection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Critère(s) de recherche"
				],
				[
					"value",
					"any",
					"->",
					"Valeur(s) à comparer lors de l'utilisation de paramètre(s) dans la chaîne"
				],
				[
					"querySettings",
					"Object",
					"->",
					"Options de requête : paramètres, attributs"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Élément(s) correspondant à queryString dans la collection"
				]
			],
			"Summary": "renvoie tous les éléments d'une collection d'objets qui correspondent aux conditions de recherche"
		},
		"reduce()": {
			"Syntax": "**.reduce**( *formula* : 4D.Function { ; *initValue* : any { ; *...param* : expression }} ) : any<br/>**.reduce**( *methodName* : Text { ; *initValue* : any { ; *...param* : expression }} ) : any",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"initValue",
					"Text, Number, Object, Collection, Date, Boolean",
					"->",
					"Valeur à utiliser comme premier argument du premier appel de *formula* ou methodName\\*"
				],
				[
					"param",
					"expression",
					"->",
					"Paramètre(s) à passer"
				],
				[
					"Résultat",
					"Text, Number, Object, Collection, Date, Boolean",
					"<-",
					"Résultat de la valeur de l'accumulateur"
				]
			],
			"Summary": "applique la callback *formula* ou *methodName* à un accumulateur et à chaque élément de la collection (de gauche à droite) pour la réduire à une valeur unique"
		},
		"reduceRight()": {
			"Syntax": "**.reduceRight**( *formula* : 4D.Function { ; *initValue* : any { ; *...param* : expression }} ) : any<br/>**.reduceRight**( *methodName* : Text { ; *initValue* : any { ; *...param* : expression }} ) : any",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"initValue",
					"Text, Number, Object, Collection, Date, Boolean",
					"->",
					"Valeur à utiliser comme premier argument du premier appel de *formula* ou methodName\\*"
				],
				[
					"param",
					"expression",
					"->",
					"Paramètre(s) à passer"
				],
				[
					"Résultat",
					"Text, Number, Object, Collection, Date, Boolean",
					"<-",
					"Résultat de la valeur de l'accumulateur"
				]
			],
			"Summary": "applique la callback *formula* ou *methodName* à un accumulateur et à chaque élément de la collection (de droite à gauche) pour la réduire à une valeur unique"
		},
		"remove()": {
			"Syntax": "**.remove**( *index* : Integer { ; *howMany* : Integer } ) : Collection",
			"Params": [
				[
					"index",
					"Integer",
					"->",
					"Élément à partir duquel la suppression peut commencer"
				],
				[
					"howMany",
					"Integer",
					"->",
					"Nombre d'éléments à supprimer, ou 1 élément si omis"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection modifiée ne contenant plus le ou les élément(s) supprimé(s)"
				]
			],
			"Summary": "supprime un ou plusieurs élément(s) à partir de la position *index* spécifiée dans la collection et retourne la collection modifiée"
		},
		"resize()": {
			"Syntax": "**.resize**( *size* : Integer { ; *defaultValue* : any } ) : Collection",
			"Params": [
				[
					"size",
					"Integer",
					"->",
					"Nouvelle taille de la collection"
				],
				[
					"defaultValue",
					"Number, Text, Object, Collection, Date, Boolean",
					"->",
					"Valeur par défaut pour remplir de nouveaux éléments"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'origine redimensionnée"
				]
			],
			"Summary": "redéfinit la longueur de la collection à partir de la nouvelle taille spécifiée et retourne la collection redimensionnée"
		},
		"reverse()": {
			"Syntax": "**.reverse( )** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Copie inversée de la collection"
				]
			],
			"Summary": "retourne une copie profonde de la collection avec tous ses éléments dans l'ordre inverse"
		},
		"shift()": {
			"Syntax": "**.shift()** : any",
			"Params": [
				[
					"Résultat",
					"any",
					"<-",
					"Premier élément de collection"
				]
			],
			"Summary": "supprime le premier élément de la collection et le retourne comme résultat de la fonction"
		},
		"slice()": {
			"Syntax": "**.slice**( *startFrom* : Integer { ; *end* : Integer } ) : Collection",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Indice l'élément de départ (inclus)"
				],
				[
					"end",
					"Integer",
					"->",
					"Indice de fin (non inclus)"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Nouvelle collection contenant des éléments découpés (copie superficielle)"
				]
			],
			"Summary": "retourne une partie d'une collection dans une nouvelle collection"
		},
		"some()": {
			"Syntax": "**.some**( { *startFrom* : Integer ; } *formula* : 4D.Function { ; *...param* : any } ) : Boolean<br/>**.some**( { *startFrom* : Integer ; } *methodName* : Text { ; *...param* : any } ) : Boolean",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Elément à partir duquel débuter l'évaluation"
				],
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si au moins un élément a réussi le test"
				]
			],
			"Summary": "retourne true si au moins un élément de la collection a réussi un test implémenté dans *formula* ou *methodName*"
		},
		"sort()": {
			"Syntax": "**.sort**() : Collection<br/>**.sort**( *formula* : 4D.Function { ; *...extraParam* : any } ) : Collection<br/>**.sort**( *methodName* : Text { ; *...extraParam* : any } ) : Collection",
			"Params": [
				[
					"formula",
					"4D.Function",
					"->",
					"Objet formule"
				],
				[
					"methodName",
					"Text",
					"->",
					"Nom de méthode"
				],
				[
					"extraParam",
					"any",
					"->",
					"Paramètre(s) à passer à la méthode"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'origine triée"
				]
			],
			"Summary": "trie les éléments de la collection d'origine et retourne également la collection triée"
		},
		"sum()": {
			"Syntax": "**.sum**( { *propertyPath* : Text } ) : Real",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Chemin de propriété d'objet à utiliser pour évaluer les valeurs"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Somme des valeurs de la collection"
				]
			],
			"Summary": "retourne la somme de toutes les valeurs de l'instance de collection"
		},
		"unshift()": {
			"Syntax": "**.unshift**( *value* : any { ;...*valueN* : any } ) : Collection",
			"Params": [
				[
					"value",
					"Text, Number, Object, Collection, Date",
					"->",
					"Valeur(s) à insérer au début de la collection"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Collection contenant des éléments ajoutés"
				],
				[
					"",
					"",
					"",
					""
				]
			],
			"Summary": "insère *value* au début de la collection"
		}
	},
	"CryptoKey": {
		"curve": {
			"Syntax": "**.curve** : Text",
			"Summary": "nom de la courbe normalisée de la clé"
		},
		"decrypt()": {
			"Syntax": "**.decrypt**( *message* : Text ; *options* : Object ) : Object",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Chaine message à déchiffrer à l'aide de `options.encodingEncrypted` et decrypted."
				],
				[
					"options",
					"Object",
					"->",
					"Options de décodage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut"
				]
			],
			"Summary": "déchiffre le paramètre *message* en utilisant la clé **privée**"
		},
		"encrypt()": {
			"Syntax": "**.encrypt**( *message* : Text ; *options* : Object ) : Text",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Chaine message à chiffrer à l'aide de `options.encodingDecrypted` et encrypted."
				],
				[
					"options",
					"Object",
					"->",
					"Options de chiffrement"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Message chiffré et encodé à l'aide de `options.encodingEncrypted`"
				]
			],
			"Summary": "chiffre le paramètre *message* à l'aide de la clé **publique**"
		},
		"getPrivateKey()": {
			"Syntax": "**.getPrivateKey()** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Clé primaire au format PEM"
				]
			],
			"Summary": "renvoie la clé privée de l'objet `CryptoKey`"
		},
		"getPublicKey()": {
			"Syntax": "**.getPublicKey**() : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Clé publique au format PEM"
				]
			],
			"Summary": "renvoie la clé publique de l'objet `CryptoKey`"
		},
		"pem": {
			"Syntax": "**.pem** : Text",
			"Summary": "PEM definition of an encryption key to load. If the key is a private key, the RSA or ECDSA public key will be deduced from it."
		},
		"sign()": {
			"Syntax": ".**sign** (*message* : Text ; *options* : Object) : Text<br/>.**sign** (*message* : Blob ; *options* : Object) : Text",
			"Params": [
				[
					"message",
					"Text OU Blob",
					"->",
					"Message à signer"
				],
				[
					"options",
					"Object",
					"->",
					"Options de signature"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Signature en représentation Base64 ou Base64URL, selon l'option \"encoding\""
				]
			],
			"Summary": "signe la représentation utf8 d'une chaîne ou d'un blob *message*"
		},
		"size": {
			"Syntax": "**.size** : Integer",
			"Summary": "la taille de la clé en bits"
		},
		"type": {
			"Syntax": "**.type** : Text",
			"Summary": "nom du type de clé - \"RSA\", \"ECDSA\", \"PEM\""
		},
		"verify()": {
			"Syntax": "**.verify**( *message* : Text ; *signature* : Text ; *options* : Object) : Object<br/>*.verify**( *message* : Blob ; *signature* : Text ; *options* : Object) : Object",
			"Params": [
				[
					"message",
					"Text OU Blob",
					"->",
					"Message qui a été utilisé pour produire la signature"
				],
				[
					"signature",
					"Text",
					"->",
					"Signature à vérifier, en représentation Base64 ou Base64URL, selon la valeur `options.encoding`"
				],
				[
					"options",
					"Object",
					"->",
					"Options de signature"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de la vérification"
				]
			],
			"Summary": "vérifie la signature base64 par rapport à la représentation utf8 du *message*"
		}
	},
	"DataClass": {
		"all()": {
			"Syntax": "**.all** ( { *settings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"settings",
					"Object",
					"->",
					"Option de création : contexte"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Références vers toutes les entités de la dataclass"
				]
			],
			"Summary": "requête le datastore pour obtenir toutes les entités liées à la dataclass et les renvoie sous la forme d'une entity selection"
		},
		"clearRemoteCache()": {
			"Syntax": "**.clearRemoteCache()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "vide le cache ORDA d'une dataclass"
		},
		"fromCollection()": {
			"Syntax": "**.fromCollection**( *objectCol* : Collection { ; *settings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"objectCol",
					"Collection",
					"->",
					"Collection d'objets à faire correspondre à des entités"
				],
				[
					"settings",
					"Object",
					"->",
					"Option de création : contexte"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Entity selection issue de la collection"
				]
			],
			"Summary": "met à jour ou crée des entités dans la dataclass en fonction de la collection d'objets *objectCol* et renvoie l'entity selection correspondante"
		},
		"get()": {
			"Syntax": "**.get**( *primaryKey* : Integer { ; *settings* : Object } ) : 4D.Entity<br/>**.get**( *primaryKey* : Text { ; *settings* : Object } ) : 4D.Entity",
			"Params": [
				[
					"primaryKey",
					"Integer OR Text",
					"->",
					"Valeur de la clé primaire de l'entité à récupérer"
				],
				[
					"settings",
					"Object",
					"->",
					"Option de création : contexte"
				],
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Entité correspondant à la clé primaire indiquée"
				]
			],
			"Summary": "requête la dataclass pour récupérer l'entité correspondant au paramètre *primaryKey*"
		},
		"getCount()": {
			"Syntax": "**.getCount()** : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'entités dans la dataclass"
				]
			],
			"Summary": "renvoie le nombre d'entités dans une dataclass"
		},
		"getDataStore()": {
			"Syntax": "**.getDataStore()** : cs.DataStore",
			"Params": [
				[
					"Résultat",
					"cs.DataStore",
					"<-",
					"Datastore de la dataclass"
				]
			],
			"Summary": "renvoie le datastore de la dataclass spécifiée"
		},
		"getInfo()": {
			"Syntax": "**.getInfo()** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur la dataclass"
				]
			],
			"Summary": "renvoie un objet fournissant des informations sur la dataclass"
		},
		"getRemoteCache()": {
			"Syntax": "**.getRemoteCache**() : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Objet décrivant le contenu du cache ORDA pour la dataclass."
				]
			],
			"Summary": "renvoie un objet qui contient le contenu du cache ORDA pour une dataclass"
		},
		"new()": {
			"Syntax": "**.new()** : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Nouvelle entité correspondant à la dataclass"
				]
			],
			"Summary": "crée en mémoire et renvoie une nouvelle entité vierge liée à la Dataclass"
		},
		"newSelection()": {
			"Syntax": "**.newSelection**( { *keepOrder* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"keepOrder",
					"Integer",
					"->",
					"`dk keep ordered` : crée une entity selection triée,<br/>`dk non ordered` : crée une entity selection non triée (défaut si omis)"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection vide liée à la dataclass"
				]
			],
			"Summary": "crée une nouvelle entity selection vierge, non partageable, liée à la dataclass, dans la mémoire"
		},
		"query()": {
			"Syntax": "**.query**( *queryString* : Text { ; *...value* : any } { ; *querySettings* : Object } ) : 4D.EntitySelection <br/>**.query**( *formula* : Object { ; *querySettings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Critères de recherche en texte"
				],
				[
					"formula",
					"Object",
					"->",
					"Critères de recherche en objet formule"
				],
				[
					"value",
					"any",
					"->",
					"Valeur(s) à utiliser comme placeholder(s)"
				],
				[
					"querySettings",
					"Object",
					"->",
					"Options de recherche : parameters, attributes, args, allowFormulas, context, queryPath, queryPlan"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection constituée des entités de la dataclass correspondant au(x) critère(s) de recherche fournis dans *queryString* ou *formula*"
				]
			],
			"Summary": "recherche les entités qui répondent aux critères de recherche spécifiés dans *queryString* ou *formula* et (optionnellement) *value*(s)"
		},
		"setRemoteCacheSettings()": {
			"Syntax": "**.setRemoteCacheSettings**(*settings* : Object)",
			"Params": [
				[
					"settings",
					"Object",
					"->",
					"Objet définissant le timeout et la taille maximum du cache ORDA pour la dataclass."
				]
			],
			"Summary": "définit le timeout et la taille maximale du cache ORDA pour une dataclass."
		}
	},
	"DataStore": {
		"cancelTransaction()": {
			"Syntax": "**.cancelTransaction()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "annule la transaction"
		},
		"clearAllRemoteContexts()": {
			"Syntax": "**.clearAllRemoteContexts()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "efface tous les attributs de tous les contextes actifs dans le datastore"
		},
		"encryptionStatus()": {
			"Syntax": "**.encryptionStatus()**: Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur le chiffrement du datastore courant et de chaque table"
				]
			],
			"Summary": "renvoie un objet fournissant le statut de chiffrement du fichier de données courant"
		},
		"flushAndLock()": {
			"Syntax": "**.flushAndLock()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "vide le cache du datastore local et empêche d'autres process d'effectuer des opérations d'écriture sur la base de données"
		},
		"getAllRemoteContexts()": {
			"Syntax": "**.getAllRemoteContexts()** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets contextes d'optimisation"
				]
			],
			"Summary": "renvoie une collection d'objets contenant des informations sur tous les contextes d'optimisation actifs dans le datastore"
		},
		"getGlobalStamp()": {
			"Syntax": "**.getGlobalStamp**() : Real",
			"Params": [
				[
					"Résultat",
					"Real",
					"<-",
					"Valeur courante du marqueur de modification global"
				]
			],
			"Summary": "retourne la valeur actuelle du marqueur de modification global du datastore"
		},
		"getInfo()": {
			"Syntax": "**.getInfo()**: Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Propriétés du datastore"
				]
			],
			"Summary": "renvoie un objet fournissant des informations sur le datastore"
		},
		"getRemoteContextInfo()": {
			"Syntax": "**.getRemoteContextInfo**(*contextName* : Text) : Object",
			"Params": [
				[
					"contextName",
					"Text",
					"->",
					"Nom du contexte"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Description du contexte"
				]
			],
			"Summary": "renvoie un objet qui contient des informations sur le contexte d'optimisation *contextName* dans le datastore"
		},
		"getRequestLog()": {
			"Syntax": "**.getRequestLog()** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets décrivant les requêtes"
				]
			],
			"Summary": "retourne les requêtes ORDA enregistrées en mémoire sur le poste client"
		},
		"isAdminProtected()": {
			"Syntax": "**.isAdminProtected()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'accès au Data Explorer est désactivé, Faux s'il est activé (défaut)"
				]
			],
			"Summary": "renvoie `True` si l'accès au Data Explorer a été désactivé pour la session de travail"
		},
		"locked()": {
			"Syntax": "**.locked()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si verrouillé"
				]
			],
			"Summary": "renvoie True si le datastore local est actuellement verrouillé"
		},
		"makeSelectionsAlterable()": {
			"Syntax": "**.makeSelectionsAlterable()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "définit toutes les entity selections comme modifiables par défaut dans les datastores de l'application courante"
		},
		"provideDataKey()": {
			"Syntax": "**.provideDataKey**( *curPassPhrase* : Text ) : Object <br/>**.provideDataKey**( *curDataKey* : Object ) : Object",
			"Params": [
				[
					"curPassPhrase",
					"Text",
					"->",
					"Phrase secrète courante"
				],
				[
					"curDataKey",
					"Object",
					"->",
					"Clé de chiffrement des données courante"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Résultat de la mise en correspondance de la clé de chiffrement"
				]
			],
			"Summary": "permet de fournir une clé de chiffrement des données pour le fichier de données courant du datastore et détecte si la clé correspond aux données chiffrées"
		},
		"setAdminProtection()": {
			"Syntax": "**.setAdminProtection**( *status* : Boolean )",
			"Params": [
				[
					"status",
					"Boolean",
					"->",
					"Vrai pour désactiver l'accès au Data Explorer sur le port `webAdmin`, Faux (défaut) pour permettre l'accès"
				]
			],
			"Summary": "permet de désactiver tout accès aux données sur le port d'administration web, y compris pour l'Explorateur de données dans les sessions `WebAdmin`"
		},
		"setGlobalStamp()": {
			"Syntax": "**.setGlobalStamp**( *newStamp* : Real)",
			"Params": [
				[
					"newStamp",
					"Real",
					"->",
					"Nouvelle valeur du marqueur de modification global"
				]
			],
			"Summary": "définit *newStamp* comme la nouvelle valeur du marqueur de modification global du datastore"
		},
		"setRemoteContextInfo()": {
			"Syntax": "**.setRemoteContextInfo**( *contextName* : Text ; *dataClassName* : Text ; *attributes* : Text {; *contextType* : Text { ; *pageLength* : Integer}})<br/>**.setRemoteContextInfo**( *contextName* : Text ; *dataClassName* : Text; *attributesColl* : Collection {; *contextType* : Text { ; *pageLength* : Integer }} )<br/>**.setRemoteContextInfo**( *contextName* : Text ; *dataClassObject* : 4D.DataClass ; *attributes* : Text {; *contextType* : Text { ; *pageLength* : Integer }})<br/>**.setRemoteContextInfo**( *contextName* : Text ; *dataClassObject* : 4D.DataClass ; *attributesColl* : Collection {; *contextType* : Text { ; *pageLength* : Integer }} )",
			"Params": [
				[
					"contextName",
					"Text",
					"->",
					"Nom du contexte"
				],
				[
					"dataClassName",
					"Text",
					"->",
					"Nom de la dataclass"
				],
				[
					"dataClassObject",
					"4D.DataClass",
					"->",
					"Objet dataclass (e.g datastore.Employee)"
				],
				[
					"attributes",
					"Text",
					"->",
					"Liste d'attributs séparés par des virgules"
				],
				[
					"attributesColl",
					"Collection",
					"->",
					"Collection de noms d'attributs (text)"
				],
				[
					"contextType",
					"Text",
					"->",
					"Si passé, \"main\" ou \"currentItem\""
				],
				[
					"pageLength",
					"Integer",
					"->",
					"Taille de page de l'entity selection associée au contexte (80 par défaut)"
				]
			],
			"Summary": "lie les attributs de la dataclass spécifiée au contexte d'optimisation *contextName*"
		},
		"startRequestLog()": {
			"Syntax": "**.startRequestLog**()<br/>**.startRequestLog**( *file* : 4D.File )<br/>**.startRequestLog**( *file* : 4D.File ; *options* : Integer )<br/>**.startRequestLog**( *reqNum* : Integer )",
			"Params": [
				[
					"file",
					"4D.File",
					"->",
					"Objet File"
				],
				[
					"options",
					"Integer",
					"->",
					"Option d'enregistrement de réponse (serveur uniquement)"
				],
				[
					"reqNum",
					"Integer",
					"->",
					"Nombre de requêtes à conserver en mémoire (client seulement)"
				]
			],
			"Summary": "démarre l'enregistrement des requêtes ORDA côté client ou côté serveur"
		},
		"startTransaction()": {
			"Syntax": "**.startTransaction()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "démarre une transaction dans le process courant sur la base de données du datastore"
		},
		"stopRequestLog()": {
			"Syntax": "**.stopRequestLog()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "arrête tout enregistrement des requêtes ORDA sur la machine où elle est appelée (client ou serveur)"
		},
		"unlock()": {
			"Syntax": "**.unlock()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "supprime le verrou courant sur les opérations d'écriture dans le datastore, s'il a été défini dans le même process"
		},
		"validateTransaction()": {
			"Syntax": "**.validateTransaction()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "valide la transaction"
		}
	},
	"Directory": {
		"creationDate": {
			"Syntax": "**.creationDate** : Date",
			"Summary": "la date de création du dossier"
		},
		"creationTime": {
			"Syntax": "**.creationTime** : Time",
			"Summary": "l'heure de création du dossier"
		},
		"exists": {
			"Syntax": "**.exists** : Boolean",
			"Summary": "true si le dossier existe sur le disque"
		},
		"extension": {
			"Syntax": "**.extension** : Text",
			"Summary": "renvoie l'extension du nom du dossier (s'il y en a une)"
		},
		"fullName": {
			"Syntax": "**.fullName** : Text",
			"Summary": "retourne le nom complet du dossier, extension comprise (le cas échéant)"
		},
		"hidden": {
			"Syntax": "**.hidden** : Boolean",
			"Summary": "true si le dossier est défini comme \"hidden\" au niveau du système"
		},
		"isAlias": {
			"Syntax": "**.isAlias** : Boolean",
			"Summary": "toujours **false** pour un objet `Dossier`"
		},
		"isFile": {
			"Syntax": "**.isFile** : Boolean",
			"Summary": "toujours **false** pour un dossier"
		},
		"isFolder": {
			"Syntax": "**.isFolder** : Boolean",
			"Summary": "toujours **true** pour un dossier"
		},
		"isPackage": {
			"Syntax": "**.isPackage** : Boolean",
			"Summary": "true si le dossier est un paquet sous macOS (et existe sur le disque)"
		},
		"modificationDate": {
			"Syntax": "**.modificationDate** : Date",
			"Summary": "la date de la dernière modification du dossier"
		},
		"modificationTime": {
			"Syntax": "**.modificationTime** : Time",
			"Summary": "l'heure de la dernière modification du dossier"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "le nom du dossier, sans l'extension (s'il y en a une)"
		},
		"original": {
			"Syntax": "**.original** : 4D.Folder",
			"Summary": "le même objet Dossier que le dossier"
		},
		"parent": {
			"Syntax": "**.parent** : 4D.Folder",
			"Summary": "l'objet dossier parent du dossier"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "le chemin POSIX du dossier"
		},
		"platformPath": {
			"Syntax": "**.platformPath** : Text",
			"Summary": "le chemin du dossier exprimé dans la syntaxe de la plate-forme courante"
		},
		"copyTo()": {
			"Syntax": "**.copyTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } { ; *overwrite* : Integer } ) : 4D.Folder",
			"Params": [
				[
					"dossierDestination",
					"4D.Folder",
					"->",
					"Dossier de destination"
				],
				[
					"nouveauNom",
					"Text",
					"->",
					"Nom de la copie"
				],
				[
					"overwrite",
					"Integer",
					"->",
					"`fk overwrite` pour écraser les éléments existants"
				],
				[
					"Résultat",
					"4D.Folder",
					"<-",
					"Dossier copié"
				]
			],
			"Summary": "copie l'objet `Folder` dans le *destinationFolder* spécifié"
		},
		"file()": {
			"Syntax": "**.file**( *path* : Text ) : 4D.File",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"Chemin POSIX relatif"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Objet `File` (null si chemin invalide)"
				]
			],
			"Summary": "un objet `File` à l'intérieur de l'objet `Folder` et retourne sa référence"
		},
		"files()": {
			"Syntax": "**.files**( { *options* : Integer } ) : Collection",
			"Params": [
				[
					"options",
					"Integer",
					"->",
					"Options de liste de fichiers"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets dossier enfant"
				]
			],
			"Summary": "retourne une collection d'objets `File` contenus dans le dossier"
		},
		"folder()": {
			"Syntax": "**.folder**( *path* : Text ) : 4D.Folder",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"Chemin POSIX relatif"
				],
				[
					"Résultat",
					"4D.Folder",
					"<-",
					"Objet dossier (null si *path* invalide)"
				]
			],
			"Summary": "crée un objet `Folder` à l'intérieur de l'objet parent `Folder` et retourne sa référence"
		},
		"folders()": {
			"Syntax": "**.folders**( { *options* : Integer } ) : Collection",
			"Params": [
				[
					"options",
					"Integer",
					"->",
					"Options de liste des dossiers"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets dossier enfant"
				]
			],
			"Summary": "retourne une collection d'objets `Folder` contenus dans le dossier parent"
		},
		"getIcon()": {
			"Syntax": "**.getIcon**( { *size* : Integer } ) : Picture",
			"Params": [
				[
					"size",
					"Integer",
					"->",
					"Longueur du côté de l'image retournée (pixels)"
				],
				[
					"Résultat",
					"Picture",
					"<-",
					"Icône"
				]
			],
			"Summary": "retourne l'icône du dossier"
		}
	},
	"Document": {
		"creationDate": {
			"Syntax": "**.creationDate** : Date",
			"Summary": "la date de création du fichier"
		},
		"creationTime": {
			"Syntax": "**.creationTime** : Time",
			"Summary": "l'heure de création du fichier"
		},
		"exists": {
			"Syntax": "**.exists** : Boolean",
			"Summary": "true si le fichier existe sur le disque"
		},
		"extension": {
			"Syntax": "**.extension** : Text",
			"Summary": "l'extension du nom du fichier (s'il y en a une)"
		},
		"fullName": {
			"Syntax": "**.fullName** : Text",
			"Summary": "le nom complet du fichier, y compris son extension (le cas échéant)"
		},
		"hidden": {
			"Syntax": "**.hidden** : Boolean",
			"Summary": "true si le fichier est défini comme \"hidden\" au niveau du système"
		},
		"isAlias": {
			"Syntax": "**.isAlias** : Boolean",
			"Summary": "true si le fichier est un alias, un raccourci ou un lien symbolique"
		},
		"isFile": {
			"Syntax": "**.isFile** : Boolean",
			"Summary": "toujours true pour un fichier"
		},
		"isFolder": {
			"Syntax": "**.isFolder** : Boolean",
			"Summary": "toujours false pour un fichier"
		},
		"isWritable": {
			"Syntax": "**.isWritable** : Boolean",
			"Summary": "true si le fichier existe sur le disque et est modifiable"
		},
		"modificationDate": {
			"Syntax": "**.modificationDate** : Date",
			"Summary": "la date de la dernière modification du fichier"
		},
		"modificationTime": {
			"Syntax": "**.modificationTime** : Time",
			"Summary": "l'heure de la dernière modification du fichier"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "le nom du fichier sans extension (s'il y en a une)"
		},
		"original": {
			"Syntax": "**.original** : 4D.File<br/>**.original** : 4D.Folder",
			"Summary": "l'élément cible d'un fichier alias, d'un raccourci ou d'un lien symbolique"
		},
		"parent": {
			"Syntax": "**.parent** : 4D.Folder",
			"Summary": "l'objet dossier parent du fichier"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "le chemin POSIX du fichier"
		},
		"platformPath": {
			"Syntax": "**.platformPath** : Text",
			"Summary": "le chemin du fichier exprimé dans la syntaxe de la plate-forme courante"
		},
		"size": {
			"Syntax": "**.size** : Real",
			"Summary": "la taille du fichier exprimée en octets"
		},
		"copyTo()": {
			"Syntax": "**.copyTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } { ; *overwrite* : Integer } ) : 4D.File",
			"Params": [
				[
					"dossierDestination",
					"4D.Folder",
					"->",
					"Dossier de destination"
				],
				[
					"nouveauNom",
					"Text",
					"->",
					"Nom de la copie"
				],
				[
					"overwrite",
					"Integer",
					"->",
					"`fk overwrite` pour écraser les éléments existants"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Fichier copié"
				]
			],
			"Summary": "copie l'objet `File` vers le *destinationFolder* spécifié"
		},
		"getContent()": {
			"Syntax": "**.getContent( )** : 4D.Blob",
			"Params": [
				[
					"Résultat",
					"4D.Blob",
					"<-",
					"Contenu du fichier"
				]
			],
			"Summary": "retourne un objet `4D.Blob` contenant le contenu intégral du fichier"
		},
		"getIcon()": {
			"Syntax": "**.getIcon**( { *size* : Integer } ) : Picture",
			"Params": [
				[
					"size",
					"Integer",
					"->",
					"Longueur du côté de l'image retournée (pixels)"
				],
				[
					"Résultat",
					"Picture",
					"<-",
					"Icône"
				]
			],
			"Summary": "l'icône du fichier"
		},
		"getText()": {
			"Syntax": "**.getText**( { *charSetName* : Text { ; *breakMode* : Integer } } ) : Text<br/>**.getText**( { *charSetNum* : Integer { ; *breakMode* : Integer } } ) : Text",
			"Params": [
				[
					"charSetName",
					"Text",
					"->",
					"Nom du jeu de caractères"
				],
				[
					"charSetNum",
					"Integer",
					"->",
					"Numéro du jeu de caractères"
				],
				[
					"breakMode",
					"Integer",
					"->",
					"Mode de traitement des retours à la ligne"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte du document"
				]
			],
			"Summary": "retourne le contenu du fichier sous forme de texte"
		}
	},
	"Email": {
		"attachments": {
			"Syntax": "**.attachments** : Collection",
			"Summary": "collection d'objet(s) `4D.MailAttachment`"
		},
		"bcc": {
			"Syntax": "**.bcc** : Text<br/>**.bcc** : Object<br/>**.bcc** : Collection",
			"Summary": "les adresses des destinataires cachés en Copie Carbone Invisible de l'email"
		},
		"bodyStructure": {
			"Syntax": "**.bodyStructure** : Object",
			"Summary": "objet *EmailBodyPart*, c'est-à-dire la structure MIME complète du body du message (facultatif)"
		},
		"bodyValues": {
			"Syntax": "**.bodyValues** : Object",
			"Summary": "objet *EmailBodyValue*, contenant un objet pour chaque \\<partID\\> de `bodyStructure` (facultatif)"
		},
		"cc": {
			"Syntax": "**.cc** : Text<br/>**.cc** : Object<br/>**.cc** : Collection",
			"Summary": "les adresse(s) email supplémentaire(s) des destinataires en Copie Carbone (CC) de l'email"
		},
		"comments": {
			"Syntax": "**.comments** : Text",
			"Summary": "header de commentaires supplémentaires"
		},
		"from": {
			"Syntax": "**.from** : Text<br/>**.from** : Object<br/>**.from** : Collection",
			"Summary": "l'adresse ou les adresse(s) d'origine de l'email"
		},
		"headers": {
			"Syntax": "**.headers** : Collection",
			"Summary": "d'objets `EmailHeader`, dans l'ordre où ils apparaissent dans le message"
		},
		"htmlBody": {
			"Syntax": "**.htmlBody** : Text",
			"Summary": "représentation HTML du message électronique (jeu de caractères par défaut : UTF-8) (optionnel, SMTP uniquement)"
		},
		"id": {
			"Syntax": "**.id** : Text",
			"Summary": "ID unique du serveur IMAP"
		},
		"inReplyTo": {
			"Syntax": "**.inReplyTo** : Text",
			"Summary": "identifiant(s) du ou des messages originaux auquel/auxquels le message courant est une réponse"
		},
		"keywords": {
			"Syntax": "**.keywords** : Object",
			"Summary": "ensemble de mots-clés sous forme d'objet, où chaque nom de propriété est un mot-clé et chaque valeur est mise à true"
		},
		"messageId": {
			"Syntax": "**.messageId** : Text",
			"Summary": "header d'identification du message (\"message-id\")"
		},
		"receivedAt": {
			"Syntax": "**.receivedAt** : Text",
			"Summary": "de l'arrivée de l'email sur le serveur IMAP au format ISO 8601 UTC (ex : 2020-09-13T16:11:53Z)"
		},
		"references": {
			"Syntax": "**.references** : Collection",
			"Summary": "collection de tous les numéros d'identification des messages de la chaîne de réponse précédente"
		},
		"replyTo": {
			"Syntax": "**.replyTo** : Text<br/>**.replyTo** : Object<br/>**.replyTo** : Collection",
			"Summary": "addresse(s) pour les réponses"
		},
		"sendAt": {
			"Syntax": "**.sendAt** : Text",
			"Summary": "horodatage de l'email au format ISO 8601 UTC"
		},
		"sender": {
			"Syntax": "**.sender** : Text<br/>**.sender** : Object<br/>**.sender** : Collection",
			"Summary": "l'adresse ou les adresses source de l'email"
		},
		"size": {
			"Syntax": "**.size** : Integer",
			"Summary": "taille (exprimée en octets) de l'objet Email renvoyé par le serveur IMAP"
		},
		"subject": {
			"Syntax": "**.subject** : Text",
			"Summary": "description du sujet"
		},
		"textBody": {
			"Syntax": "**.textBody** : Text",
			"Summary": "représentation en texte brut du message électronique (jeu de caractères par défaut : UTF-8) (optionnel, SMTP uniquement)"
		},
		"to": {
			"Syntax": "**.to** : Text<br/>**.to** : Object<br/>**.to** : Collection",
			"Summary": "la ou les adresse(s) des destinataires principaux de l'email"
		}
	},
	"Entity": {
		"clone()": {
			"Syntax": "**.clone()** : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Nouvelle entité référençant l'enregistrement"
				]
			],
			"Summary": "crée en mémoire une nouvelle entité faisant référence au même enregistrement que l'entité d'origine"
		},
		"diff()": {
			"Syntax": "**.diff**( *entityToCompare* : 4D.Entity { ; *attributesToCompare* : Collection } ) : Collection",
			"Params": [
				[
					"entityToCompare",
					"4D.Entity",
					"->",
					"Entité à comparer à l'entité d'origine"
				],
				[
					"attributesToCompare",
					"Collection",
					"->",
					"Noms des attributs à comparer"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Différences entre les entités"
				]
			],
			"Summary": "compare le contenu de deux entités et renvoie leurs différences"
		},
		"drop()": {
			"Syntax": "**.drop**( {*mode* : Integer} ) : Object",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk force drop if stamp changed` : Force la suppression même si le marqueur interne a changé"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Résultat de l'opération de suppression"
				]
			],
			"Summary": "supprime les données contenues dans l'entité"
		},
		"first()": {
			"Syntax": "**.first()**: 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Référence à la première entité de l'entity selection (Null si non trouvée)"
				]
			],
			"Summary": "renvoie une référence vers l'entité en première position dans l'entity selection à laquelle l'entité appartient"
		},
		"fromObject()": {
			"Syntax": "**.fromObject**( *filler* : Object )",
			"Params": [
				[
					"filler",
					"Object",
					"->",
					"Objet avec lequel remplir l'entité"
				]
			],
			"Summary": "remplit une entité avec le contenu du *filler*"
		},
		"getDataClass()": {
			"Syntax": "**.getDataClass()** : 4D.DataClass",
			"Params": [
				[
					"Résultat",
					"4D.DataClass",
					"<-",
					"Dataclass à laquelle appartient l'entité"
				]
			],
			"Summary": "retourne la dataclass de l'entité"
		},
		"getKey()": {
			"Syntax": "**.getKey**( { *mode* : Integer } ) : any",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk key as string`: retourner la clé primaire en texte, quel que soit son type d'origine"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur de la clé primaire de l'entité (Integer ou Text)"
				]
			],
			"Summary": "renvoie la valeur de la clé primaire de l'entité"
		},
		"getRemoteContextAttributes()": {
			"Syntax": "**.getRemoteContextAttributes()** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Attributs de contexte associés à l'entity, séparés par une virgule"
				]
			],
			"Summary": "retourne des informations relatives au contexte d'optimisation utilisé par l'entité"
		},
		"getSelection()": {
			"Syntax": "**.getSelection()**: 4D.EntitySelection",
			"Params": [
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Entity selection à laquelle appartient l'entité (Null si non trouvée)"
				]
			],
			"Summary": "renvoie l'entity selection à laquelle l'entité appartient"
		},
		"getStamp()": {
			"Syntax": "**.getStamp()** : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur du \"stamp\" de l'entité (0 si l'entité vient d'être créée)"
				]
			],
			"Summary": "renvoie la valeur courante du stamp de l'entité"
		},
		"indexOf()": {
			"Syntax": "**.indexOf**( { *entitySelection* : 4D.EntitySelection } ) : Integer",
			"Params": [
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection dans laquelle obtenir la position de l'entité"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Position de l'entité dans l'entity selection"
				]
			],
			"Summary": "retourne la position de l'entité dans une entity selection"
		},
		"isNew()": {
			"Syntax": "**.isNew()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'entité vient juste d'être créée et n'a pas encore été enregistrée. Sinon, Faux."
				]
			],
			"Summary": "renvoie Vrai si l'entité à laquelle elle est appliquée vient d'être créée et n'a pas encore été enregistrée dans le datastore"
		},
		"last()": {
			"Syntax": "**.last()** : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Référence à la dernière entité de l'entity selection (Null si non trouvée)"
				]
			],
			"Summary": "renvoie une référence vers l'entité en dernière position dans l'entity selection à laquelle l'entité appartient"
		},
		"lock()": {
			"Syntax": "**.lock**( { *mode* : Integer } ) : Object",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk reload if stamp changed` : Recharger avant de verrouiller si le marqueur interne a changé"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Résultat de l'opération lock"
				]
			],
			"Summary": "pose un verrou pessimiste sur l'enregistrement référencé par l'entité"
		},
		"next()": {
			"Syntax": "**.next()** : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Référence à l'entité suivante dans l'entity selection (Null si non trouvée)"
				]
			],
			"Summary": "renvoie une référence vers l'entité suivante dans l'entity selection à laquelle l'entité appartient"
		},
		"previous()": {
			"Syntax": "**.previous()**  : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Référence à l'entité précédente dans l'entity selection (Null si non trouvée)"
				]
			],
			"Summary": "renvoie une référence vers l'entité précédente dans l'entity selection à laquelle l'entité appartient"
		},
		"reload()": {
			"Syntax": "**.reload()** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Objet statut"
				]
			],
			"Summary": "recharge le contenu de l'entité en mémoire"
		},
		"save()": {
			"Syntax": "**.save**( { *mode* : Integer } ) : Object",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk auto merge` : Active le mode \"automatic merge\""
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Résultat de la sauvegarde"
				]
			],
			"Summary": "enregistre les modifications apportées à l'entité"
		},
		"toObject()": {
			"Syntax": "**.toObject**() : Object<br/>**.toObject**( *filterString* : Text { ; *options* : Integer}  ) : Object<br/>**.toObject**( *filterCol* : Collection { ; *options* : Integer } ) : Object",
			"Params": [
				[
					"filterString",
					"Text",
					"->",
					"Attribut(s) à extraire (chaînes séparées par des virgules)"
				],
				[
					"filterCol",
					"Collection",
					"->",
					"Collection d'attribut(s) à extraire"
				],
				[
					"options",
					"Integer",
					"->",
					"`dk with primary key`: ajoute la propriété \\_\\_KEY ;<br/>`dk with stamp`: ajoute la propriété \\_STAMP"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet généré à partir de l'entité"
				]
			],
			"Summary": "renvoie un objet qui a été construit à partir de l'entité"
		},
		"touched()": {
			"Syntax": "**.touched()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si au moins un attribut de l'entité a été modifié et non encore sauvegardé, sinon Faux"
				]
			],
			"Summary": "renvoie True si au moins un attribut de l'entité a été modifié depuis que l'entité a été chargée en mémoire ou sauvegardée"
		},
		"touchedAttributes()": {
			"Syntax": "**.touchedAttributes()** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Noms des attributs touchés ou collection vide"
				]
			],
			"Summary": "renvoie les noms des attributs qui ont été modifiés depuis que l'entité a été chargée en mémoire"
		},
		"unlock()": {
			"Syntax": "**.unlock()** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Objet statut"
				]
			],
			"Summary": "supprime le verrou pessimiste sur l'enregistrement correspondant à l'entité"
		}
	},
	"EntitySelection": {
		"add()": {
			"Syntax": "**.add**( *entity* : 4D.Entity ) : 4D.EntitySelection<br/>**.add**( *entitySelection* : 4D.EntitySelection ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entité à ajouter à l'entity selection"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection à ajouter à l'entity selection d'origine"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Entity selection incluant l'*entity* ou *entitySelection*ajoutée"
				]
			],
			"Summary": "ajoute l'*entity* ou l'*entitySelection* spécifiée à l'entity selection originale et renvoie l'entity selection modifiée"
		},
		"and()": {
			"Syntax": "**.and**( *entity* : 4D.Entity ) : 4D.EntitySelection<br/>**.and**( *entitySelection* : 4D.EntitySelection ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entité à intersecter"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection à intersecter"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Entity selection résultante de l'intersection à l'aide de l'opérateur logique ET"
				]
			],
			"Summary": "combine l'entity selection avec un paramètre *entity* ou *entitySelection* en utilisant l'opérateur logique AND"
		},
		"at()": {
			"Syntax": "**.at**( *index* : Integer ) : 4D.Entity",
			"Params": [
				[
					"index",
					"Integer",
					"->",
					"Index de l'entité à renvoyer"
				],
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"L'entité à cet index"
				]
			],
			"Summary": "retourne l'entité à la position *index*, acceptant un entier positif ou négatif"
		},
		"average()": {
			"Syntax": "**.average**( *attributePath* : Text ) : Real",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin de l'attribut à utiliser pour le calcul"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Moyenne arithmétique des valeurs des entités pour l'attribut (Undefined pour une entity selection vide)"
				]
			],
			"Summary": "renvoie la moyenne arithmétique de toutes les valeurs non nulles de *attributePath* dans l'entity selection"
		},
		"clean()": {
			"Syntax": "**.clean**() : 4D.EntitySelection",
			"Params": [
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection sans entités supprimées"
				]
			],
			"Summary": "renvoie une nouvelle entity selection basée sur l'entity selection originale mais sans les entités supprimées, le cas échéant"
		},
		"contains()": {
			"Syntax": "**.contains**( *entity* : 4D.Entity ) : Boolean",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entité à évaluer"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'entité appartient à l'entity selection, sinon Faux"
				]
			],
			"Summary": "renvoie true si la référence de l'entité appartient à l'entity selection"
		},
		"count()": {
			"Syntax": "**.count**( *attributePath* : Text ) : Real",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin de l'attribut à utiliser pour le calcul"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Nombre de valeurs de *attributePath* non null dans l'entity selection"
				]
			],
			"Summary": "renvoie le nombre d'entités de l'entity selection ayant une valeur non nulle pour *attributePath*"
		},
		"copy()": {
			"Syntax": "**.copy**( { *option* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"`ck shared` : retourne une entity selection partageable"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Copie de l'entity selection"
				]
			],
			"Summary": "renvoie une copie de l'entity selection originale"
		},
		"distinct()": {
			"Syntax": "**.distinct**( *attributePath* : Text { ; *options* : Integer } ) : Collection",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin de l'attribut dont vous souhaitez obtenir les valeurs distinctes"
				],
				[
					"options",
					"Integer",
					"->",
					"`dk diacritical`, `dk count values`"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection avec seulement les valeurs distinctes"
				]
			],
			"Summary": "renvoie une collection contenant uniquement des valeurs distinctes (différentes) de *attributePath* dans l'entity selection"
		},
		"distinctPaths()": {
			"Syntax": "**.distinctPaths**( *attribute* : Text ) : Collection",
			"Params": [
				[
					"attribut",
					"Text",
					"->",
					"Nom de l'attribut objet dont vous souhaitez obtenir les chemins d'accès"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Nouvelle collection avec chemins distincts"
				]
			],
			"Summary": "renvoie une collection de chemins distincts trouvés dans l'attribut objet indexé *attribute* de l'entity selection"
		},
		"drop()": {
			"Syntax": "**.drop**( { *mode* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk stop dropping on first error` : stoppe l'exécution de la fonction au niveau de la première entité non-supprimable"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Entity selection vide si exécutée avec succès, sinon entity selection contenant la ou les entité(s) non supprimée(s)"
				]
			],
			"Summary": "supprime les entités appartenant à l'entity selection dans la table liée à sa dataclass"
		},
		"extract()": {
			"Syntax": "**.extract**( *attributePath* : Text { ; *option* : Integer } ) : Collection<br/>**.extract**( *attributePath* { ; *targetPath* } { ; *...attributePathN* : Text ; *targetPathN* : Text } ) : Collection",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin d'attribut dont les valeurs doivent être extraites dans la nouvelle collection"
				],
				[
					"targetPath",
					"Text",
					"->",
					"Chemin ou nom d'attribut cible"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck keep null` : inclure les attributs null dans la collection retournée (ignorés par défaut)."
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection contenant les valeurs extraites"
				]
			],
			"Summary": "renvoie une collection contenant les valeurs de *attributePath* extraites de l'entity selection"
		},
		"first()": {
			"Syntax": "**.first**() : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Référence vers la première entité de l'entity selection (Null si la selection est vide)"
				]
			],
			"Summary": "renvoie une référence à l'entité en première position de l'entity selection"
		},
		"getDataClass()": {
			"Syntax": "**.getDataClass**() : 4D.DataClass",
			"Params": [
				[
					"Résultat",
					"4D.DataClass",
					"<-",
					"Dataclass à laquelle appartient l'entity selection"
				]
			],
			"Summary": "renvoie la dataclass de l'entity selection"
		},
		"getRemoteContextAttributes()": {
			"Syntax": "**.getRemoteContextAttributes**() : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Attributs de contexte associés à l'entity selection, séparés par une virgule"
				]
			],
			"Summary": "retourne des informations sur le contexte d'optimisation utilisé par l'entity selection"
		},
		"isAlterable()": {
			"Syntax": "**.isAlterable**() : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'entity selection est modifiable, sinon Faux"
				]
			],
			"Summary": "retourne Vrai si l'entity selection est modifiable"
		},
		"isOrdered()": {
			"Syntax": "**.isOrdered**() : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'entity selection est triée, sinon Faux"
				]
			],
			"Summary": "retourne Vrai si l'entity selection est ordonnée"
		},
		"last()": {
			"Syntax": "**.last**() : 4D.Entity",
			"Params": [
				[
					"Résultat",
					"4D.Entity",
					"<-",
					"Référence vers la dernière entité de l'entity selection (Null si l'entity selection est vide)"
				]
			],
			"Summary": "renvoie une référence à l'entité en dernière position de l'entity selection"
		},
		"length": {
			"Syntax": "**.length** : Integer",
			"Summary": "contient le nombre d'entités dans l'entity selection"
		},
		"max()": {
			"Syntax": "**.max**( *attributePath* : Text ) : any",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin de l'attribut à utiliser pour le calcul"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur la plus haute de l'attribut"
				]
			],
			"Summary": "retourne la valeur la plus élevée (ou maximale) parmi toutes les valeurs de *attributePath* dans l'entity selection"
		},
		"min()": {
			"Syntax": "**.min**( *attributePath* : Text ) : any",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin de l'attribut à utiliser pour le calcul"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur la plus basse de l'attribut"
				]
			],
			"Summary": "retourne la plus faible valeur (ou valeur minimale) parmi toutes les valeurs de attributePath dans l'entity selection"
		},
		"minus()": {
			"Syntax": "**.minus**( *entity* : 4D.Entity { ; *keepOrder* : Integer } ) : 4D.EntitySelection<br/>**.minus**( *entitySelection* : 4D.EntitySelection { ; *keepOrder* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entité à soustraire"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection à soustraire"
				],
				[
					"keepOrder",
					"Integer",
					"->",
					"`dk keep ordered` (integer) pour conserver l'ordre initial dans l'entity selection résultante"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection ou une nouvelle référence sur l'entity selection existante"
				]
			],
			"Summary": "exclut de l'entity selection à laquelle elle est appliquée l'*entity* ou les entités de *entitySelection* et renvoie l'entity selection résultante"
		},
		"or()": {
			"Syntax": "**.or**( *entity* : 4D.Entity ) : 4D.EntitySelection<br/>**.or**( *entitySelection* : 4D.EntitySelection ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entité à intersecter"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection à intersecter"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection ou nouvelle référence à l'entity selection d'origine"
				]
			],
			"Summary": "combine l'entity selection avec le paramètre *entity* ou *entitySelection* en utilisant l'opérateur logique OR (non exclusif)"
		},
		"orderBy()": {
			"Syntax": "**.orderBy**( *pathString* : Text ) : 4D.EntitySelection<br/>**.orderBy**( *pathObjects* : Collection ) : 4D.EntitySelection",
			"Params": [
				[
					"pathString",
					"Text",
					"->",
					"Chemin(s) d'attribut(s) et mode(s) de tri pour l'entity selection"
				],
				[
					"pathObjects",
					"Collection",
					"->",
					"Collection d'objets critère"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection dans l'ordre spécifié"
				]
			],
			"Summary": "renvoie une nouvelle entity selection triée contenant toutes les entités de l'entity selection dans l'ordre spécifié par les critères *pathString* ou *pathObjects*"
		},
		"orderByFormula()": {
			"Syntax": "**.orderByFormula**( *formulaString* : Text { ; *sortOrder* : Integer } { ; *settings* : Object} ) : 4D.EntitySelection<br/>**.orderByFormula**( *formulaObj* : Object { ; *sortOrder* : Integer } { ; *settings* : Object} ) : 4D.EntitySelection",
			"Params": [
				[
					"formulaString",
					"Text",
					"->",
					"Chaîne formule"
				],
				[
					"formulaObj",
					"Object",
					"->",
					"Objet formule"
				],
				[
					"sortOrder",
					"Integer",
					"->",
					"`dk ascending` (par défaut) ou`dk descending`"
				],
				[
					"settings",
					"Object",
					"->",
					"Paramètre(s) de la formule"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection triée"
				]
			],
			"Summary": "renvoie une nouvelle entity selection triée"
		},
		"query()": {
			"Syntax": "**.query**( *queryString* : Text { ; *...value* : any } { ; *querySettings* : Object } ) : 4D.EntitySelection <br/>**.query**( *formula* : Object { ; *querySettings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Critères de recherche en texte"
				],
				[
					"formula",
					"Object",
					"->",
					"Critères de recherche en objet formule"
				],
				[
					"value",
					"any",
					"->",
					"Valeur(s) à utiliser comme placeholder(s)"
				],
				[
					"querySettings",
					"Object",
					"->",
					"Options de recherche : parameters, attributes, args, allowFormulas, context, queryPath, queryPlan"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection composée d'entités issues de l'entity selection répondant aux critères de recherche spécifiés dans *queryString* ou *formula*"
				]
			],
			"Summary": "recherche les entités qui répondent aux critères de recherche spécifiés dans *queryString* ou *formula* et (optionnellement) *value*(s) parmi toutes les entités de l'entity selection"
		},
		"queryPath": {
			"Syntax": "**.queryPath** : Text",
			"Summary": "contient une description détaillée de la requête telle qu'elle a été réellement exécutée par 4D"
		},
		"queryPlan": {
			"Syntax": "**.queryPlan** : Text",
			"Summary": "contient une description détaillée de la requête juste avant son exécution (c'est-à-dire la requête planifiée)"
		},
		"refresh()": {
			"Syntax": "**.refresh**()",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "\"invalide\" immédiatement les données de l'entity selection dans le cache local ORDA"
		},
		"selected()": {
			"Syntax": "**.selected**( *selectedEntities* : 4D.EntitySelection ) : Object",
			"Params": [
				[
					"selectedEntities",
					"4D.EntitySelection",
					"->",
					"Entity selection avec des entités dont il faut connaître le rang dans l'entity selection"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage(s) d'entités sélectionnées dans l'entity selection"
				]
			],
			"Summary": "renvoie un objet décrivant la ou les position(s) des *selectedEntities* dans l'entity selection d'origine"
		},
		"slice()": {
			"Syntax": "**.slice**( *startFrom* : Integer { ; *end* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Indice auquel démarrer l'opération (inclus)"
				],
				[
					"end",
					"Integer",
					"->",
					"Indice de fin (non inclus)"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection contenant les entités copiées (shallow copy)"
				]
			],
			"Summary": "retourne une partie d'une entity selection dans une nouvelle entity selection"
		},
		"sum()": {
			"Syntax": "**.sum**( *attributePath* : Text ) : Real",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Chemin de l'attribut à utiliser pour le calcul"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Somme des valeurs de l'entity selection"
				]
			],
			"Summary": "retourne la somme de toutes les valeurs de *attributePath* dans l'entity selection"
		},
		"toCollection()": {
			"Syntax": "**.toCollection**( { *options* : Integer { ; *begin* : Integer { ; *howMany* : Integer } } ) : Collection<br/>**.toCollection**( *filterString* : Text {; *options* : Integer { ; *begin* : Integer { ; *howMany* : Integer }}} ) : Collection<br/>**.toCollection**( *filterCol* : Collection {; *options* : Integer { ; *begin* : Integer { ; *howMany* : Integer }}} ) : Collection",
			"Params": [
				[
					"filterString",
					"Text",
					"->",
					"Chemin(s) d'attribut(s) à extraire"
				],
				[
					"filterCol",
					"Collection",
					"->",
					"Collection d'attribut(s) à extraire"
				],
				[
					"options",
					"Integer",
					"->",
					"`dk with primary key` : ajoute la clé primaire<br/>`dk with stamp` : ajoute le marqueur"
				],
				[
					"begin",
					"Integer",
					"->",
					"Désigne la position de début"
				],
				[
					"howMany",
					"Integer",
					"->",
					"Nombre d'entités à extraire"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets contenant les attributs et valeurs de l'entity selection"
				]
			],
			"Summary": "crée et renvoie une collection où chaque élément est un objet contenant un ensemble de propriétés et de valeurs"
		}
	},
	"File": {
		"create()": {
			"Syntax": "**.create()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le fichier a été créé avec succès, sinon Faux"
				]
			],
			"Summary": "crée un fichier sur disque en fonction des propriétés de l'objet `File`"
		},
		"createAlias()": {
			"Syntax": "**.createAlias**( *destinationFolder* : 4D.Folder ; *aliasName* : Text { ; *aliasType* : Integer } ) : 4D.File",
			"Params": [
				[
					"dossierDestination",
					"4D.Folder",
					"->",
					"Dossier de destination pour l'alias ou le raccourci"
				],
				[
					"aliasName",
					"Text",
					"->",
					"Nom de l'alias ou du raccourci"
				],
				[
					"aliasType",
					"Integer",
					"->",
					"Type de lien de l'alias"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Référence du fichier de l'alias ou du raccourci"
				]
			],
			"Summary": "crée un alias (macOS) ou un raccourci (Windows)"
		},
		"delete()": {
			"Syntax": "**.delete**()",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "supprime le fichier"
		},
		"getAppInfo()": {
			"Syntax": "**.getAppInfo**() : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur le fichier de l'application"
				]
			],
			"Summary": "renvoie le contenu des informations d'un fichier d'application sous la forme d'un objet"
		},
		"moveTo()": {
			"Syntax": "**.moveTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } ) : 4D.File",
			"Params": [
				[
					"dossierDestination",
					"4D.Folder",
					"->",
					"Dossier de destination"
				],
				[
					"nouveauNom",
					"Text",
					"->",
					"Nom complet du fichier déplacé"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Fichier déplacé"
				]
			],
			"Summary": "déplace ou déplace et renomme l'objet `File` dans le dossier *destinationFolder* spécifié"
		},
		"open()": {
			"Syntax": "**.open**( { *mode* : Text } ) : 4D.FileHandle<br/>**.open**( { *options* : Object } ) : 4D.FileHandle",
			"Params": [
				[
					"mode",
					"Text",
					"->",
					"Mode d'ouverture : \"read\", \"write\", \"append\""
				],
				[
					"options",
					"Object",
					"->",
					"Options d'ouverture"
				],
				[
					"Résultat",
					"4D.FileHandle",
					"<-",
					"Nouvel objet File handle"
				]
			],
			"Summary": "crée et renvoie un nouvel objet 4D.FileHandle sur le fichier, dans le *mode* spécifié ou avec les *options* spécifiées"
		},
		"rename()": {
			"Syntax": "**.rename**( *newName* : Text ) : 4D.File",
			"Params": [
				[
					"nouveauNom",
					"Text",
					"->",
					"Nouveau nom complet du fichier"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Fichier renommé"
				]
			],
			"Summary": "renomme le fichier avec le nom que vous avez passé dans *newName* et retourne l'objet `File` renommé"
		},
		"setAppInfo()": {
			"Syntax": "**.setAppInfo**( *info* : Object )",
			"Params": [
				[
					"info",
					"Object",
					"->",
					"Propriétés à écrire dans les informations d'un fichier d'application"
				]
			],
			"Summary": "écrit les propriétés *info* en tant que contenu d'information d'un fichier d'application"
		},
		"setContent()": {
			"Syntax": "**.setContent** ( *content* : Blob )",
			"Params": [
				[
					"content",
					"BLOB",
					"->",
					"Nouveau contenu du fichier"
				]
			],
			"Summary": "réécrit l'intégralité du contenu du fichier en utilisant les données stockées dans le BLOB *content*"
		},
		"setText()": {
			"Syntax": "**.setText** ( *text* : Text {; *charSetName* : Text { ; *breakMode* : Integer } } )<br/>**.setText** ( *text* : Text {; *charSetNum* : Integer { ; *breakMode* : Integer } } )",
			"Params": [
				[
					"text",
					"Text",
					"->",
					"Texte à stocker dans le fichier"
				],
				[
					"charSetName",
					"Text",
					"->",
					"Nom du jeu de caractères"
				],
				[
					"charSetNum",
					"Integer",
					"->",
					"Numéro du jeu de caractères"
				],
				[
					"breakMode",
					"Integer",
					"->",
					"Mode de traitement des retours à la ligne"
				]
			],
			"Summary": "écrit *text* comme nouveau contenu du fichier"
		},
		"_inheritedFrom_": "Document"
	},
	"FileHandle": {
		"breakModeRead": {
			"Syntax": "**.breakModeRead** : Text",
			"Summary": "le mode de traitement des sauts de ligne utilisé lors de la lecture du fichier"
		},
		"breakModeWrite": {
			"Syntax": "**.breakModeWrite** : Text",
			"Summary": "le mode de traitement des sauts de ligne utilisé lors de l'écriture dans le fichier"
		},
		"charset": {
			"Syntax": "**.charset** : Text",
			"Summary": "le jeu de caractères utilisé lors de la lecture ou de l'écriture dans le fichier"
		},
		"eof": {
			"Syntax": "**.eof** : Boolean",
			"Summary": "True si l'`offset` a atteint la fin du fichier, et False sinon"
		},
		"file": {
			"Syntax": "**.file** : 4D.File",
			"Summary": "l'objet 4D.File sur lequel le handle a été créé"
		},
		"getSize()": {
			"Syntax": "**.getSize()** : Real",
			"Params": [
				[
					"Résultat",
					"Real",
					"<-",
					"Taille du document en octets"
				]
			],
			"Summary": "renvoie la taille courante du document, exprimée en octets"
		},
		"mode": {
			"Syntax": "**.mode** : Text",
			"Summary": "le mode dans lequel le handle de fichier a été créé : \"read\", \"write\" ou \"append\""
		},
		"offset": {
			"Syntax": "**.offset** : Real",
			"Summary": "l'offset courant du flux de données (position à l'intérieur du document)"
		},
		"readBlob()": {
			"Syntax": "**.readBlob**( *bytes* : Real ) : 4D.Blob",
			"Params": [
				[
					"bytes",
					"Real",
					"->",
					"Nombre d'octets à lire"
				],
				[
					"Résultat",
					"4D.Blob",
					"<-",
					"Octets lus depuis le fichier"
				]
			],
			"Summary": "renvoie un blob d'une taille de *bytes* octets depuis le fichier, à partir de la position courante"
		},
		"readLine()": {
			"Syntax": "**.readLine()** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Ligne de texte"
				]
			],
			"Summary": "renvoie une ligne de texte à partir de la position courante jusqu'à ce qu'un délimiteur de fin de ligne soit rencontré ou que la fin du document soit atteinte"
		},
		"readText()": {
			"Syntax": "**.readText**( { *stopChar* : Text } ) : Text",
			"Params": [
				[
					"stopChar",
					"Text",
					"->",
					"Caractère(s) au(x)quel(s) arrêter la lecture"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte du fichier"
				]
			],
			"Summary": "renvoie le texte du fichier, à partir de la position courante jusqu'à ce que la première chaîne *stopChar* soit rencontrée (si elle est passée) ou que la fin du fichier soit atteinte"
		},
		"setSize()": {
			"Syntax": "**.setSize**( *size* : Real )",
			"Params": [
				[
					"size",
					"Real",
					"->",
					"Nouvelle taille du document en octets"
				]
			],
			"Summary": "définit une nouvelle taille de *size* octets pour le document"
		},
		"writeBlob()": {
			"Syntax": "**.writeBlob**( *blob* : 4D.Blob )",
			"Params": [
				[
					"blob",
					"4D.Blob",
					"->",
					"Blob à écrire dans le fichier"
				]
			],
			"Summary": "écrit *blob* dans le fichier, à partir de la position courante"
		},
		"writeLine()": {
			"Syntax": "**.writeLine**( *lineOfText* : Text )",
			"Params": [
				[
					"lineOfText",
					"Text",
					"->",
					"Texte à écrire"
				]
			],
			"Summary": "écrit le contenu de *lineOfText* à la position courante et insère un délimiteur de fin de ligne"
		},
		"writeText()": {
			"Syntax": "**.writeText**( *textToWrite* : Text )",
			"Params": [
				[
					"textToWrite",
					"Text",
					"->",
					"Texte à écrire"
				]
			],
			"Summary": "écrit le contenu de *textToWrite* à la position courante et n'insère pas de délimiteur de fin de ligne final"
		}
	},
	"Folder": {
		"create()": {
			"Syntax": "**.create()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le dossier a été créé avec succès, sinon Faux"
				]
			],
			"Summary": "crée un dossier sur disque en fonction des propriétés de l'objet `Folder`"
		},
		"createAlias()": {
			"Syntax": "**.createAlias**( *destinationFolder* : 4D.Folder ; *aliasName* : Text { ; *aliasType* : Integer } ) : 4D.File",
			"Params": [
				[
					"dossierDestination",
					"4D.Folder",
					"->",
					"Dossier de destination pour l'alias ou le raccourci"
				],
				[
					"aliasName",
					"Text",
					"->",
					"Nom de l'alias ou du raccourci"
				],
				[
					"aliasType",
					"Integer",
					"->",
					"Type de lien de l'alias"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Référence de l'alias ou du raccourci du dossier"
				]
			],
			"Summary": "crée un alias (macOS) ou un raccourci (Windows)"
		},
		"delete()": {
			"Syntax": "**.delete**( { *option* : Integer } )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Option de suppression du dossier"
				]
			],
			"Summary": "supprime le dossier"
		},
		"moveTo()": {
			"Syntax": "**.moveTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } ) : 4D.Folder",
			"Params": [
				[
					"dossierDestination",
					"4D.Folder",
					"->",
					"Dossier de destination"
				],
				[
					"nouveauNom",
					"Text",
					"->",
					"Nom complet du dossier déplacé"
				],
				[
					"Résultat",
					"4D.Folder",
					"<-",
					"Dossier déplacé"
				]
			],
			"Summary": "déplace ou déplace et renomme l'objet `Folder` (dossier source) dans le dossier *destinationFolder* spécifié"
		},
		"rename()": {
			"Syntax": "**.rename**( *newName* : Text ) : 4D.Folder",
			"Params": [
				[
					"nouveauNom",
					"Text",
					"->",
					"Nouveau nom complet du dossier"
				],
				[
					"Résultat",
					"4D.Folder",
					"<-",
					"Dossier renommé"
				]
			],
			"Summary": "renomme le dossier avec le nom que vous avez passé dans *newName* et retourne l'objet `Folder` renommé"
		},
		"_inheritedFrom_": "Directory"
	},
	"Function": {
		"apply()": {
			"Syntax": "**.apply**() : any<br/>**.apply**( *thisObj* : Object { ; *formulaParams* : Collection } ) : any",
			"Params": [
				[
					"thisObj",
					"Object",
					"->",
					"Objet à retourner par la commande This dans la formule"
				],
				[
					"formulaParams",
					"Collection",
					"->",
					"Collection des valeurs à passer en tant que $1...$n lorsque `formula` est exécuté"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur obtenue à partir de l'exécution de la formule"
				]
			],
			"Summary": "exécute l'objet `formula` auquel elle est appliquée et retourne la valeur résultante"
		},
		"call()": {
			"Syntax": "**.call**() : any<br/>**.call**( *thisObj* : Object { ; ...*params* : any } ) : any",
			"Params": [
				[
					"thisObj",
					"Object",
					"->",
					"Objet à retourner par la commande This dans la formule"
				],
				[
					"params",
					"any",
					"->",
					"Valeur(s) à passer en tant que $1...$n lorsque formula est exécuté"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur obtenue à partir de l'exécution de la formule"
				]
			],
			"Summary": "exécute l'objet `formula` auquel elle est appliquée et retourne la valeur résultante"
		},
		"source": {
			"Syntax": "**.source** : Text",
			"Summary": "contient l'expression source de `formula` sous forme de texte"
		}
	},
	"HTTPAgent": {
		"params": {
			"Syntax": "**options** : Object",
			"Summary": "les options actuellement utilisées par le HTTPAgent"
		},
		"requestsCount": {
			"Syntax": "**requestsCount** : Integer",
			"Summary": "le nombre de requêtes actuellement traitées par le HTTPAgent"
		},
		"freeSocketsCount": {
			"Syntax": "**freeSocketsCount** : Integer",
			"Summary": "le nombre de sockets libres du `maxSockets` associé au HTTPAgent"
		}
	},
	"HTTPRequest": {
		"agent": {
			"Syntax": "**agent** : 4D.HTTPAgent",
			"Summary": "l'objet `agent` passé dans `options` ou l'objet agent global s'il a été omis"
		},
		"dataType": {
			"Syntax": "**dataType** : Text",
			"Summary": "le `dataType` passé dans l'objet `options` lors de l'appel à new(), \"auto\" s'il a été omis"
		},
		"encoding": {
			"Syntax": "**encoding** : Text",
			"Summary": "l'`encoding` passé dans l'objet `options` lors de l'appel à new(), \"UTF-8\" s'il a été omis"
		},
		"errors": {
			"Syntax": "**errors** : Collection",
			"Summary": "la collection de toutes les erreurs si au moins une erreur a été générée"
		},
		"headers": {
			"Syntax": "**headers** : Object",
			"Summary": "les `headers` passés dans l'objet `options` lors de l'appel à new()"
		},
		"method": {
			"Syntax": "**method** : Text",
			"Summary": "la `méthode` passée dans l'objet `options` lors de l'appel à new()"
		},
		"protocol": {
			"Syntax": "**protocol** : Text",
			"Summary": "le `protocole` passé dans l'objet `options` lors de l'appel à new()"
		},
		"response": {
			"Syntax": "**response** : Object",
			"Summary": "la réponse à la requête si elle a reçu au moins le code de statut, sinon undefined"
		},
		"returnResponseBody": {
			"Syntax": "**returnResponseBody** : Boolean",
			"Summary": "le `returnResponseBody` passé dans l'objet `options` lors de l'appel à new()"
		},
		"terminate()": {
			"Syntax": "**.terminate()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "interrompt la requête HTTP"
		},
		"terminated": {
			"Syntax": "**terminated** : Boolean",
			"Summary": "True si la requête est terminée (après l'appel à `onTerminate`), false sinon"
		},
		"timeout": {
			"Syntax": "**timeout** : Real",
			"Summary": "le `timeout` passé dans l'objet `options` lors de l'appel à new()"
		},
		"url": {
			"Syntax": "**url** : Text",
			"Summary": "l'URL de la requête HTTP"
		},
		"wait()": {
			"Syntax": "**.wait**( { *timeout* : Real } ) : 4D.HTTPRequest",
			"Params": [
				[
					"timeout",
					"Real",
					"->",
					"Délai d'attente maximum en secondes pour la réponse"
				],
				[
					"Résultat",
					"4D.HTTPRequest",
					"<-",
					"Objet HTTPRequest"
				]
			],
			"Summary": "attend la réponse du serveur"
		}
	},
	"IMAPTransporter": {
		"addFlags()": {
			"Syntax": "**.addFlags**( *msgIDs* : Collection ; *keywords* :  Object ) : Object<br/>**.addFlags**( *msgIDs* : Text ; *keywords* :  Object ) : Object<br/>**.addFlags**( *msgIDs* : Longint  ; *keywords* :  Object ) : Object",
			"Params": [
				[
					"msgIDs",
					"Collection",
					"->",
					"Collection de chaînes : IDs uniques des messages (texte)<br/>Texte : ID unique d'un message<br/>Numérique (IMAP all) : Tous les messages de la boîte sélectionnée"
				],
				[
					"keywords",
					"Object",
					"->",
					"Mots-clés de flags à ajouter"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération addFlags"
				]
			],
			"Summary": "ajoute des flags (drapeaux) aux `msgIDs` pour les `keywords` spécifiés"
		},
		"append()": {
			"Syntax": "**.append**( *mailObj* : Object ; *destinationBox* : Text ; *options* : Object ) : Object",
			"Params": [
				[
					"mailObj",
					"Object",
					"->",
					"Objet email"
				],
				[
					"destinationBox",
					"Text",
					"->",
					"Mailbox devant recevoir l'objet email"
				],
				[
					"options",
					"Object",
					"->",
					"Objet contenant les informations de charset"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération"
				]
			],
			"Summary": "ajoute un `mailObj` à la boîte `destinationBox`"
		},
		"checkConnectionDelay": {
			"Syntax": "**.checkConnectionDelay** : Integer",
			"Summary": "la durée maximale (en secondes) autorisée avant vérification de la connexion au serveur"
		},
		"copy()": {
			"Syntax": "**.copy**( *msgsIDs* : Collection ; *destinationBox* : Text ) : Object<br/>**.copy**( *allMsgs* : Integer ; *destinationBox* : Text ) : Object",
			"Params": [
				[
					"msgsIDs",
					"Collection",
					"->",
					"Collection d'IDs uniques de messages (texte)"
				],
				[
					"allMsgs",
					"Integer",
					"->",
					"`IMAP all` : tous les messages de la boîte de réception sélectionnée"
				],
				[
					"destinationBox",
					"Text",
					"->",
					"Boîte de réception recevant les messages copiés"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération de copie"
				]
			],
			"Summary": "copie les messages définis par *msgsIDs* ou *allMsgs* vers la *destinationBox* sur le serveur IMAP"
		},
		"createBox()": {
			"Syntax": "**.createBox**( *name* :  Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom de la nouvelle mailbox"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération de création de mailbox"
				]
			],
			"Summary": "crée une boîte de réception avec le `name` passé en paramètre"
		},
		"delete()": {
			"Syntax": "**.delete**( *msgsIDs* : Collection ) : Object<br/>**.delete**( *allMsgs* : Integer ) : Object",
			"Params": [
				[
					"msgsIDs",
					"Collection",
					"->",
					"Collection d'IDs uniques de messages (texte)"
				],
				[
					"allMsgs",
					"Integer",
					"->",
					"`IMAP all` : tous les messages de la boîte de réception sélectionnée"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération de suppression"
				]
			],
			"Summary": "associe le marqueur \"deleted\" aux messages définis dans `msgsIDs` ou `allMsgs`"
		},
		"deleteBox()": {
			"Syntax": "**.deleteBox**( *name* : Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom de la boîte de réception à supprimer"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération de suppression de boîte"
				]
			],
			"Summary": "supprime définitivement la boîte de réception nommée `name` sur le serveur IMAP"
		},
		"expunge()": {
			"Syntax": "**.expunge()** : Object",
			"Summary": "supprime tous les messages marqués \"deleted\" du serveur de messagerie IMAP."
		},
		"getBoxInfo()": {
			"Syntax": "**.getBoxInfo**( { *name* : Text }) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom de la boîte de réception"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet boxInfo"
				]
			],
			"Summary": "retourne un objet `boxInfo` correspondant à la boîte de réception courante ou à la boîte de réception nommée *name*"
		},
		"getBoxList()": {
			"Syntax": "**.getBoxList**( { *parameters* : Object } ) : Collection",
			"Params": [
				[
					"parameters",
					"Object",
					"->",
					"Objet de paramètre"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets mailbox"
				]
			],
			"Summary": "retourne une collection de boîtes aux lettres décrivant toutes les boîtes aux lettres disponibles"
		},
		"getDelimiter()": {
			"Syntax": "**.getDelimiter()** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Caractère de délimitation de hiérarchie"
				]
			],
			"Summary": "retourne le caractère utilisé pour délimiter les niveaux de hiérarchie dans le nom de la boîte aux lettres"
		},
		"getMail()": {
			"Syntax": "**.getMail**( *msgNumber*: Integer { ; *options* : Object } ) : Object<br/>**.getMail**( *msgID*: Text { ; *options* : Object } ) : Object",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Numéro de séquence du message"
				],
				[
					"msgID",
					"Text",
					"->",
					"ID unique du message"
				],
				[
					"options",
					"Object",
					"->",
					"Instructions sur la gestion du message"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet Email"
				]
			],
			"Summary": "retourne l'objet `Email` correspondant au *msgNumber* ou *msgID* dans la boite de réception désignée par l'`IMAP_transporter`"
		},
		"getMails()": {
			"Syntax": "**.getMails**( *ids* : Collection { ; *options* : Object } ) : Object<br/>**.getMails**( *startMsg* : Integer ; *endMsg* : Integer { ; *options* : Object } ) : Object",
			"Params": [
				[
					"ids",
					"Collection",
					"->",
					"Collection d'identifiants de messages"
				],
				[
					"startMsg",
					"Integer",
					"->",
					"Numéro de séquence du premier message"
				],
				[
					"endMsg",
					"Integer",
					"->",
					"Numéro de séquence du dernier message"
				],
				[
					"options",
					"Object",
					"->",
					"Instructions sur la gestion du message"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contenant :<br/><ul><li>une collection d'[objets Email] (EmailObjectClass.md#objet-email) et</li><li>une collection d'ID ou de numéros pour les messages manquants, le cas échéant</li></ul>"
				]
			],
			"Summary": "retourne un objet contenant une collection d'objets `Email`"
		},
		"getMIMEAsBlob()": {
			"Syntax": "**.getMIMEAsBlob**( *msgNumber* : Integer { ; *updateSeen* : Boolean } ) : Blob<br/>**.getMIMEAsBlob**( *msgID* : Text { ; *updateSeen* : Boolean } ) : Blob",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Numéro de séquence du message"
				],
				[
					"msgID",
					"Text",
					"->",
					"ID unique du message"
				],
				[
					"updateSeen",
					"Boolean",
					"->",
					"Si Vrai, le message est marqué comme \"seen\" (lu) dans la boite de réception. Si Faux, le message demeure inchangé."
				],
				[
					"Résultat",
					"BLOB",
					"<-",
					"Blob de la chaine MIME retournée par le serveur mail"
				]
			],
			"Summary": "retourne un BLOB avec le contenu MIME du message correspondant au *msgNumber* ou *msgID* dans la boîte de réception désignée par le `IMAP_transporter`"
		},
		"move()": {
			"Syntax": "**.move**( *msgsIDs* : Collection ; *destinationBox* : Text ) : Object<br/>**.move**( *allMsgs* : Integer ; *destinationBox* : Text ) : Object",
			"Params": [
				[
					"msgsIDs",
					"Collection",
					"->",
					"Collection d'IDs uniques de messages (texte)"
				],
				[
					"allMsgs",
					"Integer",
					"->",
					"`IMAP all` : tous les messages de la boîte de réception sélectionnée"
				],
				[
					"destinationBox",
					"Text",
					"->",
					"Boîte de réception recevant les messages déplacés"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération de déplacement"
				]
			],
			"Summary": "déplace les messages définis par *msgsIDs* ou *allMsgs* vers la *destinationBox* sur le serveur IMAP"
		},
		"numToID()": {
			"Syntax": "**.numToID**( *startMsg* : Integer ; *endMsg* : Integer ) : Collection",
			"Params": [
				[
					"startMsg",
					"Integer",
					"->",
					"Numéro de séquence du premier message"
				],
				[
					"endMsg",
					"Integer",
					"->",
					"Numéro de séquence du dernier message"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'identifiants de messages uniques"
				]
			],
			"Summary": "convertit les numéros de séquence en identifiants uniques IMAP pour les messages de la plage séquentielle désignée par *startMsg* et *endMsg*"
		},
		"removeFlags()": {
			"Syntax": "**.removeFlags**( *msgIDs* : Collection ; *keywords* :  Object ) : Object<br/>**.removeFlags**( *msgIDs* : Text ; *keywords* :  Object ) : Object<br/>**.removeFlags**( *msgIDs* : Longint ; *keywords* :  Object ) : Object",
			"Params": [
				[
					"msgIDs",
					"Collection",
					"->",
					"Collection de chaînes : IDs uniques des messages (texte)<br/>Texte : ID unique d'un message<br/>Numérique (IMAP all) : Tous les messages de la boîte sélectionnée"
				],
				[
					"keywords",
					"Object",
					"->",
					"Mots-clés de flags à supprimer"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération removeFlags"
				]
			],
			"Summary": "supprime les flags (drapeaux) des `msgIDs` pour les `keywords` spécifiés"
		},
		"renameBox()": {
			"Syntax": "**.renameBox**( *currentName* : Text ; *newName* : Text ) : Object",
			"Params": [
				[
					"currentName",
					"Text",
					"->",
					"Nom actuel de la boîte de réception"
				],
				[
					"nouveauNom",
					"Text",
					"->",
					"Nom de la nouvelle mailbox"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération renaming"
				]
			],
			"Summary": "change le nom d'une boîte de réception sur le serveur IMAP"
		},
		"searchMails()": {
			"Syntax": "**.searchMails**( *searchCriteria* : Text ) : Collection",
			"Params": [
				[
					"searchCriteria",
					"Text",
					"->",
					"Critère(s) de recherche"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de numéros de messages"
				]
			],
			"Summary": "recherche les messages qui correspondent aux critères de recherche *searchCriteria* dans la boîte aux lettres courante"
		},
		"selectBox()": {
			"Syntax": "**.selectBox**( *name* : Text { ; *state* : Integer } ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom de la boîte de réception"
				],
				[
					"state",
					"Integer",
					"->",
					"Statut de l'accès à la boite de réception"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet boxInfo"
				]
			],
			"Summary": "sélectionne la boîte de réception *name* comme boîte de réception courante"
		},
		"subscribe()": {
			"Syntax": "**.subscribe**( *name* : Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom de la boîte de réception"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération subscribe"
				]
			],
			"Summary": "permet d'ajouter la boîte spécifiée à l'ensemble des boîtes auxquelles vous avez \"souscrit\" sur le serveur IMAP"
		},
		"unsubscribe()": {
			"Syntax": "**.unsubscribe**( *name* : Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom de la boîte de réception"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de l'opération unsubscribe"
				]
			],
			"Summary": "supprime la boîte spécifiée de l'ensemble des boîtes auxquelles vous avez \"souscrit\""
		},
		"_inheritedFrom_": "Transporter"
	},
	"IncomingMessage": {
		"getBlob()": {
			"Syntax": "**.getBlob**() : Blob",
			"Params": [
				[
					"Résultat",
					"Blob",
					"<-",
					"Body de la requête en tant que Blob"
				]
			],
			"Summary": "renvoie le body de la requête sous forme de Blob"
		},
		"getHeader()": {
			"Syntax": "**.getHeader**( *key* : Text ) : Text",
			"Params": [
				[
					"key",
					"Text",
					"->",
					"Propriété de header (en-tête) à obtenir"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur de la propriété de header"
				]
			],
			"Summary": "renvoie la valeur de l'en-tête *key*"
		},
		"getJSON()": {
			"Syntax": "**.getJSON**() : Variant",
			"Params": [
				[
					"Résultat",
					"Variant",
					"<-",
					"Résolution JSON du body de la requête"
				]
			],
			"Summary": "renvoie le body de la requête sous forme de résolution JSON"
		},
		"getPicture()": {
			"Syntax": "**.getPicture**() : Picture",
			"Params": [
				[
					"Résultat",
					"Picture",
					"<-",
					"Body de la requête en tant qu'image"
				]
			],
			"Summary": "renvoie le body de la requête sous forme d'image (dans le cas d'un body envoyé en tant qu'image)"
		},
		"getText()": {
			"Syntax": "**.getText**() : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Body de la requête en tant que texte"
				]
			],
			"Summary": "renvoie le body de la requête sous forme de texte"
		},
		"headers": {
			"Syntax": "**headers** : Object",
			"Summary": "les headers courants du message entrant sous forme de paires clé/valeur (chaînes)"
		},
		"url": {
			"Syntax": "**url** : Text",
			"Summary": "l'URL de la requête sans la partie *IP:port* et sous forme de chaîne"
		},
		"urlPath": {
			"Syntax": "**urlPath** : Collection",
			"Summary": "l'URL de la requête sans la partie *IP:port* et sous la forme d'une collection de chaînes"
		},
		"urlQuery": {
			"Syntax": "**urlQuery** : Object",
			"Summary": "les paramètres de la requête lorsqu'ils ont été passés dans l'URL sous forme de paires clé/valeur"
		},
		"verb": {
			"Syntax": "**verb** : Text",
			"Summary": "le verbe utilisé par la requête"
		}
	},
	"MailAttachment": {
		"cid": {
			"Syntax": "**.cid** : Text",
			"Summary": "l'ID de la pièce jointe"
		},
		"disposition": {
			"Syntax": "**.disposition** : Text",
			"Summary": "la valeur de l'en-tête `Content-Disposition`"
		},
		"getContent()": {
			"Syntax": "**.getContent()** : 4D.Blob",
			"Params": [
				[
					"Résultat",
					"4D.Blob",
					"<-",
					"Contenu de la pièce jointe"
				]
			],
			"Summary": "retourne le contenu de l'objet pièce jointe dans un objet `4D.Blob`"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "le nom et l'extension de la pièce jointe"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "le chemin POSIX du fichier joint, s'il existe"
		},
		"platformPath": {
			"Syntax": "**.platformPath** : Text",
			"Summary": "le chemin du fichier joint exprimé dans la syntaxe de la plate-forme courante"
		},
		"size": {
			"Syntax": "**.size** : Integer",
			"Summary": "la valeur de l'en-tête `size` du fichier de la pièce jointe"
		},
		"type": {
			"Syntax": "**.type** : Text",
			"Summary": "le `content-type` du fichier de la pièce jointe"
		}
	},
	"OutgoingMessage": {
		"body": {
			"Syntax": "**body** : any",
			"Summary": "le body du message sortant"
		},
		"headers": {
			"Syntax": "**headers** : Object",
			"Summary": "les headers courants du message sortant sous forme de paires clé/valeur"
		},
		"setBody()": {
			"Syntax": "**.setBody**( *body* : any )",
			"Params": [
				[
					"body",
					"any",
					"->",
					"Body du message sortant"
				]
			],
			"Summary": "définit le *body* du message sortant"
		},
		"setHeader()": {
			"Syntax": "**.setHeader**( *key* : Text ; *value* : Text )",
			"Params": [
				[
					"key",
					"Text",
					"->",
					"Propriété de header à définir"
				],
				[
					"value",
					"Text",
					"->",
					"Valeur de la propriété de header"
				]
			],
			"Summary": "fixe la clé *key* du header du message sortant avec la *value* fournie"
		},
		"setStatus()": {
			"Syntax": "**.setStatus**( *status* : Integer )",
			"Params": [
				[
					"status",
					"Integer",
					"->",
					"Statut à définir"
				]
			],
			"Summary": "définit la propriété `status` à la valeur *status* passée"
		},
		"status": {
			"Syntax": "**status** : Integer",
			"Summary": "le statut courant du message sortant"
		}
	},
	"POP3Transporter": {
		"delete()": {
			"Syntax": "**.delete**( *msgNumber* : Integer )",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Numéro du message à supprimer"
				]
			],
			"Summary": "marque l'email *msgNumber* pour suppression sur le serveur POP3"
		},
		"getBoxInfo()": {
			"Syntax": "**.getBoxInfo()** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Objet boxInfo"
				]
			],
			"Summary": "retourne un objet `boxInfo` correspondant à la boite de réception désignée par l'objet POP3 transporter"
		},
		"getMail()": {
			"Syntax": "**.getMail**( *msgNumber* : Integer { ; *headerOnly* : Boolean } ) : Object",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Numéro du message dans la liste"
				],
				[
					"headerOnly",
					"Boolean",
					"->",
					"True pour télécharger uniquement les en-têtes de l'email (par défaut, False)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet Email"
				]
			],
			"Summary": "retourne l'objet `Email` correspondant au *msgNumber* dans la boite de réception désignée par l'objet POP3 transporter"
		},
		"getMailInfo()": {
			"Syntax": "**.getMailInfo**( *msgNumber* : Integer ) : Object",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Numéro du message dans la liste"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet MailInfo"
				]
			],
			"Summary": "retourne un objet `mailInfo` correspondant au *msgNumber* dans la boite de réception désignée par le transporteur `POP3`"
		},
		"getMailInfoList()": {
			"Syntax": "**.getMailInfoList()** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets `mailInfo`"
				]
			],
			"Summary": "retourne une collection d'objets `mailInfo` décrivant tous les messages dans la boite de réception désignée par le transporteur `POP3`"
		},
		"getMIMEAsBlob()": {
			"Syntax": "**.getMIMEAsBlob**( *msgNumber* : Integer ) : Blob",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Numéro du message dans la liste"
				],
				[
					"Résultat",
					"Blob",
					"<-",
					"Blob de la chaine MIME retournée par le serveur mail"
				]
			],
			"Summary": "renvoie un BLOB contenant le contenu MIME du message correspondant au *msgNumber* dans la boîte aux lettres désignée par l'objet `POP3_transporter`"
		},
		"undeleteAll()": {
			"Syntax": "**.undeleteAll()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "supprime tous les marqueurs de suppression définis sur les emails dans le `POP3_transporter`"
		},
		"_inheritedFrom_": "Transporter"
	},
	"Session": {
		"clearPrivileges()": {
			"Syntax": "**.clearPrivileges()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"True si l'exécution est réussie"
				]
			],
			"Summary": "supprime tous les privilèges associés à la session et retourne **True** si l'exécution a réussi"
		},
		"createOTP()": {
			"Syntax": "**.createOTP** ( { *lifespan* : Integer } ) : Text",
			"Params": [
				[
					"lifespan",
					"Integer",
					"->",
					"Durée de vie du token de session en secondes"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"UUID de la session"
				]
			],
			"Summary": "crée un nouvel OTP (One Time Passcode) pour la session et renvoie son UUID de token"
		},
		"expirationDate": {
			"Syntax": "**.expirationDate** : Text",
			"Summary": "la date et l'heure d'expiration du cookie de session"
		},
		"getPrivileges()": {
			"Syntax": "**.getPrivileges**() : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de noms de privilèges (chaînes)"
				]
			],
			"Summary": "renvoie une collection contenant tous les noms de privilèges associés à la session"
		},
		"hasPrivilege()": {
			"Syntax": "**.hasPrivilege**( *privilege* : Text ) : Boolean",
			"Params": [
				[
					"privilege",
					"Text",
					"->",
					"Nom du privilège à vérifier"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si la session dispose du *privilege*, sinon Faux"
				]
			],
			"Summary": "renvoie True si le *privilege* est associé à la session, et False sinon"
		},
		"id": {
			"Syntax": "**.id** : Text",
			"Summary": "l'identifiant unique (UUID) de la session utilisateur"
		},
		"idleTimeout": {
			"Syntax": "**.idleTimeout** : Integer",
			"Summary": "le délai maximal d'inactivité de session (en minutes), au-delà duquel la session est automatiquement fermée par 4D"
		},
		"info": {
			"Syntax": "**.info** : Object",
			"Summary": "décrit le client distant ou la session de procédure stockée sur le serveur, ou la session autonome"
		},
		"isGuest()": {
			"Syntax": "**.isGuest()** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai s'il s'agit d'une session Guest, sinon Faux"
				]
			],
			"Summary": "renvoie True si la session est une session Guest (c'est-à-dire qu'elle n'a aucun privilège)"
		},
		"restore()": {
			"Syntax": "**.restore** ( *token* : Text ) : Boolean",
			"Params": [
				[
					"token",
					"Text",
					"->",
					"UUID du token de session"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"True si la session courante a été remplacée avec succès par la session du token"
				]
			],
			"Summary": "remplace la session courante de l'utilisateur Web par sa session originale correspondant à l'UUID *token*"
		},
		"setPrivileges()": {
			"Syntax": "**.setPrivileges**( *privilege* : Text ) : Boolean<br/>**.setPrivileges**( *privileges* : Collection )<br/>**.setPrivileges**( *settings* : Object ) : Boolean",
			"Params": [
				[
					"privilege",
					"Text",
					"->",
					"Nom de privilège"
				],
				[
					"privileges",
					"Collection",
					"->",
					"Collection de noms de privilèges"
				],
				[
					"settings",
					"Object",
					"->",
					"Objet contenant une propriété \"privileges\" (texte ou collection)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"True si l'exécution est réussie"
				]
			],
			"Summary": "associe le ou les privilège(s) et/ou rôle(s) défini(s) en paramètre à la session et renvoie **True** si l'exécution a réussi"
		},
		"storage": {
			"Syntax": "**.storage** : Object",
			"Summary": "un objet partagé qui peut être utilisé pour stocker des informations disponibles pour tous les process de la session"
		},
		"userName": {
			"Syntax": "**.userName** : Text",
			"Summary": "le nom d'utilisateur associé à la session"
		}
	},
	"Signal": {
		"description": {
			"Syntax": "**.description** : Text",
			"Summary": "contient une description personnalisée pour l'objet `Signal`"
		},
		"signaled": {
			"Syntax": "**.signaled** : Boolean",
			"Summary": "contient le statut courant de l'objet `Signal`"
		},
		"trigger()": {
			"Syntax": "**.trigger( )**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "met la propriété `signaled` de l'objet signal à **true**"
		},
		"wait()": {
			"Syntax": "**.wait**( { *timeout* : Real } ) : Boolean",
			"Params": [
				[
					"timeout",
					"Real",
					"->",
					"Délai d'attente maximum en secondes pour la réponse"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la propriété `.signaled`"
				]
			],
			"Summary": "place le process courant en attente jusqu'à ce que la propriété `.signaled` de l'objet signal devienne **true** ou que le *timeout* optionnel expire"
		}
	},
	"SMTPTransporter": {
		"keepAlive": {
			"Syntax": "**.keepAlive** : Boolean",
			"Summary": "**True** si la connexion SMTP doit rester active jusqu'à la destruction de l'objet `transporter`"
		},
		"send()": {
			"Syntax": "**.send**( *mail* : Object ) : Object",
			"Params": [
				[
					"mail",
					"Object",
					"->",
					"Email à envoyer"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut SMTP"
				]
			],
			"Summary": "envoie l'objet *mail* vers le serveur SMTP défini dans l'objet `transporter` et retourne un objet statut"
		},
		"_inheritedFrom_": "Transporter"
	},
	"SystemWorker": {
		"closeInput()": {
			"Syntax": "**.closeInput**()",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "ferme le flux d'entrée (*stdin*) du process externe"
		},
		"commandLine": {
			"Syntax": "**.commandLine** : Text",
			"Summary": "contient la ligne de commande passée en paramètre à la fonction `new()`"
		},
		"currentDirectory": {
			"Syntax": "**.currentDirectory** : 4D.Folder",
			"Summary": "contient le répertoire de travail dans lequel le process externe est exécuté"
		},
		"dataType": {
			"Syntax": "**.dataType** : Text",
			"Summary": "contient le type du contenu du body de la réponse"
		},
		"encoding": {
			"Syntax": "**.encoding** : Text",
			"Summary": "contient l'encodage du contenu du body de la réponse"
		},
		"errors": {
			"Syntax": "**.errors** : Collection",
			"Summary": "contient une collection d'erreurs 4D en cas d'erreur(s) d'exécution, le cas échéant"
		},
		"exitCode": {
			"Syntax": "**.exitCode** : Integer",
			"Summary": "contient le code de sortie renvoyé par le process externe"
		},
		"hideWindow": {
			"Syntax": "**.hideWindow** : Boolean",
			"Summary": "peut être utilisée pour cacher la fenêtre de la console DOS ou la fenêtre de l'exécutable lancé (**Windows uniquement**)"
		},
		"pid": {
			"Syntax": "**.pid** : Integer",
			"Summary": "contient l'identifiant unique de process (PID) du process externe au niveau du système"
		},
		"postMessage()": {
			"Syntax": "**.postMessage**( *message* : Text)<br/>**.postMessage**( *messageBLOB* : Blob)",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Texte à écrire dans le flux d'entrée (stdin) du process externe"
				],
				[
					"messageBLOB",
					"Blob",
					"->",
					"Octets écrits dans le flux d'entrée"
				]
			],
			"Summary": "vous permet d'écrire dans le flux d'entrée (stdin) du process externe"
		},
		"response": {
			"Syntax": "**.response** : Text<br/>**.response** : Blob",
			"Summary": "contient la concaténation de toutes les données renvoyées une fois la requête terminée"
		},
		"responseError": {
			"Syntax": "**.responseError** : Text",
			"Summary": "contient la concaténation de toutes les erreurs renvoyées, une fois la requête terminée"
		},
		"terminate()": {
			"Syntax": "**.terminate**()",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "force le `SystemWorker` à mettre fin à son exécution"
		},
		"terminated": {
			"Syntax": "**.terminated** : Boolean",
			"Summary": "contient **true** si le process externe est terminé"
		},
		"timeout": {
			"Syntax": "**.timeout** : Integer",
			"Summary": "contient la durée en secondes avant que le process externe soit tué s'il est encore actif"
		},
		"wait()": {
			"Syntax": "**.wait**( {*timeout* : Real} ) : 4D.SystemWorker",
			"Params": [
				[
					"timeout",
					"Real",
					"->",
					"Délai d'attente maximum en secondes pour la réponse"
				],
				[
					"Résultat",
					"4D.SystemWorker",
					"<-",
					"Objet SystemWorker"
				]
			],
			"Summary": "attend la fin de l'exécution du `SystemWorker` ou le *timeout* spécifié"
		}
	},
	"TCPConnection": {
		"address": {
			"Syntax": "**address** : Text",
			"Summary": "l'adresse IP ou le nom de domaine de la machine distante"
		},
		"closed": {
			"Syntax": "**closed** : Boolean",
			"Summary": "si la connexion est fermée"
		},
		"errors": {
			"Syntax": "**errors** : Collection",
			"Summary": "une collection d'objets erreur associés à la connexion"
		},
		"listener": {
			"Syntax": "**listener** : Object",
			"Summary": "l'objet `TCPListener` qui a créé la `TCPConnection`, s'il y en a un"
		},
		"noDelay": {
			"Syntax": "**noDelay** : Boolean",
			"Summary": "si l'algorithme de Nagle est désactivé (`true`) ou activé (`false`)"
		},
		"port": {
			"Syntax": "**port** : Number",
			"Summary": "le numéro de port de la machine distante"
		},
		"send()": {
			"Syntax": "**.send**( *data* : Blob )",
			"params": [
				[
					"data",
					"Blob",
					"->",
					"Données à envoyer"
				]
			],
			"Summary": "envoie les données au serveur"
		},
		"shutdown()": {
			"Syntax": "**.shutdown**()",
			"params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "ferme le canal *écriture* de la connexion (flux client vers serveur)"
		},
		"wait()": {
			"Syntax": "**.wait**( { *timeout* : Real } )",
			"params": [
				[
					"timeout",
					"Real",
					"->",
					"Délai d'attente maximum en secondes pour la réponse"
				]
			],
			"Summary": "attend que la connexion TCP soit fermée ou que le `timeout` spécifié soit atteint"
		}
	},
	"TCPEvent": {
		"data": {
			"Syntax": "**data** : Blob",
			"Summary": "les données associées à l'événement"
		},
		"ip": {
			"Syntax": "**ip** : Text",
			"Summary": "l'adresse IP de la machine distante"
		},
		"port": {
			"Syntax": "**port** : Number",
			"Summary": "le numéro de port de la machine distante"
		},
		"type": {
			"Syntax": "**type** : Text",
			"Summary": "le type d'événement"
		}
	},
	"TCPListener": {
		"errors": {
			"Syntax": "**errors** : Collection",
			"Summary": "une collection d'objets erreur associés à la connexion"
		},
		"port": {
			"Syntax": "**port** : Number",
			"Summary": "le numéro de port de la machine"
		},
		"terminate()": {
			"Syntax": "**.terminate**()",
			"params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "ferme le listener et libère le port"
		}
	},
	"Transporter": {
		"acceptUnsecureConnection": {
			"Syntax": "**.acceptUnsecureConnection** : Boolean",
			"Summary": "**True** si 4D est autorisé à établir une connexion non chiffrée"
		},
		"authenticationMode": {
			"Syntax": "**.authenticationMode** : Text",
			"Summary": "le mode d'authentification utilisé pour ouvrir la session sur le serveur de messagerie"
		},
		"bodyCharset": {
			"Syntax": "**.bodyCharset** : Text",
			"Summary": "le charset et l'encodage utilisés pour la partie body de l'email"
		},
		"connectionTimeOut": {
			"Syntax": "**.connectionTimeOut** : Integer",
			"Summary": "le temps d'attente maximum (en secondes) autorisé pour établir une connexion avec le serveur"
		},
		"headerCharset": {
			"Syntax": "**.headerCharset** : Text",
			"Summary": "le jeu de caractères et l'encodage utilisés pour l'en-tête de l'e-mail"
		},
		"host": {
			"Syntax": "**.host** : Text",
			"Summary": "le nom ou l'adresse IP du serveur hôte"
		},
		"logFile": {
			"Syntax": "**.logFile** : Text",
			"Summary": "le chemin du fichier journal étendu défini (le cas échéant) pour la connexion de messagerie"
		},
		"port": {
			"Syntax": "**.port** : Integer",
			"Summary": "le numéro de port utilisé pour les transactions de courrier"
		},
		"sendTimeOut": {
			"Syntax": "**.sendTimeOut** : Integer",
			"Summary": "le temps d'attente maximum (en secondes) d'un appel à `.send()` avant le timeout"
		},
		"user": {
			"Syntax": "**.user** : Text",
			"Summary": "le nom d'utilisateur utilisé pour l'authentification sur le serveur de messagerie"
		},
		"checkConnection()": {
			"Syntax": "**.checkConnection()** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de la connexion de l'objet transporteur"
				]
			],
			"Summary": "vérifie la connexion en utilisant les informations stockées dans l'objet transporteur"
		}
	},
	"UDPEvent": {
		"data": {
			"Syntax": "**data** : Blob",
			"Summary": "les données associées à l'événement"
		},
		"ip": {
			"Syntax": "**ip** : Text",
			"Summary": "l'adresse IP de la machine distante"
		},
		"port": {
			"Syntax": "**port** : Number",
			"Summary": "le numéro de port de la machine distante"
		},
		"type": {
			"Syntax": "**type** : Texte",
			"Summary": "le type d'événement"
		}
	},
	"UDPSocket": {
		"errors": {
			"Syntax": "**errors** : Collection",
			"Summary": "une collection d'objets d'erreur associés au socket"
		},
		"port": {
			"Syntax": "**port** : Number",
			"Summary": "le numéro du port à écouter"
		},
		"send()": {
			"Syntax": "**.send**( *data* : Blob ; *hostName* : Text ; *remotePort* : Integer )",
			"params": [
				[
					"data",
					"Blob",
					"->",
					"Données à envoyer"
				],
				[
					"hostName",
					"Text",
					"->",
					"Nom ou adresse IP du serveur"
				],
				[
					"remotePort",
					"Integer",
					"->",
					"Port distant auquel se connecter (0=n'importe lequel)"
				]
			],
			"Summary": "envoie des *data* au serveur distant *hostName* sur le *remotePort* spécifié"
		}
	},
	"Vector": {
		"cosineSimilarity()": {
			"Syntax": "**.cosineSimilarity**( *vector* : 4D.Vector ) : Real",
			"Params": [
				[
					"vector",
					"4D.Vector",
					"->",
					"Vector to compare with"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Distance between vectors"
				]
			],
			"Summary": "calculates the cosine similarity between the current 4D vector and the one you passed in the *vector* parameter"
		},
		"dotSimilarity()": {
			"Syntax": "**.dotSimilarity**( *vector* : 4D.Vector ) : Real",
			"Params": [
				[
					"vector",
					"4D.Vector",
					"->",
					"Vector to compare with"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Distance between vectors"
				]
			],
			"Summary": "calculates the dot product of the current 4D vector and the one you passed in the *vector* parameter"
		},
		"euclideanDistance()": {
			"Syntax": "**.euclideanDistance**( *vector* : 4D.Vector ) : Real",
			"Params": [
				[
					"vector",
					"4D.Vector",
					"->",
					"Vector to compare with"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Distance between vectors"
				]
			],
			"Summary": "calculates the Euclidean distance between the current 4D vector and the one you passed in the *vector* parameter"
		},
		"length": {
			"Syntax": "**length** : Integer",
			"Summary": "the number of vector components"
		},
		"toCollection()": {
			"Syntax": "**.toCollection**() : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection of real numbers representing the vector components"
				]
			],
			"Summary": "returns the vector components as a collection of reals"
		}
	},
	"WebForm": {
		"componentName": {
			"Syntax": "***.componentName*** : 4D.WebFormItem",
			"Summary": "objets disponibles directement en tant que propriétés"
		},
		"disableState()": {
			"Syntax": "**.disableState**( *state* : string)",
			"Params": [
				[
					"state",
					"string",
					"->",
					"Nom de l'état à désactiver dans le formulaire web"
				]
			],
			"Summary": "désactive le rendu de l'*état* dans le formulaire web courant"
		},
		"enableState()": {
			"Syntax": "**.enableState**( *state* : string )",
			"Params": [
				[
					"state",
					"string",
					"->",
					"Nom de l'état à activer sur le formulaire web"
				]
			],
			"Summary": "active le rendu de l'*état* dans le formulaire web courant"
		},
		"setError()": {
			"Syntax": "**.setError**( *msg* : string)",
			"Params": [
				[
					"msg",
					"string",
					"->",
					"Message d'erreur à afficher dans le webform"
				]
			],
			"Summary": "envoie *msg* en tant que message d'erreur vers le formulaire web"
		},
		"setMessage()": {
			"Syntax": "**.setMessage**( *msg* : string)",
			"Params": [
				[
					"msg",
					"string",
					"->",
					"Message d'information à afficher dans le webform"
				]
			],
			"Summary": "envoie *msg* en tant que message d'information au formulaire web"
		},
		"setWarning()": {
			"Syntax": "**.setWarning**( *msg* : string)",
			"Params": [
				[
					"msg",
					"string",
					"->",
					"Message d'avertissement à afficher dans le webform"
				]
			],
			"Summary": "envoie *msg* en tant que message d'avertissement au formulaire web"
		}
	},
	"_command_": {
		"Web Form": {
			"Syntax": "**Web Form** : 4D.WebForm",
			"Params": [
				[
					"Résultat",
					"4D.WebForm",
					"<-",
					"Nouvel objet proxy `WebForm`"
				]
			],
			"Summary": "renvoie un objet proxy `4D.WebForm` qui vous permet d'interagir avec le formulaire web"
		},
		"Web Event": {
			"Syntax": "**Web Event** : Object",
			"Params": [
				[
					"Résultat",
					"object",
					"<-",
					"object"
				]
			],
			"Summary": "renvoie un objet contenant des informations sur un événement déclenché lié à un composant de formulaire web"
		},
		"Call chain": {
			"Syntax": "**Call chain** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets décrivant la chaîne d'appels au sein d'un process"
				]
			],
			"Summary": "La commande **Call chain** renvoie une collection d'objets décrivant chaque maillon de la chaîne d'appels des méthodes dans le process courant."
		},
		"Command name": {
			"Syntax": "**Command name** ( *command* {; *info* {; *theme*}} ) : Text",
			"Params": [
				[
					"command",
					"Integer",
					"->",
					"Numéro de commande"
				],
				[
					"info",
					"Integer",
					"<-",
					"Propriété de la commande à évaluer"
				],
				[
					"theme",
					"Text",
					"<-",
					"Thème du langage de la commande"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la commande"
				]
			],
			"Summary": "retourne le nom ainsi que (optionnellement) les propriétés de la commande dont vous passez le numéro dans *commande*"
		},
		"Compile project": {
			"Syntax": "**Compile project** {( {*projectFile*}{;}{*options*} )} : Object",
			"Params": [
				[
					"projectFile",
					"4D.File",
					"->",
					"Fichier .4DProject à compiler"
				],
				[
					"options",
					"Object",
					"->",
					"Objet qui spécifie les options de compilation"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contenant des informations sur le statut de compilation"
				]
			],
			"Summary": "vous permet de compiler le projet hôte courant ou le projet spécifié dans le paramètre *projectFile*."
		},
		"Create deployment license": {
			"Syntax": "**Create deployment license** ( *mergedApp* ; *autoLicenseTarget* ) : Object<br/>**Create deployment license** ( *mergedApp* ; *buildLicense* {; *oemLicense*} ) : Object",
			"Params": [
				[
					"mergedApp",
					"4D.Folder",
					"->",
					"Folder containing the merged application"
				],
				[
					"autoLicenseTarget",
					"Integer",
					"->",
					"Target license for automatic license embedding"
				],
				[
					"buildLicense",
					"4D.File",
					"->",
					"License required to generate the embedded license"
				],
				[
					"oemLicense",
					"4D.File",
					"->",
					"4D OEM XML Key license if server license"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut"
				]
			],
			"Summary": "The **Create deployment license** command creates an embedded license file in the Licenses folder of the *mergedApp* built application."
		},
		"Create entity selection": {
			"Syntax": "**Create entity selection** ( *dsTable* : Table { ; *settings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"dsTable",
					"Table",
					"->",
					"Table de la base 4D dont la sélection courante doit être utilisée pour construire l'entity selection"
				],
				[
					"settings",
					"Object",
					"->",
					"Option de création : contexte"
				],
				[
					"Résultat",
					"4D.EntitySelection",
					"<-",
					"Nouvelle entity selection liée à la dataclass de la table"
				]
			],
			"Summary": "construit et renvoie une nouvelle entity selection modifiable relative à la classe de données correspondant à la *dsTable* fournie, en fonction de la sélection actuelle de cette table"
		},
		"DIALOG": {
			"Syntax": "**DIALOG** ( {*aTable* ;} *form* {; *formData*}{; *} )",
			"Params": [
				[
					"aTable",
					"Table",
					"->",
					"Table à laquelle appartient le formulaire; Si omis : Table par défaut ou utilisation d'un formulaire projet"
				],
				[
					"form",
					"Text, Object",
					"->",
					"Nom du formulaire table ou projet à afficher, ou Chemin POSIX (chaîne) d'un fichier .json décrivant le formulaire, ou Objet décrivant le formulaire"
				],
				[
					"formData",
					"Object",
					"->",
					"Données à associer au formulaire"
				],
				[
					"\\*",
					"Opérateur",
					"->",
					"Utiliser le même process"
				]
			],
			"Summary": "The **DIALOG** command presents the *form* to the user, along with *formData* parameter(s) (optional)."
		},
		"ds": {
			"Syntax": "**ds** { ( *localID* : Text ) } : cs.DataStore",
			"Params": [
				[
					"localID",
					"Text",
					"->",
					"Identifiant local du datastore distant"
				],
				[
					"Résultat",
					"cs.DataStore",
					"<-",
					"Nouvelle référence de datastore"
				]
			],
			"Summary": "retourne une référence vers le datastore correspondant à la base de données 4D courante ou à la base de données désignée par *localID*"
		},
		"File": {
			"Syntax": "**File** ( *path* : Text { ; *pathType* : Integer }{ ; \\* } ) : 4D.File<br/>**File** ( *fileConstant* : Integer { ; \\* } ) : 4D.File",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"Chemin de fichier"
				],
				[
					"fileConstant",
					"Integer",
					"->",
					"Constante de fichier 4D"
				],
				[
					"pathType",
					"Integer",
					"->",
					"`fk posix path` (par défaut) ou `fk platform path`"
				],
				[
					"\\*",
					"operator",
					"->",
					"\\* pour retourner le fichier de la base hôte"
				],
				[
					"Résultat",
					"4D.File",
					"<-",
					"Nouvel objet fichier"
				]
			],
			"Summary": "crée et retourne un nouvel objet de type `4D.File`"
		},
		"Folder": {
			"Syntax": "**Folder** ( *path* : Text { ; *pathType* : Integer }{ ; \\* } ) : 4D.Folder<br/>**Folder** ( *folderConstant* : Integer { ; \\* } ) : 4D.Folder",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"Chemin du dossier"
				],
				[
					"folderConstant",
					"Integer",
					"->",
					"Constante de dossier 4D"
				],
				[
					"pathType",
					"Integer",
					"->",
					"`fk posix path` (par défaut) ou `fk platform path`"
				],
				[
					"\\*",
					"operator",
					"->",
					"\\* pour retourner le dossier de la base hôte"
				],
				[
					"Résultat",
					"4D.Folder",
					"<-",
					"Nouvel objet dossier"
				]
			],
			"Summary": "crée et retourne un nouvel objet de type `4D.Folder`"
		},
		"FORM EDIT": {
			"Syntax": "**FORM EDIT** ( {*aTable* ;} *form* )<br/>**FORM EDIT** ( {*aTable* ;} *form* ; *object* )",
			"Params": [
				[
					"aTable",
					"Table",
					"->",
					"Table à laquelle appartient le formulaire; Si omis : Table par défaut ou utilisation d'un formulaire projet"
				],
				[
					"form",
					"Text",
					"->",
					"Nom du formulaire"
				],
				[
					"object",
					"Text",
					"->",
					"Nom de l'objet du formulaire ou nom du groupe"
				]
			],
			"Summary": "The **FORM EDIT** command opens the *form* associated to *aTable* in the 4D Form editor, with optionnally *object* selected."
		},
		"Form event code": {
			"Syntax": "**Form event code**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro d'événement formulaire"
				]
			]
		},
		"FORM Event": {
			"Syntax": "**FORM Event** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Objet événement"
				]
			],
			"Summary": "**FORM Event** returns an object containing information about the form event that has just occurred."
		},
		"FORM LOAD": {
			"Syntax": "**FORM LOAD** ( {*aTable* ;} *form* {; *formData*}{; *} )",
			"Params": [
				[
					"aTable",
					"Table",
					"->",
					"Formulaire table à charger (si omis, charger un formulaire projet)"
				],
				[
					"form",
					"Text, Object",
					"->",
					"Nom (chaîne) du formulaire (projet ou table), ou chemin POSIX (chaîne) vers un fichier .json décrivant le formulaire, ou objet décrivant le formulaire à ouvrir"
				],
				[
					"formData",
					"Object",
					"->",
					"Données à associer au formulaire"
				],
				[
					"\\*",
					"Opérateur",
					"->",
					"Si passé = la commande s'applique à la base de données hôte lorsqu'elle est exécutée à partir d'un composant (paramètre ignoré en dehors de ce contexte)"
				]
			],
			"Summary": "The **FORM LOAD** command is used to load the *form* in memory in the current process along with *formData* (optional) in order to print its data or parse its contents."
		},
		"Form": {
			"Syntax": "**Form**  : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Données du formulaire actuel"
				]
			],
			"Summary": "The **Form** command returns the object associated with the current form (instantiated from the *formData* parameter or the user class assigned in the Form editor)."
		},
		"Formula from string": {
			"Syntax": "**Formula from string**( *formulaString* : Text ) : 4D.Function<br/>**Formula from string**( *formulaString* : Text ; *context* : Longint ) : 4D.Function",
			"Params": [
				[
					"formulaString",
					"Text",
					"->",
					"Formule texte à retourner comme objet"
				],
				[
					"context",
					"Number",
					"->",
					"`sk execute in current database` (par défaut) ou `sk execute in host database`"
				],
				[
					"Résultat",
					"4D.Function",
					"<-",
					"Objet natif encapsulant la formule"
				]
			],
			"Summary": "crée un objet `4D.Function` basé sur *formulaString* et, éventuellement, *context*"
		},
		"Formula": {
			"Syntax": "**Formula** ( *formulaExp* : Expression ) : 4D.Function",
			"Params": [
				[
					"formulaExp",
					"Expression",
					"->",
					"Formule à retourner comme objet"
				],
				[
					"Résultat",
					"4D.Function",
					"<-",
					"Fonction native encapsulant la formule"
				]
			],
			"Summary": "crée un objet `4D Function` basé sur l'expression *formulaExp*"
		},
		"HTTP Parse message": {
			"Syntax": "**HTTP Parse message** ( *data* : Text ) : Object<br/>**HTTP Parse message**( *data* : Blob ) : Object",
			"Params": [
				[
					"data",
					"Text, Blob",
					"->",
					"Données à analyser"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet dont chaque propriété est une partie des données multiparties"
				]
			],
			"Summary": "analyse un texte ou un blob multipart/form-data (message HTTP \"response\") et extrait le contenu dans un objet. Chaque propriété de l'objet renvoyé correspond à une partie des données multiparties"
		},
		"IMAP New transporter": {
			"Syntax": "**IMAP New transporter**( *server* : Object ) : 4D.IMAPTransporter",
			"Params": [
				[
					"server",
					"Object",
					"->",
					"Informations sur le serveur de messagerie"
				],
				[
					"Résultat",
					"4D.IMAPTransporter",
					"<-",
					"Objet IMAP transporter"
				]
			],
			"Summary": "configure une nouvelle connexion IMAP"
		},
		"Last errors": {
			"Syntax": "**Last errors** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets erreur"
				]
			],
			"Summary": "La commande **Last errors** renvoie la pile d'erreurs courante de l'application 4D sous la forme d'une collection d'objets erreur, ou **null** si aucune erreur ne s'est produite."
		},
		"License info": {
			"Syntax": "**License info** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur la licence active"
				]
			],
			"Summary": "The **License info** command returns an object providing detailed information about the active license."
		},
		"LISTBOX Get property": {
			"Syntax": "**LISTBOX Get property** ( {* ;} *object* ; *property* ) : any",
			"Params": [
				[
					"\\*",
					"Opérateur",
					"->",
					"If specified, object is an object name (string). If omitted, object is a variable"
				],
				[
					"object",
					"any",
					"->",
					"Nom de l'objet (si \\* est spécifié) ou Variable (si \\* est omis)"
				],
				[
					"property",
					"Integer",
					"->",
					"Property whose value you want to get"
				],
				[
					"Résultat",
					"Integer, Text",
					"<-",
					"Current value"
				]
			],
			"Summary": "The **LISTBOX Get property** command returns the value of the *property* of the list box or column specified using the *object* and *\\** parameters."
		},
		"LISTBOX SET PROPERTY": {
			"Syntax": "**LISTBOX SET PROPERTY** ( {* ;} *object* ; *property* ; *value* )",
			"Params": [
				[
					"\\*",
					"Opérateur",
					"->",
					"If specified, object is an object name (string). If specified, object is an object name (string)."
				],
				[
					"object",
					"any",
					"->",
					"Nom de l'objet (si \\* est spécifié) ou Variable (si \\* est omis)"
				],
				[
					"property",
					"Integer",
					"->",
					"List box or column property"
				],
				[
					"value",
					"Integer, Text",
					"->",
					"Value of property"
				]
			],
			"Summary": "The **LISTBOX SET PROPERTY** command sets the *value* for the *property* of the list box or list box column specified using the *object* and *\\** parameters."
		},
		"MAIL Convert from MIME": {
			"Syntax": "**MAIL Convert from MIME**( *mime* : Blob ) : Object<br/>**MAIL Convert from MIME**( *mime* : Text ) : Object",
			"Params": [
				[
					"mime",
					"Blob, Text",
					"->",
					"Email en MIME"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet email"
				]
			],
			"Summary": "convertit un document MIME en un objet email valide"
		},
		"MAIL Convert to MIME": {
			"Syntax": "**MAIL Convert to MIME**( *mail* : Object { ; *options* : Object } ) : Text",
			"Params": [
				[
					"mail",
					"Object",
					"->",
					"Objet email"
				],
				[
					"options",
					"Object",
					"->",
					"Options d'encodage et de charset du mail"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Objet email converti en MIME"
				]
			],
			"Summary": "convertit un objet email en texte MIME"
		},
		"MAIL New attachment": {
			"Syntax": "**MAIL New attachment**( *file* : 4D.File { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br/>**MAIL New attachment**( *zipFile* : 4D.ZipFile { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br/>**MAIL New attachment**( *blob* : 4D.Blob { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br/>**MAIL New attachment**( *path* : Text { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment",
			"Params": [
				[
					"file",
					"4D.File",
					"->",
					"Fichier joint"
				],
				[
					"zipFile",
					"4D.ZipFile",
					"->",
					"Fichier Zip joint"
				],
				[
					"blob",
					"4D.Blob",
					"->",
					"Blob contenant la pièce jointe"
				],
				[
					"path",
					"Text",
					"->",
					"Chemin de la pièce jointe"
				],
				[
					"name",
					"Text",
					"->",
					"Nom + extension utilisés par le client de messagerie pour désigner la pièce jointe"
				],
				[
					"cid",
					"Text",
					"->",
					"ID de la pièce jointe (messages HTML uniquement) ou \" \" si aucun cid n'est requis"
				],
				[
					"type",
					"Text",
					"->",
					"Valeur de l'en-tête content-type"
				],
				[
					"disposition",
					"Text",
					"->",
					"Valeur de l'en-tête content-disposition : \"inline\" ou \"attachment\""
				],
				[
					"Résultat",
					"4D.MailAttachment",
					"<-",
					"Objet pièce jointe"
				]
			],
			"Summary": "vous permet de créer un objet pièce jointe que vous pouvez ajouter à un objet Email"
		},
		"New collection": {
			"Syntax": "**New collection** {( *...value* : any )} : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Date, Time, Boolean, Object, Collection, Picture, Pointer",
					"->",
					"Valeur(s) de collection"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"New collection"
				]
			],
			"Summary": "crée une nouvelle collection vide ou pré-remplie et retourne sa référence."
		},
		"New log file": {
			"Syntax": "**New log file** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin complet du fichier journal fermé"
				]
			],
			"Summary": "La commande **New log file** referme le fichier journal courant, le renomme et en crée un nouveau avec le même nom et le même emplacement que le précédent"
		},
		"New shared collection": {
			"Syntax": "**New shared collection** {( *...value* : any )} : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Date, Time, Boolean, Object, Collection",
					"->",
					"Valeur(s) de la collection partagée"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"New shared collection"
				]
			],
			"Summary": "crée une nouvelle collection partagée vide ou préremplie"
		},
		"New signal": {
			"Syntax": "**New signal** { ( *description* : Text ) } : 4D.Signal",
			"Params": [
				[
					"Description",
					"Text",
					"->",
					"Description du signal"
				],
				[
					"Résultat",
					"4D.Signal",
					"<-",
					"Object encapsulant le signal"
				]
			],
			"Summary": "crée un objet `4D.Signal`"
		},
		"Num": {
			"Syntax": "**Num** ( *expression* {; *separator*} ) : Real<br/>**Num** ( *expression* ; *base* ) : Real",
			"Params": [
				[
					"expression",
					"Text, Boolean, Integer",
					"->",
					"String for which to return the numeric form, or Boolean to return 0 or 1, or Numeric expression"
				],
				[
					"separator",
					"Text",
					"->",
					"Decimal separator"
				],
				[
					"base",
					"Integer",
					"->",
					"Value between 2 and 36 that represents the radix"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Numeric form of the expression parameter"
				]
			],
			"Summary": "The **Num** command returns the numeric form of the String, Boolean or numeric expression you pass in *expression*."
		},
		"OBJECT Get data source formula": {
			"Syntax": "**OBJECT Get data source formula** ( {* ;} *object* ) : *formula*",
			"Params": [
				[
					"\\*",
					"Opérateur",
					"->",
					"If specified, object is an object name (string)<br/>If omitted, object is a field or variable"
				],
				[
					"object",
					"any",
					"->",
					"Object name (if \\* is specified) or<br/>Field or variable (if \\* is omitted)"
				],
				[
					"formula",
					"4D.Formula",
					"<-",
					"Formula associated with the form object (`Null` if no formula is associated)"
				]
			],
			"Summary": "returns the formula (if any) associated object(s) designated by the *object* and *\\** parameters."
		},
		"OBJECT SET DATA SOURCE FORMULA": {
			"Syntax": "**OBJECT SET DATA SOURCE FORMULA** ( {* ;} *object* ; *formula* )",
			"Params": [
				[
					"\\*",
					"Opérateur",
					"->",
					"If specified, object is an object name (string)<br/>If omitted, object is a field or variable"
				],
				[
					"object",
					"any",
					"->",
					"Object name (if \\* is specified) or<br/>Field or variable (if \\* is omitted)"
				],
				[
					"formula",
					"4D.Formula",
					"->",
					"Formula to assign as the data source"
				]
			],
			"Summary": "assigns a formula (expression) as the data source of the object(s) designated by the *object* and *\\** parameters"
		},
		"Open datastore": {
			"Syntax": "**Open datastore**( *connectionInfo* : Object ; *localID* : Text ) : 4D.DataStoreImplementation",
			"Params": [
				[
					"connectionInfo",
					"Object",
					"->",
					"Propriétés de connexion utilisées pour joindre le datastore distant"
				],
				[
					"localID",
					"Text",
					"->",
					"Identifiant à affecter au datastore ouvert sur l'application locale (obligatoire)"
				],
				[
					"Résultat",
					"4D.DataStoreImplementation",
					"<-",
					"Objet datastore"
				]
			],
			"Summary": "connecte l'application au datastore distant identifié par le paramètre *connectionInfo*"
		},
		"POP3 New transporter": {
			"Syntax": "**POP3 New transporter**( *server* : Object ) : 4D.POP3Transporter",
			"Params": [
				[
					"server",
					"Object",
					"->",
					"Informations sur le serveur de messagerie"
				],
				[
					"Résultat",
					"4D.POP3Transporter",
					"<-",
					"Object POP3 transporter"
				]
			],
			"Summary": "configure une nouvelle connexion POP3"
		},
		"Print form": {
			"Syntax": "**Print form** ( {*aTable* ;} *form* {; *formData*} {; *areaStart*{; *areaEnd*}} ) : Integer",
			"Params": [
				[
					"aTable",
					"Table",
					"->",
					"Table du formulaire, ou table par défaut si omis"
				],
				[
					"form",
					"Text, Object",
					"->",
					"Nom (chaîne) du formulaire, ou chemin POSIX (chaîne) vers un fichier .json décrivant le formulaire, ou objet décrivant le formulaire à imprimer"
				],
				[
					"formData",
					"Object",
					"->",
					"Données à associer au formulaire"
				],
				[
					"areaStart",
					"Integer",
					"->",
					"Marqueur d'impression ou zone de démarrage (si areaEnd est spécifié)"
				],
				[
					"areaEnd",
					"Integer",
					"->",
					"Zone de fin (si areaStart est spécifié)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur de la section imprimée"
				]
			],
			"Summary": "The **Print form** command simply prints *form* with the current values of fields and variables of *aTable*."
		},
		"Process activity": {
			"Syntax": "**Process activity** () : Object<br/>**Process activity** ( *options* ) : Object<br/>**Process activity** ( *sessionID* ) : Object<br/>**Process activity** ( *sessionID* ; *options* ) : Object",
			"Params": [
				[
					"sessionID",
					"Text",
					"->",
					"ID de session"
				],
				[
					"options",
					"Integer",
					"->",
					"Options de retour"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Aperçu des process en cours d'exécution et/ou (4D Server uniquement) des sessions utilisateur"
				]
			],
			"Summary": "The **Process activity** command returns a snapshot of running processes and/or (4D Server only) connected user sessions at a given time."
		},
		"Process info": {
			"Syntax": "**Process info** ( *processNumber* : Integer ) : Object",
			"Params": [
				[
					"processNumber",
					"Integer",
					"->",
					"Numéro du process"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur le process"
				]
			],
			"Summary": "renvoie un objet fournissant des informations détaillées sur le process dont le numéro est passé dans *processNumber*"
		},
		"Process number": {
			"Syntax": "**Process number** ( *name* {; *} ) : Integer<br/>**Process number** ( *id* {; *} ) : Integer",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Nom du process duquel obtenir le numéro"
				],
				[
					"id",
					"Text",
					"->",
					"ID du process duquel récupérer le numéro"
				],
				[
					"\\*",
					"Opérateur",
					"->",
					"Renvoyer le numéro du process depuis le serveur"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du process"
				]
			],
			"Summary": "The `Process number` command returns the number of the process whose *name* or *id* you pass in the first parameter"
		},
		"SELECT LOG FILE": {
			"Syntax": "**SELECT LOG FILE** ( *logFile* )<br/>**SELECT LOG FILE** ( * )",
			"Params": [
				[
					"logFile",
					"Text",
					"->",
					"Nom du fichier journal"
				],
				[
					"\\*",
					"Opérateur",
					"->",
					"Fermer le fichier journal courant"
				]
			],
			"Summary": "La commande **SELECT LOG FILE** crée ou ferme le fichier d'historique (ou fichier journal) de la base de données, suivant la valeur que vous passez en paramètre."
		},
		"Session info": {
			"Syntax": "**Session info** ( *sessionId* : Integer ) : Object",
			"Params": [
				[
					"sessionID",
					"Integer",
					"->",
					"ID de session"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur la session"
				]
			],
			"Summary": "retourne un objet décrivant la session dont vous passez l'ID dans le paramètre *sessionID*"
		},
		"Session storage": {
			"Syntax": "**Session storage** ( *id* ) : Object",
			"Params": [
				[
					"id",
					"Text",
					"->",
					"Identifiant unique (UUID) de la session"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet de stockage de la session"
				]
			],
			"Summary": "The **Session storage** command returns the storage object of the session whose unique identifier you passed in the *id* parameter."
		},
		"Session": {
			"Syntax": "**Session** : 4D.Session",
			"Params": [
				[
					"Résultat",
					"4D.Session",
					"<-",
					"Objet session"
				]
			],
			"Summary": "retourne l'objet `Session` correspondant à la session utilisateur courante"
		},
		"SET ALLOWED METHODS": {
			"Syntax": "**SET ALLOWED METHODS** ( *methodsArray* )",
			"Params": [
				[
					"methodsArray",
					"Text array",
					"->",
					"Tableau de noms de méthodes"
				]
			],
			"Summary": "The **SET ALLOWED METHODS** command designates the project methods that can be entered via the application."
		},
		"SET WINDOW DOCUMENT ICON": {
			"Syntax": "**SET WINDOW DOCUMENT ICON** ( *winRef* )<br/>**SET WINDOW DOCUMENT ICON** ( *winRef* ; *image* )<br/>**SET WINDOW DOCUMENT ICON** ( *winRef* ; *file* )<br/>**SET WINDOW DOCUMENT ICON** (  *winRef* ; *image* ; *file* )",
			"Params": [
				[
					"winRef",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre"
				],
				[
					"image",
					"Picture",
					"->",
					"Icône personnalisée"
				],
				[
					"file",
					"4D.File, 4D.Folder",
					"->",
					"Chemin d'accès du fichier ou du dossier"
				]
			],
			"Summary": "vous permet de définir une icône pour les fenêtres dans les applications multi-fenêtres en utilisant une *image* et/ou un *file* avec la référence de la fenêtre *winRef*"
		},
		"SMTP New transporter": {
			"Syntax": "**SMTP New transporter**( *server* : Object ) : 4D.SMTPTransporter",
			"Params": [
				[
					"server",
					"Object",
					"->",
					"Informations sur le serveur de messagerie"
				],
				[
					"Résultat",
					"4D.SMTPTransporter",
					"<-",
					"Objet SMTP transporter"
				]
			],
			"Summary": "configure une nouvelle connexion SMTP"
		},
		"String": {
			"Syntax": "**String** ( *expression* {; *format* {; *addTime*}} ) : Text<br/>**String** ( *expression* ; *base* ) : Text",
			"Params": [
				[
					"expression",
					"Expression",
					"->",
					"Expression à convertir en chaîne (peut être de type Réel, Integer, Date, Heure, Alpha, Texte, Booléen, Undefined ou Null)"
				],
				[
					"format",
					"Integer, Text",
					"->",
					"Format d'affichage"
				],
				[
					"addTime",
					"Time",
					"->",
					"Heure à combiner si *expression* est une date"
				],
				[
					"base",
					"Integer",
					"->",
					"Valeur comprise entre 2 et 36 qui représente la base si *expression* est un nombre"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"expression convertie en chaîne alphanumérique"
				]
			],
			"Summary": "La commande **String** renvoie sous forme de chaîne alphanumérique l'expression numérique, date, heure, chaîne ou booléenne que vous avez passée dans le paramètre *expression*."
		},
		"Super": {
			"Syntax": "**Super**( ...param : any )<br/>**Super** : Object",
			"Params": [
				[
					"param",
					"any",
					"->",
					"Paramètre(s) à passer au constructeur de la classe parente"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Parent de l'objet"
				]
			],
			"Summary": "permet les appels à la `superclass`, c'est-à-dire à la classe parente"
		},
		"This": {
			"Syntax": "**This** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Élément ou objet courant"
				]
			],
			"Summary": "renvoie une référence à l'objet en cours de traitement."
		},
		"Trim end": {
			"Syntax": "**Trim end** ( *aString* ) : Text",
			"Params": [
				[
					"aString",
					"Text",
					"->",
					"Text to trim"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Trimmed text"
				]
			],
			"Summary": "removes **whitespace** from the end of the *aString* parameter and returns a new string, without modifying the original one."
		},
		"Trim start": {
			"Syntax": "**Trim start** ( *aString* ) : Text",
			"Params": [
				[
					"aString",
					"Text",
					"->",
					"Text to trim"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Trimmed text"
				]
			],
			"Summary": "removes **whitespace** from the beginning of the *aString* parameter and returns a new string, without modifying the original one."
		},
		"Trim": {
			"Syntax": "**Trim** ( *aString* ) : Text",
			"Params": [
				[
					"aString",
					"Text",
					"->",
					"Text to trim"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Trimmed text"
				]
			],
			"Summary": "removes **whitespace** from both ends of the *aString* parameter and returns a new string, without modifying the original one."
		},
		"USE ENTITY SELECTION": {
			"Syntax": "**USE ENTITY SELECTION** ( *entitySelection* : 4D.EntitySelection )",
			"Params": [
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Une entity selection"
				]
			],
			"Summary": "met à jour la sélection courante de la table correspondant à la classe de données du paramètre *entitySelection*, en fonction du contenu de la entity selection"
		},
		"WA Get context": {
			"Syntax": "**WA Get context** ( {* ;} *object* ) -> *contextObj*",
			"Params": [
				[
					"\\*",
					"Opérateur",
					"->",
					"Si passé, *object* est un nom d'objet (chaîne de caractères). Si omis, *object* est une variable."
				],
				[
					"object",
					"any",
					"->",
					"Nom de l'objet (si \\* est spécifié) ou Variable (si \\* est omis)."
				],
				[
					"contextObj",
					"Object",
					"<-",
					"Objet contexte si défini précédemment, sinon `null`."
				]
			],
			"Summary": "récupère l'objet contexte défini pour `$4d` dans la zone Web désignée par les paramètres \\* et *object* en utilisant `WA SET CONTEXT`."
		},
		"WA SET CONTEXT": {
			"Syntax": "**WA SET CONTEXT** ( {* ;} *object* ; *contextObj* )",
			"Params": [
				[
					"\\*",
					"Opérateur",
					"->",
					"Si passé, *object* est un nom d'objet (chaîne de caractères). Si omis, *object* est une variable."
				],
				[
					"object",
					"any",
					"->",
					"Nom de l'objet (si \\* est spécifié) ou Variable (si \\* est omis)."
				],
				[
					"contextObj",
					"Object",
					"->",
					"Objet contenant les fonctions qui peuvent être appelées avec `$4d`."
				]
			],
			"Summary": "définit un objet contexte *contextObj* pour `$4d` dans la zone Web désignée par les paramètres \\* et *object*. Lorsque cette commande est utilisée, `$4d` ne peut accéder qu'aux contenus déclarés dans le *contextObj* fourni. Si aucun objet contexte n'est défini, `$4d` a accès à toutes les méthodes 4D et ne peut pas accéder aux classes utilisateurs."
		},
		"WEB Server list": {
			"Syntax": "**WEB Server list** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection des objets Web Server disponibles"
				]
			],
			"Summary": "renvoie une collection de tous les objets serveur Web disponibles dans l'application 4D"
		},
		"WEB Server": {
			"Syntax": "**WEB Server** : 4D.WebServer<br/>**WEB Server**( *option* : Integer ) : 4D.WebServer",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Serveur Web à référencer (défaut si omis = `Web server database`)"
				],
				[
					"Résultat",
					"4D.WebServer",
					"<-",
					"Objet Serveur Web"
				]
			],
			"Summary": "retourne l'objet Web server par défaut, ou l'objet Web server défini via le paramètre *option*"
		},
		"ZIP Create archive": {
			"Syntax": "**ZIP Create archive** ( *fileToZip* : 4D.File ; *destinationFile* : 4D.File ) : Object<br/>**ZIP Create archive** ( *folderToZip* : 4D.Folder ; *destinationFile* : 4D.File { ; *options* : Integer }) : Object<br/>**ZIP Create archive** ( *zipStructure* : Object ; *destinationFile* : 4D.File ) : Object",
			"Params": [
				[
					"fileToZip",
					"4D.File",
					"->",
					"Objet fichier ou dossier à compresser"
				],
				[
					"folderToZip",
					"4D.Folder",
					"->",
					"Objet fichier ou dossier à compresser"
				],
				[
					"zipStructure",
					"Object",
					"->",
					"Objet fichier ou dossier à compresser"
				],
				[
					"destinationFile",
					"4D.File",
					"->",
					"Fichier de destination de l'archive"
				],
				[
					"options",
					"Integer",
					"->",
					"Si *folderToZip* utilisé : `ZIP Without enclosing folder`"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet statut"
				]
			],
			"Summary": "crée un objet d'archive ZIP compressée et renvoie le statut de l'opération"
		},
		"ZIP Read archive": {
			"Syntax": "**ZIP Read archive** ( *zipFile* : 4D.File { ; *password* : Text }) : 4D.ZipArchive",
			"Params": [
				[
					"zipFile",
					"4D.File",
					"->",
					"Fichier archive ZIP"
				],
				[
					"password",
					"Text",
					"->",
					"Mot de passe de l'archive ZIP, le cas échéant"
				],
				[
					"Résultat",
					"4D.ZipArchive",
					"<-",
					"Objet archive"
				]
			],
			"Summary": "récupère le contenu de *zipFile* et le renvoie sous forme d'objet `4D.ZipArchive`"
		},
		"ABORT PROCESS BY ID": {
			"Syntax": "**ABORT PROCESS BY ID** ( *uniqueID* )",
			"Params": [
				[
					"uniqueID",
					"Integer",
					"->",
					"ID unique du process"
				]
			],
			"Summary": "La commande **ABORT PROCESS BY ID** stoppe un process spécifique sur 4D Server."
		},
		"ABORT": {
			"Syntax": "**ABORT**",
			"Params": [],
			"Summary": "La commande **ABORT** est destinée à être utilisée dans une méthode projet de gestion d'erreurs installée par la commande ON ERR CALL."
		},
		"Abs": {
			"Syntax": "**Abs** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre dont vous voulez obtenir la valeur absolue"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Valeur absolue de nombre"
				]
			],
			"Summary": "**Abs** retourne la valeur absolue (positive et sans signe) de *nombre*."
		},
		"ACCEPT": {
			"Syntax": "**ACCEPT**",
			"Params": [],
			"Summary": "**ACCEPT** effectue la même action que lorsque l'utilisateur appuie sur la touche **Entrée**."
		},
		"ACCUMULATE": {
			"Syntax": "**ACCUMULATE** ( *objet* {; *objet2* ; ... ; *objetN*} )",
			"Params": [
				[
					"objet",
					"Field, Variable",
					"->",
					"Champ ou variable de type numérique à cumuler"
				]
			],
			"Summary": "**ACCUMULATE** désigne les champ(s) ou variable(s) à cumuler dans un état créé à l'aide de la commande PRINT SELECTION."
		},
		"Action info": {
			"Syntax": "**Action info** ( *action* {; *cible*} ) : Object",
			"Params": [
				[
					"action",
					"Text",
					"->",
					"Nom de l'action standard ou syntaxe incluant un paramètre si celui-ci est requis"
				],
				[
					"cible",
					"Integer",
					"->",
					"Définit la cible de l'action où lire les informations : formulaire principal ou formulaire courant"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contenant le statut de l'action sous forme de booléens : isEnabled, isVisible, isChecked, isMixed, isUnknownState"
				]
			],
			"Summary": "La commande **Action info** retourne plusieurs informations, incluant la disponibilité et le statut à propos de l'*action* définie dans la *cible*, selon le contexte de l'application courante."
		},
		"Activated": {
			"Syntax": "**Activated**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est en activation"
				]
			],
			"Summary": "**Activated** retourne Vrai dans une méthode formulaire lorsque la fenêtre contenant le formulaire passe au premier plan."
		},
		"Active transaction": {
			"Syntax": "**Active transaction** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Faux si la transaction courante est suspendue"
				]
			],
			"Summary": "La commande **Active transaction** retourne **Vrai** si le process courant est en transaction et si cette transaction n'est pas suspendue."
		},
		"ACTIVITY SNAPSHOT": {
			"Syntax": "**ACTIVITY SNAPSHOT** ( tabActivités | tabUUID ; *tabDébut* ; *tabDurée* ; *tabInfo* {; *tabDétails*}{; *} )",
			"Params": [
				[
					"tabActivités &#124; tabUUID",
					"Tableau objet, Tableau texte",
					"<-",
					"Description complète des opérations (tableau objet) ouUUIDs des opérations (tableau texte)"
				],
				[
					"tabDébut",
					"Text array",
					"<-",
					"Heures de démarrage des opérations"
				],
				[
					"tabDurée",
					"Integer array",
					"<-",
					"Durées des opérations en millisecondes"
				],
				[
					"tabInfo",
					"Text array",
					"<-",
					"Description"
				],
				[
					"tabDétails",
					"Object array",
					"<-",
					"Détails du contexte et Sous-opérations (le cas échéant)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = Lire activité serveur"
				]
			],
			"Summary": "La commande **ACTIVITY SNAPSHOT** retourne un ou plusieurs tableau(x) décrivant les opérations en cours de progression sur les données de 4D."
		},
		"ADD RECORD": {
			"Syntax": "**ADD RECORD** ( {*laTable*}{;}{*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle ajouter des données ou Table par défaut si ce paramètre est omis"
				],
				[
					"*",
					"Operator",
					"->",
					"Cacher les barres de défilement"
				]
			],
			"Summary": "*Cette commande est apparue dans les premières versions de 4D et reste toujours utile pour créer des prototypes ou effectuer des développements simples."
		},
		"Add to date": {
			"Syntax": "**Add to date** ( *date* ; *années* ; *mois* ; *jours* ) : Date",
			"Params": [
				[
					"date",
					"Date",
					"->",
					"Date à laquelle ajouter jours, mois et années"
				],
				[
					"années",
					"Integer",
					"->",
					"Nombre d'années à ajouter à la date"
				],
				[
					"mois",
					"Integer",
					"->",
					"Nombre de mois à ajouter à la date"
				],
				[
					"jours",
					"Integer",
					"->",
					"Nombre de jours à ajouter à la date"
				],
				[
					"Résultat",
					"Date",
					"<-",
					"Date résultante"
				]
			],
			"Summary": "**Add to date** ajoute *années*, *mois* et *jours* à la date que vous avez passée dans *laDate*, et retourne la date résultante."
		},
		"ADD TO SET": {
			"Syntax": "**ADD TO SET** ( {*laTable* ;} *ensemble* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				],
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble auquel ajouter l'enregistrement courant"
				]
			],
			"Summary": "**ADD TO SET** ajoute l'enregistrement courant de *laTable* à *ensemble*."
		},
		"ADJUST BLOBS CACHE PRIORITY": {
			"Syntax": "**ADJUST BLOBS CACHE PRIORITY** ( *laTable* ; *priorité* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous souhaitez ajuster la priorité des données \"blobs\""
				],
				[
					"priorité",
					"Integer",
					"->",
					"Priorité des données \"blobs\" de la table dans le cache"
				]
			],
			"Summary": "Cette commande est réservée pour des besoins spécifiques."
		},
		"ADJUST INDEX CACHE PRIORITY": {
			"Syntax": "**ADJUST INDEX CACHE PRIORITY** ( *leChamp* ; *priorité* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ dont vous voulez ajuster la priorité du ou des index dans le cache"
				],
				[
					"priorité",
					"Integer",
					"->",
					"Priorité du ou des index du champ dans le cache"
				]
			],
			"Summary": "Cette commande est réservée pour des besoins spécifiques."
		},
		"ADJUST TABLE CACHE PRIORITY": {
			"Syntax": "**ADJUST TABLE CACHE PRIORITY** ( *laTable* ; *priority* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous souhaitez ajuster la priorité des données scalaires"
				],
				[
					"priority",
					"Integer",
					"->",
					"Priorité des données scalaires de la table dans le cache"
				]
			],
			"Summary": "Cette commande est réservée pour des besoins spécifiques."
		},
		"After": {
			"Syntax": "**After**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Retourne Vrai si le cycle d'exécution est après"
				]
			],
			"Summary": "**After** retourne Vrai pour le cycle d'exécution Après."
		},
		"ALERT": {
			"Syntax": "**ALERT** ( *message* {; *libelléBoutonOK*} )",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message à afficher dans la boîte de dialogue d'alerte"
				],
				[
					"libelléBoutonOK",
					"Text",
					"->",
					"Libellé du bouton OK"
				]
			],
			"Summary": "La commande **ALERT** affiche une boîte de dialogue d'alerte composée d'une icône, d'un message et d'un bouton OK."
		},
		"ALL RECORDS": {
			"Syntax": "**ALL RECORDS** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle vous voulez sélectionner tous les enregistrements ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "La commande **ALL RECORDS** sélectionne tous les enregistrements de *laTable* pour le process courant."
		},
		"APPEND DATA TO PASTEBOARD": {
			"Syntax": "**APPEND DATA TO PASTEBOARD** ( *typeDonnées* ; *données* )",
			"Params": [
				[
					"typeDonnées",
					"Text",
					"->",
					"Type des données à ajouter"
				],
				[
					"données",
					"Blob",
					"->",
					"Données à ajouter au conteneur"
				]
			],
			"Summary": "**APPEND DATA TO PASTEBOARD** ajoute dans le conteneur les données du type spécifié dans *typeDonnées* présentes dans le BLOB *données*."
		},
		"Append document": {
			"Syntax": "**Append document** ( *nomFichier* {; *typeFichier*} ) : Time",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du document ou Chemin d'accès complet au document ou Chaîne vide pour afficher la boîte de dialogue standard d'ouverture de fichiers"
				],
				[
					"typeFichier",
					"Text",
					"->",
					"Liste des types de documents à filtrer, ou \"*\" pour ne pas filtrer les documents"
				],
				[
					"Résultat",
					"Time",
					"<-",
					"Numéro de référence du document"
				]
			],
			"Summary": "La commande **Append document** \"fait la même chose\" que la commande Open document : elle vous permet d'ouvrir un document sur disque et de se placer à la fin du document."
		},
		"APPEND MENU ITEM": {
			"Syntax": "**APPEND MENU ITEM** ( *menu* ; *libelléLigne* {; *sousMenu* {; *process* {; *}}} )",
			"Params": [
				[
					"menu",
					"Integer",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"libelléLigne",
					"Text",
					"->",
					"Libellé du ou des nouvelle(s) ligne(s) de menu"
				],
				[
					"sousMenu",
					"Text",
					"->",
					"Référence du sous-menu associé à la ligne"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : considérer les métacaractères comme des caractères standard"
				]
			],
			"Summary": "La commande **APPEND MENU ITEM**  ajoute une ou plusieurs ligne(s) au menu dont vous avez passé le numéro ou la référence dans *menu."
		},
		"APPEND TO ARRAY": {
			"Syntax": "**APPEND TO ARRAY** ( *tableau* ; *valeur* )",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau auquel ajouter une valeur"
				],
				[
					"valeur",
					"Expression",
					"->",
					"Valeur à ajouter au tableau"
				]
			],
			"Summary": "La commande **APPEND TO ARRAY** ajoute une nouvelle ligne à la fin du *tableau* et lui affecte la valeur passée dans le paramètre *valeur*."
		},
		"APPEND TO LIST": {
			"Syntax": "**APPEND TO LIST** ( *liste* ; *libelléElément* ; *réfElément* {; sous_Liste ; *déployée*} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de liste"
				],
				[
					"libelléElément",
					"Text",
					"->",
					"Libellé du nouvel élément"
				],
				[
					"réfElément",
					"Integer",
					"->",
					"Numéro de référence unique du nouvel élément"
				],
				[
					"sous_Liste",
					"Integer",
					"->",
					"Sous-liste optionnelle à rattacher au nouvel élément"
				],
				[
					"déployée",
					"Boolean",
					"->",
					"Indique si la sous-liste doit être déployée ou non"
				]
			],
			"Summary": "La commande **APPEND TO LIST** ajoute un nouvel élément à la liste hiérarchique dont vous avez passé le numéro de référence dans le paramètre *liste*."
		},
		"Application file": {
			"Syntax": "**Application file**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom long du fichier 4D exécutable ou de l'application 4D"
				]
			],
			"Summary": "La fonction **Application file** retourne le nom long (c'est-à-dire le chemin d'accès complet au fichier, y compris son nom) du fichier exécutable ou de l'application 4D que vous utilisez."
		},
		"Application info": {
			"Syntax": "**Application info** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Information sur l'activité de l'application courante"
				]
			],
			"Summary": "La commande **Application info** retourne un objet qui fournit des informations détaillées sur l'activité de l'application courante et sa configuration réseau."
		},
		"Application type": {
			"Syntax": "**Application type**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur numérique représentant le type de l'application"
				]
			],
			"Summary": "La fonction **Application type** renvoie une valeur numérique qui représente le type de l'environnement 4D que vous utilisez."
		},
		"Application version": {
			"Syntax": "**Application version** {( *numBuild* {; *} )} : Text",
			"Params": [
				[
					"numBuild",
					"Integer",
					"<-",
					"Numéro de build"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = numéro de version long Si omis = numéro de version court"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Numéro de version dans une chaîne encodée"
				]
			],
			"Summary": "**Application version** retourne une chaîne encodée qui exprime le numéro de version de l'environnement 4D que vous utilisez."
		},
		"APPLY TO SELECTION": {
			"Syntax": "**APPLY TO SELECTION** ( *laTable* ; *formule* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle appliquer la formule"
				],
				[
					"formule",
					"Expression",
					"->",
					"Ligne de code ou méthode"
				]
			],
			"Summary": "La commande **APPLY TO SELECTION** applique *formule* à chaque enregistrement de la sélection courante de *laTable*."
		},
		"Arctan": {
			"Syntax": "**Arctan** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Tangente pour laquelle vous souhaitez calculer l'angle en radians"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Angle en radians"
				]
			],
			"Summary": "**Arctan** retourne en radians la valeur de l'angle dont la tangente est spécifiée par *nombre*."
		},
		"ARRAY BLOB": {
			"Syntax": "**ARRAY BLOB** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY BLOB** crée ou redimensionne un tableau d’éléments de type Blob en mémoire."
		},
		"ARRAY BOOLEAN": {
			"Syntax": "**ARRAY BOOLEAN** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY BOOLEAN** crée et/ou redimensionne un tableau d'éléments de type Booléen en mémoire."
		},
		"ARRAY DATE": {
			"Syntax": "**ARRAY DATE** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY DATE** crée et/ou redimensionne un tableau d'éléments de type Date en mémoire."
		},
		"ARRAY INTEGER": {
			"Syntax": "**ARRAY INTEGER** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY INTEGER** crée et/ou redimensionne un tableau d'éléments de type Entier-1) (Entier sur deux octets)\") (2 octets) en mémoire."
		},
		"ARRAY LONGINT": {
			"Syntax": "**ARRAY LONGINT** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY LONGINT** crée et/ou redimensionne un tableau d'éléments de type Entier long (4 octets) en mémoire."
		},
		"ARRAY OBJECT": {
			"Syntax": "**ARRAY OBJECT** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY OBJECT** crée et/ou redimensionne un tableau d’éléments de type Objet de langage en mémoire."
		},
		"ARRAY PICTURE": {
			"Syntax": "**ARRAY PICTURE** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY PICTURE** crée et/ou redimensionne un tableau d'éléments de type Image en mémoire."
		},
		"ARRAY POINTER": {
			"Syntax": "**ARRAY POINTER** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY POINTER** crée ou redimensionne un tableau d'éléments de type Pointeur, table, or field\") en mémoire."
		},
		"ARRAY REAL": {
			"Syntax": "**ARRAY REAL** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY REAL** crée et/ou redimensionne un tableau d'éléments de type Réel en mémoire."
		},
		"ARRAY TEXT": {
			"Syntax": "**ARRAY TEXT** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY TEXT** crée et/ou redimensionne un tableau d'éléments de type Texte en mémoire."
		},
		"ARRAY TIME": {
			"Syntax": "**ARRAY TIME** ( *nomTableau* ; *taille* {; *taille2*} )",
			"Params": [
				[
					"nomArray",
					"Array",
					"->",
					"Nom du tableau"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nombre d'éléments du tableau ou Nombre de tableaux si taille2 est spécifié"
				],
				[
					"taille2",
					"Integer",
					"->",
					"Nombre d'éléments des tableaux à deux dimensions"
				]
			],
			"Summary": "La commande **ARRAY TIME** crée et/ou redimensionne un tableau d’éléments de type Heure en mémoire."
		},
		"ARRAY TO COLLECTION": {
			"Syntax": "**ARRAY TO COLLECTION** ( *collection* ; *tableau* {; *nomPropriété*}{; *tableau2* ; *nomPropriété2* ; ... ; *tableauN* ; *nomPropriétéN*} )",
			"Params": [
				[
					"collection",
					"Collection",
					"<-",
					"Collection qui reçoit les données du tableau"
				],
				[
					"tableau",
					"Array",
					"->",
					"Tableau à copier vers la collection ; si le paramètre nomPropriété est passé, sont copiées les valeurs correspondantes à la propriété dans la collection"
				],
				[
					"nomPropriété",
					"Text",
					"->",
					"Nom de propriété Objet dont les valeurs remplissent les éléments du tableau"
				]
			],
			"Summary": "La commande **ARRAY TO COLLECTION** copie un ou plusieurs *tableau*(x) dans les éléments ou les valeurs *nomPropriété* de *collection*."
		},
		"ARRAY TO LIST": {
			"Syntax": "**ARRAY TO LIST** ( *tableau* ; *liste* {; *réfEléments*} )",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau duquel copier les éléments"
				],
				[
					"liste",
					"Text, Integer",
					"->",
					"Nom ou référence de la liste dans laquelle copier les éléments du tableau"
				],
				[
					"réfEléments",
					"Array",
					"->",
					"Tableau numérique des numéros de référence des éléments"
				]
			],
			"Summary": "La commande **ARRAY TO LIST** crée ou remplace la liste hiérarchique ou l'énumération *liste* en utilisant les éléments du tableau *tableau*."
		},
		"ARRAY TO SELECTION": {
			"Syntax": "**ARRAY TO SELECTION** {( *tableau* ; *leChamp* {; *tableau2* ; *leChamp2* ; ... ; *tableauN* ; *leChampN*}{; *} )}",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau à copier dans la sélection"
				],
				[
					"leField",
					"Field",
					"<-",
					"Champ recevant les valeurs du tableau"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d’exécution"
				]
			],
			"Summary": "La commande **ARRAY TO SELECTION** copie un ou plusieurs tableau(x) vers une sélection d'enregistrements."
		},
		"ASSERT": {
			"Syntax": "**ASSERT** ( *expressionBool* {; *texteMessage*} )",
			"Params": [
				[
					"expressionBool",
					"Boolean",
					"->",
					"Expression booléenne"
				],
				[
					"texteMessage",
					"Text",
					"->",
					"Texte du message d’erreur"
				]
			],
			"Summary": "La commande **ASSERT** évalue l'assertion *expressionBool* passée en paramètre et, si elle retourne faux, interrompt l'exécution du code en affichant une erreur."
		},
		"Asserted": {
			"Syntax": "**Asserted** ( *expressionBool* {; *texteMessage*} ) : Boolean",
			"Params": [
				[
					"expressionBool",
					"Boolean",
					"->",
					"Expression booléenne"
				],
				[
					"texteMessage",
					"Text",
					"->",
					"Texte du message d’erreur"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Résultat de l’évaluation d’expressionBool"
				]
			],
			"Summary": "La commande **Asserted** a un fonctionnement semblable à celui de la commande ASSERT, à la différence près qu’elle retourne une valeur issue de l’évaluation du paramètre *expressionBool*."
		},
		"Average": {
			"Syntax": "**Average** ( *séries* {; *cheminAttribut*} ) : Real",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs dont vous voulez calculer la moyenne"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Chemin d'attribut duquel calculer la moyenne"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Moyenne arithmétique de séries"
				]
			],
			"Summary": "**Average** retourne la moyenne arithmétique de *séries*."
		},
		"BACKUP INFO": {
			"Syntax": "**BACKUP INFO** ( *sélecteur* ; *info1* ; *info2* )",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Type d’information à récupérer"
				],
				[
					"info1",
					"Integer, Date",
					"<-",
					"Valeur 1 du sélecteur"
				],
				[
					"info2",
					"Time, Text",
					"<-",
					"Valeur 2 du sélecteur"
				]
			],
			"Summary": "La commande **BACKUP INFO** permet de récupérer des informations relatives à la dernière sauvegarde effectuée sur les données de la base."
		},
		"BACKUP": {
			"Syntax": "**BACKUP**",
			"Params": [],
			"Summary": "La commande **BACKUP** déclenche la sauvegarde de la base de données avec les paramétrages de sauvegarde courants."
		},
		"BASE64 DECODE": {
			"Syntax": "**BASE64 DECODE** ( àDécoder {; *décodé*}{; *} )",
			"Params": [
				[
					"àDécoder",
					"Text, Blob",
					"->",
					"Valeur encodée à décoder"
				],
				[
					"<-",
					"Valeur décodée (si le paramètre décodé est omis)"
				],
				[
					"décodé",
					"Text, Blob",
					"<-",
					"Valeur décodée"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Décoder au format Base64URL"
				]
			],
			"Summary": "La commande **BASE64 DECODE**décode la valeur encodée de type BLOB ou texte au format base64 ou Base64URL passé dans le paramètre àDécoder ."
		},
		"BASE64 ENCODE": {
			"Syntax": "**BASE64 ENCODE** ( àEncoder {; *encodé*}{; *} )",
			"Params": [
				[
					"àEncoder",
					"Blob, Text",
					"->",
					"Valeur à encoder"
				],
				[
					"<-",
					"Valeur encodée (si le paramètre encodé est omis)"
				],
				[
					"encodé",
					"Blob, Text",
					"<-",
					"Valeur encodée"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Encoder au format Base64URL"
				]
			],
			"Summary": "La commande **BASE64 ENCODE** encode la valeur texte ou BLOB passée dans le paramètre *àEncoder* en Base64 ou Base64URL."
		},
		"BEEP": {
			"Syntax": "**BEEP**",
			"Params": [],
			"Summary": "La commande **BEEP** provoque l'émission d'un bip sonore."
		},
		"Before selection": {
			"Syntax": "**Before selection** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle vous testez si le pointeur se trouve avant la sélection"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Avant sélection (Vrai) sinon (Faux)"
				]
			],
			"Summary": "La fonction **Before selection** retourne Vrai lorsque le pointeur d'enregistrement courant se trouve avant le premier enregistrement de la sélection courante de *laTable*."
		},
		"Before": {
			"Syntax": "**Before**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est avant"
				]
			],
			"Summary": "**Before** retourne Vrai pour le cycle d'exécution Avant."
		},
		"Begin SQL": {
			"Syntax": "**Begin SQL**",
			"Params": [],
			"Summary": "**Begin SQL** est un mot-clé permettant d'indiquer dans l'éditeur de méthodes le début d'une séquence de commandes SQL, qui devront être interprétées par la source de données courante du process (moteur SQL intégré de 4D ou toute source définie via la commande SQL LOGIN)."
		},
		"BLOB PROPERTIES": {
			"Syntax": "**BLOB PROPERTIES** ( *blob* ; *compressé* {; *tailleDécompressée* {; *tailleCourante*}} )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB sur lequel vous voulez obtenir des informations"
				],
				[
					"compressé",
					"Integer",
					"<-",
					"0 = pas de compression, 1 = interne compact, 2 = interne rapide, -1 = GZIP compact, -2 = GZIP rapide"
				],
				[
					"tailleDécompressée",
					"Integer",
					"<-",
					"Taille du BLOB décompressé en octets"
				],
				[
					"tailleCourante",
					"Integer",
					"<-",
					"Taille courante du BLOB en octets"
				]
			],
			"Summary": "**BLOB PROPERTIES** retourne des informations sur le BLOB *blob*."
		},
		"BLOB size": {
			"Syntax": "**BLOB size** ( *blob* ) : Integer",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"Champ ou variable de type BLOB"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Taille en octets du BLOB"
				]
			],
			"Summary": "**BLOB size** retourne la taille de *blob* exprimée en octets."
		},
		"BLOB TO DOCUMENT": {
			"Syntax": "**BLOB TO DOCUMENT** ( *document* ; *blob* )",
			"Params": [
				[
					"document",
					"Text",
					"->",
					"Nom du document"
				],
				[
					"blob",
					"Blob",
					"->",
					"Nouveau contenu du document"
				]
			],
			"Summary": "**BLOB TO DOCUMENT** écrit le contenu de *document* en utilisant les données stockées dans *blob*."
		},
		"BLOB to integer": {
			"Syntax": "**BLOB to integer** ( *blob* ; *ordreOctet* {; *offset*} ) : Integer",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB duquel obtenir la valeur entière"
				],
				[
					"ordreOctet",
					"Integer",
					"->",
					"0 Ordre d'octets mode natif 1 Ordre d'octets Macintosh 2 Ordre d'octets PC"
				],
				[
					"offset",
					"Variable",
					"<->",
					"Offset (en octets) dans le BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après la lecture"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur entière (2 octets)"
				]
			],
			"Summary": "BLOB to integer retourne une valeur entière (2 octets) lue dans le BLOB blob."
		},
		"BLOB to list": {
			"Syntax": "**BLOB to list** ( *blob* {; *offset*} ) : Integer",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB contenant la liste hiérarchique"
				],
				[
					"offset",
					"Integer",
					"<->",
					"Offset (en octets) dans le BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après la lecture"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Référence de la liste nouvellement créée"
				]
			],
			"Summary": "**BLOB to list** crée une nouvelle liste hiérarchique avec les données stockées dans le BLOB *blob* à l'offset d'octet (à partir de zéro) spécifié par *offset* et retourne un numéro de référence de liste hiérarchique pour cette nouvelle liste."
		},
		"BLOB to longint": {
			"Syntax": "**BLOB to longint** ( *blob* ; *ordreOctet* {; *offset*} ) : Integer",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB duquel extraire la valeur de type Entier long"
				],
				[
					"ordreOctet",
					"Integer",
					"->",
					"0 = Ordre d'octets natif 1 = Ordre d'octets Macintosh 2 = Ordre d'octets PC"
				],
				[
					"offset",
					"Variable",
					"<->",
					"Offset (en octets) dans le BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après lecture"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de type Entier long (4 octets)"
				]
			],
			"Summary": "La fonction **BLOB to longint** retourne une valeur de type Entier long (4 octets) lue dans le BLOB *blob*."
		},
		"BLOB TO PICTURE": {
			"Syntax": "**BLOB TO PICTURE** ( *blobImage* ; *image* {; *codec*} )",
			"Params": [
				[
					"blobImage",
					"Blob",
					"->",
					"BLOB contenant une image"
				],
				[
					"image",
					"Picture",
					"<-",
					"Champ ou variable image 4D"
				],
				[
					"codec",
					"Text",
					"->",
					"Identifiant de codec d’image"
				]
			],
			"Summary": "La commande **BLOB TO PICTURE** place dans un champ ou une variable image 4D une image stockée dans un BLOB, quel que soit son format initial."
		},
		"BLOB to print settings": {
			"Syntax": "**BLOB to print settings** ( *paramImpression* {; *param*} ) : Integer",
			"Params": [
				[
					"paramImpression",
					"Blob",
					"->",
					"BLOB contenant les paramètres d’impression"
				],
				[
					"param",
					"Integer",
					"->",
					"0=Utilise les valeurs sauvegardées pour le nombre de copies et la plage d'impression, 1=Réinitialise aux valeurs par défaut"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code d'état : 1=Opération réussie, 0=Pas d'imprimante courante, -1=Paramètres incorrects, 2=L'imprimante a changé"
				]
			],
			"Summary": "La commande **BLOB to print settings** remplace les paramètres d’impression courants de 4D par les paramètres stockés dans le BLOB *paramImpression*."
		},
		"BLOB to real": {
			"Syntax": "**BLOB to real** ( *blob* ; *formatRéel* {; *offset*} ) : Real",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB duquel extraire la valeur de type Réel"
				],
				[
					"formatRéel",
					"Integer",
					"->",
					"0 Format réel natif 1 Format réel étendu 2  Format réel double Macintosh 3  Format réel double Windows"
				],
				[
					"offset",
					"Variable",
					"<->",
					"Offset (en octets) dans le BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après lecture"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Valeur de type Réel"
				]
			],
			"Summary": "La fonction **BLOB to real** retourne une valeur de type Réel lue dans le BLOB *blob*."
		},
		"BLOB to text": {
			"Syntax": "**BLOB to text** ( *blob* ; *formatTexte* {; *offset* {; *longueurTexte*}} )  : Text",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB duquel extraire le texte"
				],
				[
					"formatTexte",
					"Integer",
					"->",
					"Format et jeu de caractères du texte"
				],
				[
					"offset",
					"Variable",
					"<->",
					"Offset (en octets) dans le BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après la lecture"
				],
				[
					"longueurTexte",
					"Integer",
					"->",
					"Nombre de caractères à lire"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte extrait"
				]
			],
			"Summary": "La fonction **BLOB to text** retourne une valeur de type Texte lue dans le BLOB *blob*."
		},
		"BLOB TO USERS": {
			"Syntax": "**BLOB TO USERS** ( *utilisateurs* )",
			"Params": [
				[
					"utilisateurs",
					"Blob",
					"->",
					"BLOB (crypté) contenant des comptes utilisateurs créés et sauvegardés par l'Administrateur"
				]
			],
			"Summary": "La commande **BLOB TO USERS** remplace les comptes utilisateurs et les groupes présents dans le BLOB *utilisateurs* dans la base courante."
		},
		"BLOB TO VARIABLE": {
			"Syntax": "**BLOB TO VARIABLE** ( *blob* ; *variable* {; *offset*} )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB contenant une ou plusieurs variable(s) 4D"
				],
				[
					"variable",
					"Variable",
					"<-",
					"Variable à écrire avec le contenu de BLOB"
				],
				[
					"offset",
					"Integer",
					"<->",
					"Position de la variable dans BLOB"
				],
				[
					"",
					"",
					"",
					"Position de la variable suivante dans BLOB"
				]
			],
			"Summary": "**BLOB TO VARIABLE** réécrit la variable *variable* avec les données stockées dans le BLOB *blob* à l'offset d'octet (à partir de zéro) spécifié par *offset*."
		},
		"Bool": {
			"Syntax": "**Bool** ( *expression* ) : Boolean",
			"Params": [
				[
					"expression",
					"Expression",
					"->",
					"Expression à retourner sous forme de booléen"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Expression sous forme booléenne"
				]
			],
			"Summary": "La commande **Bool** retourne l'expression que vous avez passée dans *expression* sous une forme booléenne."
		},
		"BOOLEAN ARRAY FROM SET": {
			"Syntax": "**BOOLEAN ARRAY FROM SET** ( *tabBooléen* {; *ensemble*} )",
			"Params": [
				[
					"tabBooléen",
					"Boolean array",
					"<-",
					"Tableau d'appartenance des enregistrements à l’ensemble"
				],
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l’ensemble ou Ensemble UserSet si ce paramètre est omis"
				]
			],
			"Summary": "La commande **BOOLEAN ARRAY FROM SET** remplit un tableau de booléens indiquant si chaque enregistrement de la table à laquelle appartient *ensemble* fait ou non partie de l’ensemble."
		},
		"BREAK LEVEL": {
			"Syntax": "**BREAK LEVEL** ( *niveau* {; *sautPage*} )",
			"Params": [
				[
					"niveau",
					"Integer",
					"->",
					"Nombre de niveaux de rupture"
				],
				[
					"sautPage",
					"Integer",
					"->",
					"Niveau de saut de page"
				]
			],
			"Summary": "**BREAK LEVEL** spécifie le nombre de niveaux de rupture dans un état créé à l'aide de la commande PRINT SELECTION."
		},
		"BRING TO FRONT": {
			"Syntax": "**BRING TO FRONT** ( *process* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro du process à passer au premier plan"
				]
			],
			"Summary": "**BRING TO FRONT** passe les fenêtres du process de numéro *process* au premier plan."
		},
		"BUILD APPLICATION": {
			"Syntax": "**BUILD APPLICATION** {( *nomProjet* )}",
			"Params": [
				[
					"nomProjet",
					"Text",
					"->",
					"Chemin d’accès complet du projet à utiliser"
				]
			],
			"Summary": "La commande **BUILD APPLICATION** lance le processus de génération d’application en prenant en compte les paramètres définis dans le fichier de configuration d’application courant ou le fichier de configuration défini dans le paramètre *buildAppSettings*."
		},
		"Cache info": {
			"Syntax": "**Cache info** {( *dbFilter* )} : Object",
			"Params": [
				[
					"dbFilter",
					"Object",
					"->",
					"définit la liste des attributs à retourner (filtrés par DB)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Informations à propos du cache"
				]
			],
			"Summary": "La commande **Cache info** retourne un objet contenant des informations détaillées sur le contenu actuel du cache (mémoire utilisée, tables et index chargés, etc.)"
		},
		"CALL FORM": {
			"Syntax": "**CALL FORM** ( *fenêtre* ; *formule* {; *param*}{; *param2* ; ... ; *paramN*} )",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre"
				],
				[
					"formule",
					"Object, Text",
					"->",
					"Objet Formula ou Nom de la méthode projet"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) passé(s) à la méthode"
				]
			],
			"Summary": "La commande **CALL FORM** exécute le code 4D désigné dans formule avec un ou plusieurs *param*(s) optionnel(s) dans le contexte d'un formulaire affiché dans la *fenêtre*, indépendamment du process auquel appartient la fenêtre."
		},
		"CALL SUBFORM CONTAINER": {
			"Syntax": "**CALL SUBFORM CONTAINER** ( événement )",
			"Params": [
				[
					"événement",
					"Integer",
					"->",
					"Evénement à transmettre"
				]
			],
			"Summary": "La commande **CALL SUBFORM CONTAINER** permet à une instance de sous-formulaire d’envoyer l’*événement* à l’objet sous-formulaire qui la contient."
		},
		"CALL WORKER": {
			"Syntax": "**CALL WORKER** ( *process* ; *formule* {; *param*}{; *param2* ; ... ; *paramN*} )",
			"Params": [
				[
					"process",
					"Text, Integer",
					"->",
					"Nom ou numéro du process worker"
				],
				[
					"formule",
					"Object, Text",
					"->",
					"Objet Formula ou Nom de la méthode projet"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) passé(s) à la méthode"
				]
			],
			"Summary": "La commande **CALL WORKER** crée ou appelle le process worker dont vous avez passé le nom ou le numéro dans *process* et demande l’exécution du code désigné par la *formule* dans son contexte avec le ou les paramètre(s) optionnel(s) spécifié(s) dans *param*."
		},
		"CANCEL TRANSACTION": {
			"Syntax": "**CANCEL TRANSACTION**",
			"Params": [],
			"Summary": "**CANCEL TRANSACTION** annule la transaction ouverte par la commande START TRANSACTION de niveau correspondant dans le process courant."
		},
		"CANCEL": {
			"Syntax": "**CANCEL**",
			"Params": [],
			"Summary": "Dans le contexte de la saisie, **CANCEL** effectue la même action que lorsque l'utilisateur utilise la touche d'annulation (**Esc**)."
		},
		"Caps lock down": {
			"Syntax": "**Caps lock down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Verrouillage Majuscule"
				]
			],
			"Summary": "**Caps lock down** retourne Vrai si la touche **Verrouillage Majuscule** est enfoncée."
		},
		"CHANGE CURRENT USER": {
			"Syntax": "**CHANGE CURRENT USER** {( *utilisateur* ; *motDePasse* )}",
			"Params": [
				[
					"utilisateur",
					"Text, Integer",
					"->",
					"Nom ou Numéro de référence unique de l’utilisateur"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe (non crypté)"
				]
			],
			"Summary": "**CHANGE CURRENT USER** permet de changer l'identité de l'utilisateur courant dans la base, sans devoir la quitter."
		},
		"CHANGE LICENSES": {
			"Syntax": "**CHANGE LICENSES**",
			"Params": [],
			"Summary": "La commande **CHANGE LICENSES** affiche la boîte de dialogue du Gestionnaire de licences 4D."
		},
		"CHANGE PASSWORD": {
			"Syntax": "**CHANGE PASSWORD** ( *motDePasse* )",
			"Params": [
				[
					"motDePasse",
					"Text",
					"->",
					"Nouveau mot de passe"
				]
			],
			"Summary": "**CHANGE PASSWORD** permet de changer le mot de passe de l'utilisateur courant."
		},
		"Change string": {
			"Syntax": "**Change string** ( *source* ; *nouveau* ; *positionDépart* ) : Text",
			"Params": [
				[
					"source",
					"Text",
					"->",
					"Chaîne de départ"
				],
				[
					"nouveau",
					"Text",
					"->",
					"Nouveaux caractères"
				],
				[
					"positionDépart",
					"Integer",
					"->",
					"Position de départ du remplacement"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne résultante"
				]
			],
			"Summary": "**Change string** retourne une chaîne résultant du remplacement des caractères, dans la chaîne *source*, à partir de *positionDépart*, par la chaîne *nouveau*."
		},
		"Char": {
			"Syntax": "**Char** ( *codeCaractère* ) : Text",
			"Params": [
				[
					"codeCaractère",
					"Integer",
					"->",
					"Code de caractère"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Caractère représenté par codeCaractère"
				]
			],
			"Summary": "La fonction **Char** retourne le caractère dont le code est *codeCaractère*."
		},
		"Character code": {
			"Syntax": "**Character code** ( *unCaractère* ) : Integer",
			"Params": [
				[
					"unCaractère",
					"Text",
					"->",
					"Caractère dont vous voulez obtenir le code"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code du caractère"
				]
			],
			"Summary": "La commande **Character code** retourne le code Unicode UTF-16 (compris entre 1 et 65535) de *unCaractère*."
		},
		"CHECK LOG FILE": {
			"Syntax": "**CHECK LOG FILE**",
			"Params": [],
			"Summary": "La commande **CHECK LOG FILE** affiche la boîte de dialogue de visualisation du fichier d’historique courant de la base (également accessible via la fenêtre du Centre de sécurité et de maintenance)"
		},
		"Choose": {
			"Syntax": "**Choose** ( *critère* ; *valeur* {; *valeur2* ; ... ; *valeurN*} )  : any",
			"Params": [
				[
					"critère",
					"Boolean, Integer",
					"->",
					"Valeur à tester"
				],
				[
					"valeur",
					"Expression",
					"->",
					"Valeurs possibles"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur de critère"
				]
			],
			"Summary": "La commande **Choose** retourne l’une des valeurs passées dans les paramètres *valeur*, *valeur2*, etc."
		},
		"CLEAR LIST": {
			"Syntax": "**CLEAR LIST** ( *liste* {; *} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de liste"
				],
				[
					"*",
					"Operator",
					"->",
					"Si spécifié, effacer les sous-listes de la mémoire (s'il existe des sous-listes) Si omis, ne pas effacer les sous-listes"
				]
			],
			"Summary": "La commande **CLEAR LIST** efface de la mémoire la liste hiérarchique dont vous avez passé le numéro de référence dans le paramètre *liste*."
		},
		"CLEAR NAMED SELECTION": {
			"Syntax": "**CLEAR NAMED SELECTION** ( *nom* )",
			"Params": [
				[
					"nom",
					"Text",
					"->",
					"Nom de la sélection temporaire à effacer"
				]
			],
			"Summary": "**CLEAR NAMED SELECTION** efface *nom* de la mémoire et donc libère la mémoire qu'elle utilisait."
		},
		"CLEAR PASTEBOARD": {
			"Syntax": "**CLEAR PASTEBOARD**",
			"Params": [],
			"Summary": "**CLEAR PASTEBOARD** efface entièrement le conteneur de données."
		},
		"CLEAR SEMAPHORE": {
			"Syntax": "**CLEAR SEMAPHORE** ( *sémaphore* )",
			"Params": [
				[
					"sémaphore",
					"Text",
					"->",
					"Sémaphore à effacer"
				]
			],
			"Summary": "**CLEAR SEMAPHORE** permet d'effacer le *sémaphore* précédemment créé par la fonction Semaphore."
		},
		"CLEAR SET": {
			"Syntax": "**CLEAR SET** ( *ensemble* )",
			"Params": [
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble à effacer de la mémoire"
				]
			],
			"Summary": "**CLEAR SET** efface *ensemble* de la mémoire et la libère ainsi pour d'autres utilisations."
		},
		"CLEAR VARIABLE": {
			"Syntax": "**CLEAR VARIABLE** ( *variable* )",
			"Params": [
				[
					"variable",
					"Variable",
					"->",
					"Nom de la variable à effacer"
				]
			],
			"Summary": "**CLEAR VARIABLE** réinitialise *variable* à la valeur par défaut de son type (par exemple chaîne vide pour les types Texte, 0 — zéro — pour les variables numériques, aucun élément pour un tableau etc.)."
		},
		"Clickcount": {
			"Syntax": "**Clickcount**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de clics consécutifs"
				]
			],
			"Summary": "La commande **Clickcount** retourne, dans le contexte d'un événement clic, le nombre de fois que l'utilisateur a cliqué de manière répétée avec le même bouton de la souris."
		},
		"CLOSE DOCUMENT": {
			"Syntax": "**CLOSE DOCUMENT** ( *docRef* )",
			"Params": [
				[
					"docRef",
					"Time",
					"->",
					"Numéro de référence du document"
				]
			],
			"Summary": "**CLOSE DOCUMENT** ferme le document spécifié par *docRef*."
		},
		"CLOSE PRINTING JOB": {
			"Syntax": "**CLOSE PRINTING JOB**",
			"Params": [],
			"Summary": "La commande **CLOSE PRINTING JOB** permet de refermer la tâche d’impression préalablement ouverte par la commande OPEN PRINTING JOB et d’envoyer à l’imprimante courante le document d’impression éventuellement construit."
		},
		"CLOSE RESOURCE FILE": {
			"Syntax": "**CLOSE RESOURCE FILE** ( *resFichier* )",
			"Params": [
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources"
				]
			],
			"Summary": "La commande **CLOSE RESOURCE FILE** referme le fichier de ressources dont vous avez passé le numéro de référence dans *resFichier*."
		},
		"CLOSE WINDOW": {
			"Syntax": "**CLOSE WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre externe ou Fenêtre de premier plan du process si ce paramètre est omis"
				]
			],
			"Summary": "**CLOSE WINDOW** referme la dernière fenêtre créée à l'aide de la commande Open window ou Open form window dans le process courant."
		},
		"COLLECTION TO ARRAY": {
			"Syntax": "**COLLECTION TO ARRAY** ( *collection* ; *tableau* {; *nomPropriété*}{; *tableau2* ; *nomPropriété2* ; ... ; *tableauN* ; *nomPropriétéN*} )",
			"Params": [
				[
					"collection",
					"Collection",
					"->",
					"Collection à copier dans un ou des tableau(x)"
				],
				[
					"tableau",
					"Array",
					"<-",
					"Tableau reçevant les éléments de la collection ; si le paramètre nomPropriété est passé, le tableau reçoit les valeurs correspondantes à nomPropriété dans la collection."
				],
				[
					"nomPropriété",
					"Text",
					"->",
					"Nom de la propriété de l'objet dont les valeurs sont à copier dans le tableau (\"\" pour tous les éléments)"
				]
			],
			"Summary": "La commande **COLLECTION TO ARRAY** remplit un ou plusieurs *tableau*(x) avec les éléments ou les valeurs *nomPropriété* de la *collection* dans le ou les *tableau*(x)."
		},
		"COMBINE PICTURES": {
			"Syntax": "**COMBINE PICTURES** ( *imageRésultat* ; *image1* ; *opérateur* ; *image2* {; *décalHoriz* ; *décalVert*} )",
			"Params": [
				[
					"imageRésultat",
					"Picture",
					"<-",
					"Image résultant de la combinaison"
				],
				[
					"image1",
					"Picture",
					"->",
					"Première image à combiner"
				],
				[
					"opérateur",
					"Integer",
					"->",
					"Type de combinaison à effectuer"
				],
				[
					"image2",
					"Picture",
					"->",
					"Seconde image à combiner"
				],
				[
					"décalHoriz",
					"Integer",
					"->",
					"Décalage horizontal pour la superposition"
				],
				[
					"décalVert",
					"Integer",
					"->",
					"Décalage vertical pour la superposition"
				]
			],
			"Summary": "La commande **COMBINE PICTURES** permet de combiner les images *image1* et *image2* en mode *opérateur* pour en produire une troisième, *imageRésultat*."
		},
		"Compact data file": {
			"Syntax": "**Compact data file** ( *cheminStructure* ; *cheminDonnées* {; *dossierArchive* {; *options* {; *méthode*}}} ) : Text",
			"Params": [
				[
					"cheminStructure",
					"Text",
					"->",
					"Chemin d’accès du fichier de structure"
				],
				[
					"cheminDonnées",
					"Text",
					"->",
					"Chemin d’accès du fichier de données"
				],
				[
					"dossierArchive",
					"Text",
					"->",
					"Chemin d’accès du dossier dans lequel placer le fichier de données original"
				],
				[
					"options",
					"Integer",
					"->",
					"Options de compactage"
				],
				[
					"méthode",
					"Text",
					"->",
					"Nom de la méthode 4D de rétro-appel"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès complet du dossier contenant le fichier de données original"
				]
			],
			"Summary": "La commande **Compact data file** effectue un compactage du fichier de données désigné par le paramètre *cheminDonnées* associé au fichier de structure *cheminStructure*."
		},
		"Compare strings": {
			"Syntax": "**Compare strings** ( *aString* ; *bString* {; *options*} ) : Integer",
			"Params": [
				[
					"aString",
					"Text",
					"->",
					"Chaîne à comparer"
				],
				[
					"bString",
					"Text",
					"->",
					"Chaîne à comparer"
				],
				[
					"options",
					"Integer",
					"->",
					"Règle(s) de comparaison"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Résultat de la comparaison de chaînes"
				]
			],
			"Summary": "La commande **Compare strings** retourne une valeur négative, zéro, ou une valeur positive, en fonction du paramètre *aString* selon qu'il soit évalué comme étant inférieur, égal ou supérieur au paramètre *bString*."
		},
		"COMPONENT LIST": {
			"Syntax": "**COMPONENT LIST** ( *tabComposants* )",
			"Params": [
				[
					"tabComposants",
					"Text array",
					"<-",
					"Noms des composants"
				]
			],
			"Summary": "La commande **COMPONENT LIST** dimensionne et remplit le tableau *tabComposants* avec les noms des composants chargés par l’application 4D pour la base hôte courante."
		},
		"COMPRESS BLOB": {
			"Syntax": "**COMPRESS BLOB** ( *blob* {; *compression*} )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB à compresser"
				],
				[
					"compression",
					"Integer",
					"->",
					"Si ce paramètre est passé : 1= taux de compression maximum 2 = vitesse de compression maximum"
				]
			],
			"Summary": "**COMPRESS BLOB** compresse le BLOB *blob* à l'aide d'un algorithme de compression."
		},
		"CONFIRM": {
			"Syntax": "**CONFIRM** ( *message* {; *libelléBoutonOK* {; *libelléBoutonAnn*}} )",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message à afficher dans la boîte de dialogue de confirmation"
				],
				[
					"libelléBoutonOK",
					"Text",
					"->",
					"Libellé du bouton OK"
				],
				[
					"libelléBoutonAnn",
					"Text",
					"->",
					"Libellé du bouton Annuler"
				]
			],
			"Summary": "La commande **CONFIRM** affiche une boîte de dialogue de confirmation qui se compose d'une icône, d'un message, d'un bouton OK et d'un bouton Annuler."
		},
		"Contextual click": {
			"Syntax": "**Contextual click**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si un clic contextuel a été détecté, sinon Faux"
				]
			],
			"Summary": "La commande **Contextual click** retourne Vrai si un clic de type contextuel a été effectué"
		},
		"CONVERT COORDINATES": {
			"Syntax": "**CONVERT COORDINATES** ( *coordX* ; *coordY* ; *depuis* ; *vers* )",
			"Params": [
				[
					"coordX",
					"Integer",
					"->",
					"Coordonnée horizontale d'un point (initiale)"
				],
				[
					"<-",
					"Coordonnée horizontale d'un point (convertie)"
				],
				[
					"coordY",
					"Integer",
					"->",
					"Coordonnée verticale d'un point (initiale)"
				],
				[
					"<-",
					"Coordonnée verticale d'un point (convertie)"
				],
				[
					"depuis",
					"Integer",
					"->",
					"Système de coordonnées d'origine"
				],
				[
					"vers",
					"Integer",
					"->",
					"Système de coordonnées dans lequel convertir le point"
				]
			],
			"Summary": "La commande **CONVERT COORDINATES** permet de convertir les coordonnées (x;y) d'un point depuis un système de coordonnées vers un autre système de coordonnées."
		},
		"CONVERT FROM TEXT": {
			"Syntax": "**CONVERT FROM TEXT** ( *texte4D* ; *jeuCaractères* ; *blobConverti* )",
			"Params": [
				[
					"texte4D",
					"Text",
					"->",
					"Texte exprimé dans le jeu de caractères courant de 4D"
				],
				[
					"jeuCaractères",
					"Text, Integer",
					"->",
					"Nom ou Numéro de jeu de caractères"
				],
				[
					"blobConverti",
					"Blob",
					"<-",
					"BLOB contenant le texte converti"
				]
			],
			"Summary": "La commande **CONVERT FROM TEXT** permet de convertir un texte exprimé dans le jeu de caractères courant de 4D en un texte exprimé dans un autre jeu de caractères."
		},
		"Convert path POSIX to system": {
			"Syntax": "**Convert path POSIX to system** ( *cheminPosix* {; *} ) : Text",
			"Params": [
				[
					"cheminPosix",
					"Text",
					"->",
					"Chemin d’accès POSIX"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Option d’encodage"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès exprimé en syntaxe système"
				]
			],
			"Summary": "La commande **Convert path POSIX to system** convertit un chemin d’accès exprimé avec la syntaxe POSIX (Unix) en chemin d’accès exprimé avec la syntaxe système."
		},
		"Convert path system to POSIX": {
			"Syntax": "**Convert path system to POSIX** ( *cheminSystème* {; *} ) : Text",
			"Params": [
				[
					"cheminSystème",
					"Text",
					"->",
					"Chemin d’accès relatif ou absolu exprimé en syntaxe système"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Option d’encodage"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès absolu exprimé en syntaxe POSIX"
				]
			],
			"Summary": "La commande **Convert path system to POSIX** convertit un chemin d’accès exprimé avec la syntaxe système en chemin d’accès exprimé avec la syntaxe POSIX (Unix)."
		},
		"CONVERT PICTURE": {
			"Syntax": "**CONVERT PICTURE** ( *image* ; *codec* {; *compression*} )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image à convertir"
				],
				[
					"<-",
					"Image convertie"
				],
				[
					"codec",
					"Text",
					"->",
					"Identifiant de codec d'image"
				],
				[
					"compression",
					"Real",
					"->",
					"Qualité de compression"
				]
			],
			"Summary": "La commande **CONVERT PICTURE** convertit *image* dans un nouveau type."
		},
		"Convert to text": {
			"Syntax": "**Convert to text** ( *blob* ; *jeuCaractères* ) : Text",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB contenant un texte exprimé dans un jeu de caractères spécifique"
				],
				[
					"jeuCaractères",
					"Text, Integer",
					"->",
					"Nom ou Numéro du jeu de caractères de blob"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Contenu de blob exprimé dans le jeu de caractères 4D"
				]
			],
			"Summary": "La commande **Convert to text** convertit le texte contenu dans le paramètre *blob* et le retourne en texte exprimé dans le jeu de caractères de 4D."
		},
		"COPY ARRAY": {
			"Syntax": "**COPY ARRAY** ( *source* ; *destination* )",
			"Params": [
				[
					"source",
					"Array",
					"->",
					"Tableau à recopier"
				],
				[
					"destination",
					"Array",
					"<-",
					"Tableau de destination"
				]
			],
			"Summary": "La commande **COPY ARRAY** crée ou remplace le tableau *destination* avec les mêmes contenu, taille et type que le tableau *source*."
		},
		"COPY BLOB": {
			"Syntax": "**COPY BLOB** ( *srcBLOB* ; *dstBLOB* ; *srcOffset* ; *dstOffset* ; *nombre* )",
			"Params": [
				[
					"srcBlob",
					"Blob",
					"->",
					"BLOB source"
				],
				[
					"dstBlob",
					"Blob",
					"->",
					"BLOB de destination"
				],
				[
					"srcOffset",
					"Integer",
					"->",
					"Position dans la source pour la copie"
				],
				[
					"dstOffset",
					"Integer",
					"->",
					"Position dans la destination pour la copie"
				],
				[
					"nombre",
					"Integer",
					"->",
					"Nombre d'octets à copier"
				]
			],
			"Summary": "**COPY BLOB** copie le nombre d'octets spécifié par *nombre* du BLOB *srcBLOB* vers le BLOB *dstBLOB*."
		},
		"COPY DOCUMENT": {
			"Syntax": "**COPY DOCUMENT** ( *nomSource* ; *nomDest* {; *nouvNom*} {; *} )",
			"Params": [
				[
					"nomSource",
					"Text",
					"->",
					"Chemin d’accès du fichier ou du dossier à copier"
				],
				[
					"nomDest",
					"Text",
					"->",
					"Nom ou chemin d’accès du fichier ou du dossier copié"
				],
				[
					"nouvNom",
					"Text",
					"->",
					"Nouveau nom du fichier ou du dossier copié"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Remplacer le document existant le cas échéant"
				]
			],
			"Summary": "La commande **COPY DOCUMENT** copie le fichier ou dossier désigné par *nomSource* à l'emplacement désigné par *nomDest* et le renomme optionnellement."
		},
		"Copy list": {
			"Syntax": "**Copy list** ( *liste* ) : Integer",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de la liste à copier"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de la nouvelle liste"
				]
			],
			"Summary": "La commande **Copy list** duplique la liste dont vous passez le numéro de référence dans le paramètre *liste* et retourne le numéro de référence de la nouvelle liste."
		},
		"COPY NAMED SELECTION": {
			"Syntax": "**COPY NAMED SELECTION** ( {*laTable* ;} *nom* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle il faut copier la sélection ou Table par défaut si ce paramètre est omis"
				],
				[
					"nom",
					"Text",
					"->",
					"Nom de la sélection temporaire à créer"
				]
			],
			"Summary": "**COPY NAMED SELECTION** copie la sélection courante de *laTable* dans une sélection temporaire *nom*."
		},
		"Copy parameters": {
			"Syntax": "**Copy parameters** {( *startFrom* )} : Collection",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Starting index (included)"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"New collection containing parameters actually passed"
				]
			],
			"Summary": "La commande Copy parameters retourne une nouvelle collection contenant tous les paramètres passés à une méthode ou à une fonction."
		},
		"COPY SET": {
			"Syntax": "**COPY SET** ( *srcEns* ; *dstEns* )",
			"Params": [
				[
					"srcEns",
					"Text",
					"->",
					"Nom de l'ensemble source"
				],
				[
					"dstEns",
					"Text",
					"->",
					"Nom de l'ensemble de destination"
				]
			],
			"Summary": "La commande **COPY SET** copie le contenu de l'ensemble *srcEns* dans l'ensemble *dstEns*."
		},
		"Cos": {
			"Syntax": "**Cos** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre, exprimé en radians, dont vous voulez connaître le cosinus"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Cosinus de nombre"
				]
			],
			"Summary": "**Cos** retourne le cosinus de *nombre*."
		},
		"Count in array": {
			"Syntax": "**Count in array** ( *tableau* ; *valeur* ) : Integer",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau dans lequel effectuer le comptage"
				],
				[
					"valeur",
					"Expression",
					"->",
					"Valeur à compter"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d’occurrences trouvées"
				]
			],
			"Summary": "La commande **Count in array** retourne le nombre d’occurrences de *valeur* dans *tableau*."
		},
		"Count list items": {
			"Syntax": "**Count list items** ( {* ;} *liste* {; *} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si omis (défaut) : Retourner les éléments visibles (déployés) dans la ou les liste(s) Si spécifié : Retourner tous les éléments"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'éléments visibles (déployés) si 2e * omis ou Nombre total d’éléments si 2e * passé"
				]
			],
			"Summary": "La fonction **Count list items** retourne soit le nombre d'éléments visibles soit le nombre total d'éléments dans la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"Count menu items": {
			"Syntax": "**Count menu items** ( *menu* {; *process*} ) : Integer",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de lignes du menu"
				]
			],
			"Summary": "La commande **Count menu items** retourne le nombre de lignes (commandes) de menus présentes dans le menu dont vous avez passé le numéro ou la référence dans *menu."
		},
		"Count menus": {
			"Syntax": "**Count menus** {( *process* )} : Integer",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de menus de la barre de menus courante"
				]
			],
			"Summary": "La commande **Count menus** retourne le nombre de menus présents dans la barre de menus."
		},
		"Count parameters": {
			"Syntax": "**Count parameters**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de paramètres effectivement passés"
				]
			],
			"Summary": "**Count parameters** retourne le nombre de paramètres passés à une méthode projet."
		},
		"Count screens": {
			"Syntax": "**Count screens**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'écrans"
				]
			],
			"Summary": "**Count screens** retourne le nombre de moniteurs qui sont connectés à votre machine."
		},
		"Count tasks": {
			"Syntax": "**Count tasks**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre total de process ouverts (y compris les process du moteur de 4D)"
				]
			],
			"Summary": "**Count tasks** retourne le numéro de process vivant le plus élevé sur un poste 4D distant, 4D Server (procédures stockées) ou dans une version monoposte de 4D."
		},
		"Count user processes": {
			"Syntax": "**Count user processes**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de process vivants (à l'exception de process internes)"
				]
			],
			"Summary": "**Count user processes** retourne le nombre courant de process \"vivants\" dans l'application 4D et dont le type est différent de -25 (Internal Timer Process), -31 (Client Manager Process) et -15 (Server Interface Process)."
		},
		"Count users": {
			"Syntax": "**Count users**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'utilisateurs connectés au serveur"
				]
			],
			"Summary": "La commande **Count users** retourne le nombre d'utilisateurs connectés au poste serveur."
		},
		"CREATE ALIAS": {
			"Syntax": "**CREATE ALIAS** ( *cheminCible* ; *cheminAlias* )",
			"Params": [
				[
					"cheminCible",
					"Text",
					"->",
					"Nom ou chemin d’accès de la cible de l’alias/du raccourci"
				],
				[
					"cheminAlias",
					"Text",
					"->",
					"Nom ou chemin d’accès complet de l’alias/du raccourci à créer"
				]
			],
			"Summary": "La commande **CREATE ALIAS** crée un alias (appelé “raccourci” sous Windows) du fichier ou dossier cible désigné par le paramètre *cheminCible*, avec le nom et l’emplacement définis dans le paramètre *cheminAlias*."
		},
		"CREATE DATA FILE": {
			"Syntax": "**CREATE DATA FILE** ( *cheminAccès* )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Nom ou chemin d’accès complet du fichier de données à créer"
				]
			],
			"Summary": "La commande **CREATE DATA FILE** permet de créer un nouveau fichier de données sur disque et de remplacer à la volée le fichier de données ouvert par l’application 4D."
		},
		"Create document": {
			"Syntax": "**Create document** ( *nomFichier* {; *typeFichier*} ) : Time",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom de document ou Chemin d'accès complet de document ou Chaîne vide pour afficher la boîte de dialogue standard d'enregistrement de fichiers"
				],
				[
					"typeFichier",
					"Text",
					"->",
					"Liste des types de documents à filtrer, ou \"*\" pour ne pas filtrer les documents"
				],
				[
					"Résultat",
					"Time",
					"<-",
					"Numéro de référence du document"
				]
			],
			"Summary": "La commande **Create document** crée un document et retourne son numéro de référence de document."
		},
		"CREATE EMPTY SET": {
			"Syntax": "**CREATE EMPTY SET** ( {*laTable* ;} *ensemble* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle créer un ensemble vide ou Table par défaut si ce paramètre est omis"
				],
				[
					"ensemble",
					"Text",
					"->",
					"Nom du nouvel ensemble vide"
				]
			],
			"Summary": "**CREATE EMPTY SET** crée un ensemble vide, *ensemble*, pour *laTable*."
		},
		"CREATE FOLDER": {
			"Syntax": "**CREATE FOLDER** ( *cheminAccès* {; *} )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Chemin d'accès au nouveau dossier à créer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Créer la hiérarchie du dossier"
				]
			],
			"Summary": "La commande **CREATE FOLDER** crée un dossier en fonction du chemin d'accès que vous passez dans le paramètre *cheminAccès*."
		},
		"CREATE INDEX": {
			"Syntax": "**CREATE INDEX** ( *laTable* ; *tabChamps* ; *typeIndex* ; *nomIndex* {; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle créer un index"
				],
				[
					"tabChamps",
					"Pointer array",
					"->",
					"Pointeur(s) vers le(s) champ(s) à indexer"
				],
				[
					"typeIndex",
					"Integer",
					"->",
					"Type d’index à créer : -1 = Mots-clés, 0 = par défaut, 1 = B-Tree standard, 3 = BTree cluster"
				],
				[
					"nomIndex",
					"Text",
					"->",
					"Nom de l'index à créer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = indexation asynchrone"
				]
			],
			"Summary": "index standard sur un ou plusieurs champs (index composite)"
		},
		"Create menu": {
			"Syntax": "**Create menu** {( *menu* )} : Text",
			"Params": [
				[
					"menu",
					"Text, Integer, Text",
					"->",
					"Référence de menu ou Numéro ou Nom de barre de menus"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence du menu"
				]
			],
			"Summary": "La commande **Create menu** permet de créer un nouveau menu en mémoire."
		},
		"CREATE RECORD": {
			"Syntax": "**CREATE RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle créer un enregistrement ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**CREATE RECORD** crée un nouvel enregistrement vide pour *laTable*, mais ne l'affiche pas à l'écran."
		},
		"CREATE RELATED ONE": {
			"Syntax": "**CREATE RELATED ONE** ( *leChamp* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ N (champ d'où part le lien)"
				]
			],
			"Summary": "**CREATE RELATED ONE** a deux effets."
		},
		"CREATE SELECTION FROM ARRAY": {
			"Syntax": "**CREATE SELECTION FROM ARRAY** ( *laTable* ; *tabEnrg* {; *nom*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de la sélection"
				],
				[
					"tabEnrg",
					"Integer, Boolean array",
					"->",
					"Tableau de n° d’enregistrements, ou Tableau de booléens (Vrai = l’enregistrement est dans la sélection, Faux = il n’est pas dans la sélection)"
				],
				[
					"nom",
					"Text",
					"->",
					"Nom de la sélection temporaire à créer, ou Appliquer la commande à la sélection courante si ce paramètre est omis ou vide"
				]
			],
			"Summary": "La commande **CREATE SELECTION FROM ARRAY** construit la sélection temporaire *nom*"
		},
		"CREATE SET FROM ARRAY": {
			"Syntax": "**CREATE SET FROM ARRAY** ( *laTable* ; *tabEnrg* {; *nomEnsemble*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l’ensemble"
				],
				[
					"tabEnrg",
					"Integer, Boolean array",
					"->",
					"Tableau de n° d’enregistrements, ou Tableau de booléens (Vrai = l’enregistrement est dans l’ensemble, Faux = il n’est pas dans l’ensemble)"
				],
				[
					"nomEnsemble",
					"Text",
					"->",
					"Nom de l’ensemble à créer, ou Appliquer la commande à l’ensemble Userset si ce paramètre est omis ou vide"
				]
			],
			"Summary": "La commande **CREATE SET FROM ARRAY** crée l’ensemble *nomEnsemble*"
		},
		"CREATE SET": {
			"Syntax": "**CREATE SET** ( {*laTable* ;} *ensemble* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle vous voulez créer un ensemble à partir de la sélection courante ou Table par défaut si ce paramètre est omis"
				],
				[
					"ensemble",
					"Text",
					"->",
					"Nom du nouvel ensemble"
				]
			],
			"Summary": "**CREATE SET** crée un nouvel ensemble, *ensemble*, pour *laTable*, et y place la sélection courante."
		},
		"CREATE THUMBNAIL": {
			"Syntax": "**CREATE THUMBNAIL** ( *source* ; *dest* {; *largeur* {; *hauteur* {; *mode* {; *profondeur*}}}} )",
			"Params": [
				[
					"source",
					"Picture",
					"->",
					"Champ ou variable image 4D à passer en imagette"
				],
				[
					"dest",
					"Picture",
					"<-",
					"Imagette résultante"
				],
				[
					"largeur",
					"Integer",
					"->",
					"Largeur de l’imagette en pixels, Par défaut = 48"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de l’imagette en pixels, Par défaut = 48"
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode de création de l’imagette Par défaut = proportionnelle centrée (6)"
				],
				[
					"profondeur",
					"Integer",
					"->",
					"Obsolète, ne pas utiliser"
				]
			],
			"Summary": "La commande **CREATE THUMBNAIL** retourne une imagette à partir d’une image source."
		},
		"Current client authentication": {
			"Syntax": "**Current client authentication** {( *domaine* ; *protocole* )} : Text",
			"Params": [
				[
					"domaine",
					"Text",
					"<-",
					"Nom du domaine"
				],
				[
					"protocole",
					"Text",
					"<-",
					"\"Kerberos\", \"NTLM\" ou chaîne vide"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom d'utilisateur de session retourné par Windows"
				]
			],
			"Summary": "La commande **Current client authentication** envoie au serveur Active Directory de Windows une requête d'authentification du client courant et, en cas de succès, retourne le nom d'utilisateur Windows de ce client (identifiant de session)."
		},
		"Current date": {
			"Syntax": "**Current date** {( * )} : Date",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Retourne la date du jour du serveur"
				],
				[
					"Résultat",
					"Date",
					"<-",
					"Date du jour"
				]
			],
			"Summary": "**Current date** retourne la date courante telle que définie dans l'horloge système de la machine."
		},
		"Current default table": {
			"Syntax": "**Current default table**  : Pointer",
			"Params": [
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers la table par défaut"
				]
			],
			"Summary": "**Current default table** retourne un pointeur vers la table qui a été passée au dernier appel de la commande DEFAULT TABLE pour le process courant."
		},
		"Current form name": {
			"Syntax": "**Current form name**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom du formulaire projet courant ou du formulaire table courant dans le process"
				]
			],
			"Summary": "La commande **Current form name** retourne le nom du formulaire courant défini pour le process."
		},
		"Current form table": {
			"Syntax": "**Current form table**  : Pointer",
			"Params": [
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers la table à laquelle appartient le formulaire actuellement affiché"
				]
			],
			"Summary": "La fonction **Current form table** retourne un pointeur vers la table à laquelle appartient le formulaire affiché à l'écran ou imprimé dans le process courant."
		},
		"Current form window": {
			"Syntax": "**Current form window**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de la fenêtre du formulaire courant"
				]
			],
			"Summary": "La commande **Current form window** retourne la référence de la fenêtre du formulaire courant."
		},
		"Current machine": {
			"Syntax": "**Current machine**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la machine sur le réseau"
				]
			],
			"Summary": "La commande   **Current machine** retourne le nom de la machine tel qu'il a été défini dans les paramètres réseau du système d'exploitation."
		},
		"Current method name": {
			"Syntax": "**Current method name**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la méthode d’appel"
				]
			],
			"Summary": "La commande **Current method name** retourne le nom de la méthode dans laquelle elle est appelée."
		},
		"Current method path": {
			"Syntax": "**Current method path**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin interne complet de la méthode en cours d’exécution"
				]
			],
			"Summary": "La commande **Current method path** retourne le chemin d’accès interne de la méthode base, du trigger, de la méthode projet, méthode formulaire ou méthode objet en cours d’exécution."
		},
		"Current process name": {
			"Syntax": "**Current process name**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom du process courant"
				]
			],
			"Summary": "La commande **Current process name** retourne le nom du process depuis lequel elle est appelée."
		},
		"Current process": {
			"Syntax": "**Current process**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du process en cours d'exécution"
				]
			],
			"Summary": "**Current process** retourne le numéro du process à partir duquel la fonction a été appelée."
		},
		"Current system user": {
			"Syntax": "**Current system user**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de l'utilisateur de la machine sur le réseau"
				]
			],
			"Summary": "La fonction **Current system user** retourne le nom du possesseur de la machine, tel qu'il a été défini dans le compte d'utilisateur courant sur la machine."
		},
		"Current time": {
			"Syntax": "**Current time** {( * )} : Time",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Retourne l'heure courante sur le poste serveur"
				],
				[
					"Résultat",
					"Time",
					"<-",
					"Heure courante"
				]
			],
			"Summary": "La fonction **Current time** retourne l'heure courante définie dans l'horloge de votre système."
		},
		"Current user": {
			"Syntax": "**Current user** {( *utilisateur* )} : Text",
			"Params": [
				[
					"utilisateur",
					"Integer",
					"->",
					"Alias utilisateur ou compte utilisateur 4D"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de l'utilisateur courant"
				]
			],
			"Summary": "**Current user** retourne l'alias ou le compte de l'utilisateur courant."
		},
		"CUT NAMED SELECTION": {
			"Syntax": "**CUT NAMED SELECTION** ( {*laTable* ;} *nom* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de la sélection ou Table par défaut si ce paramètre est omis"
				],
				[
					"nom",
					"Text",
					"->",
					"Nom de la sélection temporaire à créer"
				]
			],
			"Summary": "**CUT NAMED SELECTION** crée la sélection temporaire *nom* et y place la sélection courante de *laTable*."
		},
		"Data file encryption status": {
			"Syntax": "**Data file encryption status** ( cheminStructure , cheminDonnées ) : Object",
			"Params": [
				[
					"cheminStructure",
					"Text",
					"->",
					"Chemin d'accès du fichier de structure à vérifier"
				],
				[
					"cheminDonnées",
					"Text",
					"->",
					"Chemin d'accès du fichier de données 4D à vérifier"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur le chiffrement du fichier de données et de chaque table"
				]
			],
			"Summary": "La commande **Data file encryption status** retourne un objet qui fournit le statut de chiffrement du fichier de données indiqué par les paramètres *cheminStructure* et *cheminDonnées*."
		},
		"Data file": {
			"Syntax": "**Data file** {( *segment* )} : Text",
			"Params": [
				[
					"segment",
					"Integer",
					"->",
					"Obsolète, ne pas utiliser"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom long du fichier de données de la base"
				]
			],
			"Summary": "La fonction **Data file** retourne le nom long (c'est-à-dire le chemin d'accès complet au fichier, y compris son nom) du fichier de données de la base avec laquelle vous êtes en train de travailler."
		},
		"Database measures": {
			"Syntax": "**Database measures** {( *options* )} : Object",
			"Params": [
				[
					"options",
					"Object",
					"->",
					"Options de retour"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contenant des mesures sur la base"
				]
			],
			"Summary": "La commande **Database measures** vous permet d'obtenir un ensemble d'informations détaillées sur les événements du moteur de base de données de 4D."
		},
		"Date": {
			"Syntax": "**Date** ( *expression* ) : Date",
			"Params": [
				[
					"expression",
					"Text, Date",
					"->",
					"Chaîne contenant la date à retourner ou expression de type Date"
				],
				[
					"Résultat",
					"Date",
					"<-",
					"Expression de type Date"
				]
			],
			"Summary": "La fonction **Date** extrait et retourne la date de la chaîne *expression*."
		},
		"Day number": {
			"Syntax": "**Day number** ( *laDate* ) : Integer",
			"Params": [
				[
					"laDate",
					"Date",
					"->",
					"Date dont vous souhaitez connaître le numéro du jour"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro représentant le jour de la semaine auquel date correspond"
				]
			],
			"Summary": "La fonction **Day number** retourne un numéro représentant le jour de la semaine auquel *laDate* correspond."
		},
		"Day of": {
			"Syntax": "**Day of** ( *date* ) : Integer",
			"Params": [
				[
					"date",
					"Date",
					"->",
					"Date dont vous voulez extraire le jour"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Jour du mois de date"
				]
			],
			"Summary": "**Day of** retourne le jour du mois de *laDate*."
		},
		"Deactivated": {
			"Syntax": "**Deactivated**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est en désactivation"
				]
			],
			"Summary": "**Deactivated** retourne Vrai dans une méthode formulaire ou méthode objet lorsque la fenêtre appartenant au process du premier plan, contenant le formulaire, passe à l'arrière-plan."
		},
		"Dec": {
			"Syntax": "**Dec** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Valeur dont voulez obtenir la partie décimale"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Partie décimale de nombre"
				]
			],
			"Summary": "**Dec** retourne la partie décimale de *nombre*."
		},
		"DECRYPT BLOB": {
			"Syntax": "**DECRYPT BLOB** ( *aDécrypter* ; *cléPubEmetteur* {; *cléPrivRécepteur*} )",
			"Params": [
				[
					"aDécrypter",
					"Blob",
					"<->",
					"Données à décrypter"
				],
				[
					"",
					"",
					"",
					"Données décryptées"
				],
				[
					"cléPubEmetteur",
					"Blob",
					"->",
					"Clé publique de l’émetteur"
				],
				[
					"cléPrivRécepteur",
					"Blob",
					"->",
					"Clé privée du récepteur"
				]
			],
			"Summary": "La commande **DECRYPT BLOB** permet de décrypter le contenu du BLOB *aDécrypter* à l’aide de la clé publique de l’émetteur *cléPubEmetteur* ainsi que, optionnellement, de la clé privée du récepteur *cléPrivRécepteur*."
		},
		"Decrypt data BLOB": {
			"Syntax": "**Decrypt data BLOB** ( *blobToDecrypt* ; *keyObject* ; *salt* ; *decryptedBLOB* ) : Boolean<br/>**Decrypt data BLOB** ( *blobToDecrypt* ; *passPhrase* ; *salt* ; *decryptedBLOB* ) : Boolean",
			"Params": [
				[
					"blobToDecrypt",
					"Blob",
					"->",
					"BLOB à décrypter"
				],
				[
					"keyObject &#124; passPhrase",
					"Objet, Texte",
					"->",
					"Objet JSON contenant la clé de chiffrement ou le mot de passe pour générer directement une clé de chiffrement (texte)"
				],
				[
					"salt",
					"Integer",
					"->",
					"Additional salt for algorithm"
				],
				[
					"decryptedBlob",
					"Blob",
					"<-",
					"BLOB décrypté"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"True si le déchiffrement a été effectué correctement. Sinon False"
				]
			],
			"Summary": "La commande **Decrypt data BLOB**décrypte le paramètre blobToDecrypt avec le même algorithme utilisé par 4D pour décrypter les données (AES-256) et retourne le résultat dans decryptedBLOB."
		},
		"DEFAULT TABLE": {
			"Syntax": "**DEFAULT TABLE** ( *laTable* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à définir comme table par défaut"
				]
			],
			"Summary": "**Conseil :** Bien que l'appel de **DEFAULT TABLE** et l'omission du nom de la table rendent le code plus lisible, la plupart des programmeurs estiment que l'utilisation de cette commande apporte plus d'inconvénients que d'avantages."
		},
		"DELAY PROCESS": {
			"Syntax": "**DELAY PROCESS** ( *process* ; *durée* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				],
				[
					"durée",
					"Real",
					"->",
					"Durée exprimée en ticks"
				]
			],
			"Summary": "**DELAY PROCESS** permet d'endormir un *process* pour un certain nombre de ticks (1 tick = 1/60ème de seconde)."
		},
		"DELETE DOCUMENT": {
			"Syntax": "**DELETE DOCUMENT** ( *nomFichier* )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom de document ou Chemin d'accès complet au document"
				]
			],
			"Summary": "**DELETE DOCUMENT** supprime le document dont vous avez passé le nom dans *document*."
		},
		"DELETE FOLDER": {
			"Syntax": "**DELETE FOLDER** ( *dossier* {; *optionSuppression*} )",
			"Params": [
				[
					"dossier",
					"Text",
					"->",
					"Nom ou chemin d’accès complet du dossier à supprimer"
				],
				[
					"optionSuppression",
					"Integer",
					"->",
					"Option de suppression du dossier"
				]
			],
			"Summary": "La commande **DELETE FOLDER** supprime le dossier dont vous avez passé le nom ou le chemin d’accès complet dans *dossier*."
		},
		"DELETE FROM ARRAY": {
			"Syntax": "**DELETE FROM ARRAY** ( *tableau* ; *positionDépart* {; *combien*} )",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau dans lequel supprimer des lignes"
				],
				[
					"positionDépart",
					"Integer",
					"->",
					"Elément de départ de la suppression"
				],
				[
					"combien",
					"Integer",
					"->",
					"Nombre d'éléments à supprimer ou 1 élément si ce paramètre est omis"
				]
			],
			"Summary": "La commande **DELETE FROM ARRAY** supprime un ou plusieurs élément(s) de *tableau*."
		},
		"DELETE FROM BLOB": {
			"Syntax": "**DELETE FROM BLOB** ( *blob* ; *offset* ; *nombre* )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB duquel supprimer des octets"
				],
				[
					"offset",
					"Integer",
					"->",
					"Offset à partir duquel supprimer les octets"
				],
				[
					"nombre",
					"Integer",
					"->",
					"Nombre d'octets à supprimer"
				]
			],
			"Summary": "**DELETE FROM BLOB** supprime le nombre d'octets spécifié par *nombre* du BLOB *blob* à partir de la position définie par *offset* (exprimée de manière relative à l'origine du BLOB)."
		},
		"DELETE FROM LIST": {
			"Syntax": "**DELETE FROM LIST** ( {* ;} *liste* ; réfElément | * {; *} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"réfElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste ou * pour l'élément de la liste actuellement sélectionné"
				],
				[
					"*",
					"Operator",
					"->",
					"Si spécifié, effacer les sous-listes de la mémoire (le cas échéant) Si omis, ne pas effacer les sous-listes"
				]
			],
			"Summary": "La commande **DELETE FROM LIST** supprime l'élément désigné par le paramètre *réfElément* de la liste dont le numéro de référence ou le nom d'objet est passé dans *liste*."
		},
		"DELETE INDEX": {
			"Syntax": "**DELETE INDEX** ( *ptrChp* {; *} )<br/>**DELETE INDEX** ( *nomIndex* {; *} )",
			"Params": [
				[
					"ptrChp &#124; nomIndex",
					"Pointeur, Chaîne",
					"->",
					"Pointeur vers le champ duquel supprimer les index ou Nom de l’index à supprimer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = opération asynchrone"
				]
			],
			"Summary": "La commande **DELETE INDEX** permet de supprimer un ou plusieurs index existant dans la base."
		},
		"DELETE MENU ITEM": {
			"Syntax": "**DELETE MENU ITEM** ( *menu* ; *ligneMenu* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				]
			],
			"Summary": "La commande **DELETE MENU ITEM** supprime la ligne de menu dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*."
		},
		"DELETE RECORD": {
			"Syntax": "**DELETE RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle supprimer l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**DELETE RECORD** supprime de *laTable* l'enregistrement courant du process en cours."
		},
		"DELETE SELECTION": {
			"Syntax": "**DELETE SELECTION** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle supprimer la sélection courante ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "La commande **DELETE SELECTION** supprime la sélection courante d'enregistrements de *laTable*."
		},
		"Delete string": {
			"Syntax": "**Delete string** ( *source* ; *positionDépart* ; *nbCars* ) : Text",
			"Params": [
				[
					"source",
					"Text",
					"->",
					"Chaîne de départ"
				],
				[
					"positionDépart",
					"Integer",
					"->",
					"Premier caractère à supprimer"
				],
				[
					"nbCars",
					"Integer",
					"->",
					"Nombre de caractères à supprimer"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne résultante"
				]
			],
			"Summary": "**Delete string** supprime *nbCars* dans *source* à partir de *positionDépart* et retourne la chaîne résultante."
		},
		"DELETE USER": {
			"Syntax": "**DELETE USER** ( *réfUtilisateur* )",
			"Params": [
				[
					"réfUtilisateur",
					"Integer",
					"->",
					"Numéro d'identification de l'utilisateur à supprimer"
				]
			],
			"Summary": "La commande **DELETE USER** supprime l'utilisateur dont le numéro est passé dans *réfUtilisateur*."
		},
		"DESCRIBE QUERY EXECUTION": {
			"Syntax": "**DESCRIBE QUERY EXECUTION** ( *statut* )",
			"Params": [
				[
					"statut",
					"Boolean",
					"->",
					"Vrai=Enregistrer la description des requêtes, Faux=Stopper l'enregistrement"
				]
			],
			"Summary": "La commande **DESCRIBE QUERY EXECUTION** permet d’activer ou d’inactiver le mode d’analyse de l’exécution des recherches pour le process courant."
		},
		"DIFFERENCE": {
			"Syntax": "**DIFFERENCE** ( *ensemble1* ; *ensemble2* ; *résultat* )",
			"Params": [
				[
					"ensemble1",
					"Text",
					"->",
					"Ensemble initial"
				],
				[
					"ensemble2",
					"Text",
					"->",
					"Ensemble à exclure"
				],
				[
					"résultat",
					"Text",
					"->",
					"Ensemble résultant"
				]
			],
			"Summary": "**DIFFERENCE** fusionne *ensemble1* et *ensemble2* et exclut de l'ensemble *résultat* tous les enregistrements se trouvant dans *ensemble2*."
		},
		"DISABLE MENU ITEM": {
			"Syntax": "**DISABLE MENU ITEM** ( *menu* ; *ligneMenu* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				]
			],
			"Summary": "**DISABLE MENU ITEM** désactive la commande de menu dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*."
		},
		"Discover data key": {
			"Syntax": "**Discover data key**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si une clé de chiffrement valide a été trouvée pour le fichier de données courant, sinon Faux"
				]
			],
			"Summary": "La commande **Discover data key** recherche, à la racine de tous les appareils connectés, une clé de chiffrement valide correspondant au fichier de données courant et retourne **Vrai** si l'opération est réussie."
		},
		"DISPLAY NOTIFICATION": {
			"Syntax": "**DISPLAY NOTIFICATION** ( *titre* ; *contenu* {; *durée*} )",
			"Params": [
				[
					"titre",
					"Text",
					"->",
					"Titre de la notification"
				],
				[
					"contenu",
					"Text",
					"->",
					"Texte de la notification"
				],
				[
					"durée",
					"Integer",
					"->",
					"Délai d’affichage en secondes"
				]
			],
			"Summary": "La commande **DISPLAY NOTIFICATION** provoque l’affichage d’un message de notification à destination de l'utilisateur."
		},
		"DISPLAY RECORD": {
			"Syntax": "**DISPLAY RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle afficher l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**DISPLAY RECORD** affiche l'enregistrement courant de *laTable* dans le formulaire entrée courant."
		},
		"DISPLAY SELECTION": {
			"Syntax": "**DISPLAY SELECTION** ( {*laTable*}{; *modeSélection*}{; *saisieListe*}{; *}{; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à laquelle appartient la sélection ou Table par défaut si ce paramètre est omis"
				],
				[
					"modeSélection",
					"Integer",
					"->",
					"Mode de sélection"
				],
				[
					"saisieListe",
					"Boolean",
					"->",
					"Autoriser saisie en liste"
				],
				[
					"*",
					"Operator",
					"->",
					"Utiliser le formulaire sortie en cas de sélection d'un seul enregistrement et masquer les barres de défilement dans le formulaire entrée"
				],
				[
					"*",
					"Operator",
					"->",
					"Afficher les barres de défilement dans le formulaire entrée (= annuler le second effet du premier paramètre *)"
				]
			],
			"Summary": "**DISPLAY SELECTION** affiche, pour le process en cours, la sélection courante de *laTable* dans le formulaire sortie courant."
		},
		"Displayed line number": {
			"Syntax": "**Displayed line number**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de ligne en cours d’affichage"
				]
			],
			"Summary": "La commande **Displayed line number** fonctionne uniquement dans le contexte de l’événement formulaire On Display Detail."
		},
		"DISTINCT ATTRIBUTE PATHS": {
			"Syntax": "**DISTINCT ATTRIBUTE PATHS** ( *champObjet* ; *tabChemins* )",
			"Params": [
				[
					"champObjet",
					"Field",
					"->",
					"Champ objet indexé"
				],
				[
					"tabChemins",
					"Text array",
					"<-",
					"Tableau devant recevoir les chemins d'attributs du champ"
				]
			],
			"Summary": "La commande **DISTINCT ATTRIBUTE PATHS** retourne la liste des chemins d'attributs différents présents dans le champ objet indexé passé dans *champObjet* et ce, pour la sélection courante de la table à laquelle le champ appartient."
		},
		"DISTINCT ATTRIBUTE VALUES": {
			"Syntax": "**DISTINCT ATTRIBUTE VALUES** ( *champObjet* ; *cheminAttribut* ; *tabValeurs* )",
			"Params": [
				[
					"champObjet",
					"Field",
					"->",
					"Champ objet à utiliser"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Nom ou chemin de l'attribut dont vous voulez obtenir les valeurs distinctes"
				],
				[
					"tabValeurs",
					"Text array, Integer array, Boolean array, Date array, Time array",
					"<-",
					"Tableau des valeurs distinctes dans l'attribut"
				]
			],
			"Summary": "La commande **DISTINCT ATTRIBUTE VALUES** crée et remplit le tableau *tabValeurs* avec les valeurs uniques présentes dans l'attribut *cheminAttribut* du champ objet *champObjet* et ce, pour la sélection courante de la table à laquelle appartient le champ."
		},
		"DISTINCT VALUES": {
			"Syntax": "**DISTINCT VALUES** ( *leChamp* ; *tableau* {; *tabNbVal*} )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ à utiliser"
				],
				[
					"tableau",
					"Array",
					"<-",
					"Tableau devant recevoir les données du champ indexable"
				],
				[
					"tabNbVal",
					"Integer array, Real array",
					"<-",
					"Tableau devant recevoir le nombre d'occurrences de chaque valeur"
				]
			],
			"Summary": "**DISTINCT VALUES** crée et remplit le tableau *tableau* avec toutes les valeurs distinctes provenant du champ *leChamp* pour la sélection courante de la table du champ et, optionnellement, retourne dans *tabNbVal* le nombre d'occurrences de chaque valeur."
		},
		"DOCUMENT LIST": {
			"Syntax": "**DOCUMENT LIST** ( *cheminAccès* ; *documents* {; *options*} )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Chemin d'accès de volume ou de dossier"
				],
				[
					"documents",
					"Text array",
					"<-",
					"Nom des documents situés à cet endroit"
				],
				[
					"options",
					"Integer",
					"->",
					"Options de construction de la liste"
				]
			],
			"Summary": "La commande **DOCUMENT LIST** remplit le tableau de type Texte *documents* avec les noms des documents situés à l'endroit que vous avez indiqué avec le paramètre *cheminAccès*."
		},
		"DOCUMENT TO BLOB": {
			"Syntax": "**DOCUMENT TO BLOB** ( *document* ; *blob* )",
			"Params": [
				[
					"document",
					"Text",
					"->",
					"Nom du document"
				],
				[
					"blob",
					"Blob",
					"<->",
					"Champ ou variable de type BLOB devant recevoir le document"
				],
				[
					"",
					"",
					"",
					"Contenu du document"
				]
			],
			"Summary": "**DOCUMENT TO BLOB** charge le contenu de *document* dans *blob*."
		},
		"Document to text": {
			"Syntax": "**Document to text** ( *nomFichier* {; *jeuCaractères* {; *modeRetour*}} ) : Text",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom de document ou Chemin d'accès à un document"
				],
				[
					"jeuCaractères",
					"Text, Integer",
					"->",
					"Nom ou Numéro de jeu de caractères"
				],
				[
					"modeRetour",
					"Integer",
					"->",
					"Mode de traitement des retours à la ligne"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte issu du document"
				]
			],
			"Summary": "La commande **Document to text** permet de récupérer directement le contenu d’un fichier sur disque dans une variable texte ou un champ texte 4D."
		},
		"DOM Append XML child node": {
			"Syntax": "**DOM Append XML child node** ( *refElément* ; *typeEnfant* ; *valeurEnfant* ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"typeEnfant",
					"Integer",
					"->",
					"Type d’enfant à ajouter"
				],
				[
					"valeurEnfant",
					"Text, Blob",
					"->",
					"Texte ou variable (Texte ou BLOB) dont la valeur doit être insérée en tant que noeud enfant"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML enfant"
				]
			],
			"Summary": "La commande **DOM Append XML child node** permet d’ajouter la valeur *valeurEnfant* au noeud XML désigné par *refElément*."
		},
		"DOM Append XML element": {
			"Syntax": "**DOM Append XML element** ( *refElémentCible* ; *refElémentSource* ) : Text",
			"Params": [
				[
					"refElémentCible",
					"Text",
					"->",
					"Référence de l’élément XML parent"
				],
				[
					"refElémentSource",
					"Text",
					"->",
					"Référence de l’élément XML à ajouter"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence du nouvel élément XML"
				]
			],
			"Summary": "La commande **DOM Append XML element** permet d’ajouter un nouvel élément XML aux enfants de l’élément XML dont la référence est passée dans le paramètre *refElémentCible*."
		},
		"DOM CLOSE XML": {
			"Syntax": "**DOM CLOSE XML** ( *refElément* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				]
			],
			"Summary": "La commande **DOM CLOSE XML** libère l’espace mémoire occupé par l’objet XML désigné par *refElément*."
		},
		"DOM Count XML attributes": {
			"Syntax": "**DOM Count XML attributes** ( *refElément* ) : Integer",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d’attributs"
				]
			],
			"Summary": "La commande **DOM Count XML attributes** retourne le nombre d’attributs XML présents dans l’élément XML désigné par *refElément*."
		},
		"DOM Count XML elements": {
			"Syntax": "**DOM Count XML elements** ( *refElément* ; *nomElément* ) : Integer",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElément",
					"Text",
					"->",
					"Nom d'éléments XML à compter"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d’éléments"
				]
			],
			"Summary": "La commande **DOM Count XML elements** retourne le nombre d’éléments “enfants” dépendants de l’élément parent *refElément* et nommés *nomElément*."
		},
		"DOM Create XML element arrays": {
			"Syntax": "**DOM Create XML element arrays** ( *refElément* ; *xChemin* {; *tabNomsAttributs* ; *tabValeursAttributs*} {; *tabNomsAttributs2* ; *tabValeursAttributs2* ; ... ; *tabNomsAttributsN* ; *tabValeursAttributsN*} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				],
				[
					"xChemin",
					"Text",
					"->",
					"Chemin XPath de l’élément XML à créer"
				],
				[
					"tabNomsAttributs",
					"Text array",
					"->",
					"Tableau de noms d’attributs"
				],
				[
					"tabValeursAttributs",
					"Text array",
					"->",
					"Tableau de valeurs d’attributs"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l'élément XML créé"
				]
			],
			"Summary": "La commande **DOM Create XML element arrays** permet d’ajouter un nouvel élément dans l’élément XML *refElément* ainsi que, facultativement, des attributs et leurs valeurs sous forme de tableaux."
		},
		"DOM Create XML element": {
			"Syntax": "**DOM Create XML element** ( *refElément* ; *xPath* {; *nomAttribut* ; *valeurAttribut*} {; *nomAttribut2* ; *valeurAttribut2* ; ... ; *nomAttributN* ; *valeurAttributN*} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				],
				[
					"xPath",
					"Text",
					"->",
					"Chemin XPath de l’élément XML à créer"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Attribut à définir"
				],
				[
					"valeurAttribut",
					"Text, Boolean, Integer, Real, Time, Date",
					"->",
					"Nouvelle valeur d’attribut"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML créé"
				]
			],
			"Summary": "La commande **DOM Create XML element** permet de créer un nouvel élément dans l’élément XML *refElément*, à l’emplacement du noeud désigné par le paramètre *xPath*, et de lui ajouter éventuellement des attributs."
		},
		"DOM Create XML Ref": {
			"Syntax": "**DOM Create XML Ref** ( *racine* {; *nameSpace*} {; *nSNom* ; *nSValeur*} {; *nSNom2* ; *nSValeur2* ; ... ; *nSNomN* ; *nSValeurN*} ) : Text",
			"Params": [
				[
					"racine",
					"Text",
					"->",
					"Nom de l’élément racine"
				],
				[
					"nameSpace",
					"Text",
					"->",
					"Valeur de l’espace de nommage (Namespace)"
				],
				[
					"nSNom",
					"Text",
					"->",
					"Nom d’espace de nommage"
				],
				[
					"nSValeur",
					"Text",
					"->",
					"Valeur d’espace de nommage"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML racine"
				]
			],
			"Summary": "La commande **DOM Create XML Ref** crée un arbre XML vide en mémoire et retourne sa référence."
		},
		"DOM EXPORT TO FILE": {
			"Syntax": "**DOM EXPORT TO FILE** ( *refElément* ; *cheminFichier* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				],
				[
					"cheminFichier",
					"Text",
					"->",
					"Chemin d’accès complet du fichier"
				]
			],
			"Summary": "La commande **DOM EXPORT TO FILE** permet de sauvegarder un arbre XML dans un fichier sur disque."
		},
		"DOM EXPORT TO VAR": {
			"Syntax": "**DOM EXPORT TO VAR** ( *refElément* ; *vVarXml* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				],
				[
					"vVarXml",
					"Text, Blob",
					"<-",
					"Variable devant recevoir l’arbre XML"
				]
			],
			"Summary": "La commande **DOM EXPORT TO VAR** permet de sauvegarder un arbre XML dans une variable texte ou BLOB."
		},
		"DOM Find XML element by ID": {
			"Syntax": "**DOM Find XML element by ID** ( *refElément* ; *id* ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"id",
					"Text",
					"->",
					"Valeur de l’attribut ID de l’élément à chercher"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément trouvé (le cas échéant)"
				]
			],
			"Summary": "La commande **DOM Find XML element by ID** vous permet de rechercher, à l'intérieur d'un document XML, l'élément dont l'attribut id est égal à la valeur passée dans le paramètre *id*."
		},
		"DOM Find XML element": {
			"Syntax": "**DOM Find XML element** ( *refElément* ; *xPath* {; *tabRefEléments*} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"xPath",
					"Text",
					"->",
					"Chemin XPath de l’élément à chercher"
				],
				[
					"tabRefEléments",
					"Text array",
					"<-",
					"Liste des références d’éléments trouvés (le cas échéant)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément trouvé (le cas échéant)"
				]
			],
			"Summary": "La commande **DOM Find XML element** vous permet de rechercher des éléments XML spécifiques dans une structure XML."
		},
		"DOM Get first child XML element": {
			"Syntax": "**DOM Get first child XML element** ( *refElément* {; *nomElémentEnf* {; *valeurElémentEnf*}} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElémentEnf",
					"Text",
					"<-",
					"Nom de l'élément XML enfant"
				],
				[
					"valeurElémentEnf",
					"Text",
					"<-",
					"Valeur de l'élément XML enfant"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML enfant"
				]
			],
			"Summary": "La commande **DOM Get first child XML element** retourne une référence XML vers le premier “enfant” de l’élément XML passé en référence dans *refElément*."
		},
		"DOM Get last child XML element": {
			"Syntax": "**DOM Get last child XML element** ( *refElément* {; *nomElémentEnf* {; *valeurElémentEnf*}} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElémentEnf",
					"Text",
					"<-",
					"Nom de l’élément enfant"
				],
				[
					"valeurElémentEnf",
					"Text",
					"<-",
					"Valeur de l’élément enfant"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML"
				]
			],
			"Summary": "La commande **DOM Get last child XML element** retourne une référence XML vers le dernier “enfant” de l’élément XML passé en référence dans *refElément*."
		},
		"DOM Get next sibling XML element": {
			"Syntax": "**DOM Get next sibling XML element** ( *refElément* {; *nomElémentFrère* {; *valeurElémentFrère*}} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElémentFrère",
					"Text",
					"<-",
					"Nom de l'élément XML frère"
				],
				[
					"valeurElémentFrère",
					"Text",
					"<-",
					"Valeur de l'élément XML frère"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML frère"
				]
			],
			"Summary": "La commande **DOM Get next sibling XML element** retourne une référence vers le prochain “frère” de l’élément XML passé en référence."
		},
		"DOM Get parent XML element": {
			"Syntax": "**DOM Get parent XML element** ( *refElément* {; *nomElémentPar* {; *valeurElémentPar*}} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElémentPar",
					"Text",
					"<-",
					"Nom de l’élément XML parent"
				],
				[
					"valeurElémentPar",
					"Text",
					"<-",
					"Valeur de l’élément XML parent"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML parent"
				]
			],
			"Summary": "La commande **DOM Get parent XML element** retourne une référence XML vers le “parent” de l’élément XML passé en référence dans *refElément*."
		},
		"DOM Get previous sibling XML element": {
			"Syntax": "**DOM Get previous sibling XML element** ( *refElément* {; *nomElémentFrère* {; *valeurElémentFrère*}} ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElémentFrère",
					"Text",
					"<-",
					"Nom de l’élément XML frère"
				],
				[
					"valeurElémentFrère",
					"Text",
					"<-",
					"Valeur de l’élément XML frère"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML frère"
				]
			],
			"Summary": "La commande **DOM Get previous sibling XML element** retourne une référence vers le précédent “frère” de l’élément XML passé en référence."
		},
		"DOM Get root XML element": {
			"Syntax": "**DOM Get root XML element** ( *refElément* ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément racine ou \"\" en cas d’erreur"
				]
			],
			"Summary": "La commande **DOM Get root XML element** retourne une référence vers l’élément racine du document auquel appartient l’élément XML passé dans le paramètre *refElément*."
		},
		"DOM GET XML ATTRIBUTE BY INDEX": {
			"Syntax": "**DOM GET XML ATTRIBUTE BY INDEX** ( *refElément* ; *indexAttribut* ; *nomAttribut* ; *valeurAttribut* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"indexAttribut",
					"Integer",
					"->",
					"Numéro d’indice de l’attribut"
				],
				[
					"nomAttribut",
					"Variable",
					"<-",
					"Nom de l’attribut"
				],
				[
					"valeurAttribut",
					"Variable",
					"<-",
					"Valeur de l’attribut"
				]
			],
			"Summary": "La commande **DOM GET XML ATTRIBUTE BY INDEX** permet de connaître le nom ainsi que la valeur d’un attribut désigné par son numéro d’indice."
		},
		"DOM GET XML ATTRIBUTE BY NAME": {
			"Syntax": "**DOM GET XML ATTRIBUTE BY NAME** ( *refElément* ; *nomAttribut* ; *valeurAttribut* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Nom d’attribut"
				],
				[
					"valeurAttribut",
					"Variable",
					"<-",
					"Valeur de l’attribut"
				]
			],
			"Summary": "La commande **DOM GET XML ATTRIBUTE BY NAME** permet de connaître la valeur d’un attribut désigné par son nom."
		},
		"DOM GET XML CHILD NODES": {
			"Syntax": "**DOM GET XML CHILD NODES** ( *refElément* ; *tabTypesEnfants* ; *tabRefsNoeuds* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"tabTypesEnfants",
					"Integer array",
					"<-",
					"Types des noeuds enfants"
				],
				[
					"tabRefsNoeuds",
					"Text array",
					"<-",
					"Références ou Valeurs des noeuds enfants"
				]
			],
			"Summary": "La commande **DOM GET XML CHILD NODES** retourne les types et les références ou valeurs de tous les noeuds enfants de l’élément XML désigné par *refElément*."
		},
		"DOM Get XML document ref": {
			"Syntax": "**DOM Get XML document ref** ( *refElément* ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’un élément existant dans un arbre DOM"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence du premier élément de l'arbre DOM (noeud document)"
				]
			],
			"Summary": "La commande **DOM Get XML document ref** permet de récupérer la référence de l’élément \"document\" de l’arbre DOM dont vous avez passé la référence dans *refElément*."
		},
		"DOM GET XML ELEMENT NAME": {
			"Syntax": "**DOM GET XML ELEMENT NAME** ( *refElément* ; *nomElément* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElément",
					"Variable",
					"<-",
					"Nom de l’élément"
				]
			],
			"Summary": "La commande DOM LIRE NOM ELEMENT XML retourne dans le paramètre *nomElément* le nom de l’élément XML désigné par *refElément*."
		},
		"DOM GET XML ELEMENT VALUE": {
			"Syntax": "**DOM GET XML ELEMENT VALUE** ( *refElément* ; *valeurElément* {; *cDATA*} )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"valeurElément",
					"Variable",
					"<-",
					"Valeur de l’élément"
				],
				[
					"cDATA",
					"Variable",
					"<-",
					"Contenu de la section CDATA"
				]
			],
			"Summary": "La commande **DOM GET XML ELEMENT VALUE** retourne dans le paramètre *valeurElément* la valeur de l’élément XML désigné par *refElément*."
		},
		"DOM Get XML element": {
			"Syntax": "**DOM Get XML element** ( *refElément* ; *nomElément* ; *indice* ; *valeurElément* ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElément",
					"Text",
					"->",
					"Nom de l’élément à lire"
				],
				[
					"indice",
					"Integer",
					"->",
					"Numéro d’indice de l’élément à lire"
				],
				[
					"valeurElément",
					"Variable",
					"<-",
					"Valeur de l’élément"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML (16 caractères)"
				]
			],
			"Summary": "La commande **DOM Get XML element** retourne une référence XML vers l’élément “enfant” dépendant des paramètres *nomElément* et *index*."
		},
		"DOM Get XML information": {
			"Syntax": "**DOM Get XML information** ( *refElément* ; *infoXML* ) : Text",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				],
				[
					"infoXML",
					"Integer",
					"->",
					"Type d’information à lire"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur de l’information XML"
				]
			],
			"Summary": "La commande **DOM Get XML information** permet de récupérer diverses informations sur l’élément XML désigné par *refElément*."
		},
		"DOM Insert XML element": {
			"Syntax": "**DOM Insert XML element** ( *refElémentCible* ; *refElémentSource* ; *indexEnfant* ) : Text",
			"Params": [
				[
					"refElémentCible",
					"Text",
					"->",
					"Référence de l’élément XML parent"
				],
				[
					"refElémentSource",
					"Text",
					"->",
					"Référence de l’élément XML à insérer"
				],
				[
					"indexEnfant",
					"Integer",
					"->",
					"Index de l’enfant de l’élément cible avant lequel le nouvel élément doit être inséré"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence du nouvel élément XML"
				]
			],
			"Summary": "La commande **DOM Insert XML element** permet d’insérer un nouvel élément XML parmi les enfants de l’élément XML dont la référence est passée dans le paramètre *refElémentCible*."
		},
		"DOM Parse XML source": {
			"Syntax": "**DOM Parse XML source** ( *nomFichier* {; *validation* {; dtd | schéma}} ) : Text",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Chemin d’accès du document"
				],
				[
					"validation",
					"Boolean",
					"->",
					"Vrai = Validation, Faux = Pas de validation"
				],
				[
					"dtd &#124; schéma",
					"Chaîne",
					"->",
					"Emplacement de la DTD ou du schéma XML"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML"
				]
			],
			"Summary": "La commande **DOM Parse XML source** analyse un document contenant une structure XML et retourne une référence pour ce document."
		},
		"DOM Parse XML variable": {
			"Syntax": "**DOM Parse XML variable** ( *variable* {; *validation* {; dtd | schéma}} ) : Text",
			"Params": [
				[
					"variable",
					"Blob, Text",
					"->",
					"Nom de la variable"
				],
				[
					"validation",
					"Boolean",
					"->",
					"Vrai = Validation, Faux = Pas de validation"
				],
				[
					"dtd &#124; schéma",
					"Chaîne",
					"->",
					"Emplacement de la DTD ou du schéma XML"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence de l’élément XML"
				]
			],
			"Summary": "La commande **DOM Parse XML variable** analyse une variable de type BLOB ou Texte contenant une structure XML et retourne une référence pour cette variable."
		},
		"DOM REMOVE XML ATTRIBUTE": {
			"Syntax": "**DOM REMOVE XML ATTRIBUTE** ( *refElément* ; *nomAttribut* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Attribut à supprimer"
				]
			],
			"Summary": "La commande **DOM REMOVE XML ATTRIBUTE** supprime, s’il existe, l’attribut désigné par *nomAttribut* de l’élément XML dont la référence est passée dans le paramètre *refElément*."
		},
		"DOM REMOVE XML ELEMENT": {
			"Syntax": "**DOM REMOVE XML ELEMENT** ( *refElément* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				]
			],
			"Summary": "La commande **DOM REMOVE XML ELEMENT** supprime l’élément désigné par *refElément*."
		},
		"DOM SET XML ATTRIBUTE": {
			"Syntax": "**DOM SET XML ATTRIBUTE** ( *refElément* ; *nomAttribut* ; *valeurAttribut* {; *nomAttribut2* ; *valeurAttribut2* ; ... ; *nomAttributN* ; *valeurAttributN*} )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Attribut à définir"
				],
				[
					"valeurAttribut",
					"Text, Boolean, Integer, Real, Time, Date",
					"->",
					"Nouvelle valeur d’attribut"
				]
			],
			"Summary": "La commande **DOM SET XML ATTRIBUTE** permet d’ajouter un ou plusieurs attribut(s) à l’élément XML dont la référence est passée dans le paramètre *refElément*."
		},
		"DOM SET XML DECLARATION": {
			"Syntax": "**DOM SET XML DECLARATION** ( *refElément* ; *encodage* {; *autonome* {; *indentation*}} )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"encodage",
					"Text",
					"->",
					"Jeu de caractères du document XML"
				],
				[
					"autonome",
					"Boolean",
					"->",
					"Vrai=le document est autonome Faux (défaut)=le document n’est pas autonome"
				],
				[
					"indentation",
					"Boolean",
					"->",
					"*** Obsolète, ne plus utiliser ***"
				]
			],
			"Summary": "La commande **DOM SET XML DECLARATION** permet de définir diverses options qui seront utilisée pour la création de l’arbre XML désigné par *refElément*."
		},
		"DOM SET XML ELEMENT NAME": {
			"Syntax": "**DOM SET XML ELEMENT NAME** ( *refElément* ; *nomElément* )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"nomElément",
					"Text",
					"->",
					"Nouveau nom de l’élément"
				]
			],
			"Summary": "La commande **DOM SET XML ELEMENT NAME** permet de modifier le nom de l’élément désigné par *refElément*."
		},
		"DOM SET XML ELEMENT VALUE": {
			"Syntax": "**DOM SET XML ELEMENT VALUE** ( *refElément* {; *xPath*}; *valeurElément* {; *} )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"xPath",
					"Text",
					"->",
					"Chemin XPath de l’élément XML"
				],
				[
					"valeurElément",
					"Text, Variable",
					"->",
					"Nouvelle valeur de l’élément"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : définir la valeur en CDATA"
				]
			],
			"Summary": "La commande **DOM SET XML ELEMENT VALUE** permet de modifier la valeur de l’élément désigné par *refElément*."
		},
		"DRAG WINDOW": {
			"Syntax": "**DRAG WINDOW**",
			"Params": [],
			"Summary": "La commande **DRAG WINDOW** permet de faire glisser la fenêtre dans laquelle l'utilisateur a cliqué puis de la déplacer en fonction des mouvements de la souris."
		},
		"Drop position": {
			"Syntax": "**Drop position** {( numColonne | posYImage )} : Integer",
			"Params": [
				[
					"numColonne &#124; posYImage",
					"Integer",
					"<-",
					"Numéro de colonne de list box (-1 si le déposer a lieu après la dernière colonne) ouPosition coordonnée Y dans l'image"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"• Numéro (tableau/list box) ou• Position (liste hiérarchique) ou• Position dans la chaîne (texte/combo box) de l'élément de destination ou• -1 si le déposer a lieu après le dernier élément de tableau ou de liste ou• Position coordonnée X dans l’image"
				]
			],
			"Summary": "**Drop position** permet de connaître l'emplacement, dans un objet de destination “complexe”, auquel un objet a été (glissé et) déposé."
		},
		"DROP REMOTE USER": {
			"Syntax": "**DROP REMOTE USER** ( *sessionUtilisateur* )",
			"Params": [
				[
					"sessionUtilisateur",
					"Text",
					"->",
					"ID de la session de l'utilisateur"
				]
			],
			"Summary": "La commande **DROP REMOTE USER** permet de déconnecter un utilisateur distant spécifique connecté à 4D Server."
		},
		"DUPLICATE RECORD": {
			"Syntax": "**DUPLICATE RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement à dupliquer ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**DUPLICATE RECORD** duplique l'enregistrement courant de *laTable*."
		},
		"Dynamic pop up menu": {
			"Syntax": "**Dynamic pop up menu** ( *menu* {; *parDéfaut* {; *coordX* ; *coordY*}} )  : Text",
			"Params": [
				[
					"menu",
					"Text",
					"->",
					"Référence de menu"
				],
				[
					"parDéfaut",
					"Text",
					"->",
					"Paramètre de l'élément sélectionné par défaut"
				],
				[
					"coordX",
					"Integer",
					"->",
					"Coordonnée X du coin supérieur gauche"
				],
				[
					"coordY",
					"Integer",
					"->",
					"Coordonnée Y du coin supérieur gauche"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Paramètre de l'élément de menu sélectionné"
				]
			],
			"Summary": "La commande **Dynamic pop up menu** fait apparaître un pop up menu hiérarchique à l’emplacement courant de la souris ou à l’emplacement défini par les paramètres facultatifs *coordX* et *coordY*."
		},
		"EDIT ACCESS": {
			"Syntax": "**EDIT ACCESS**",
			"Params": [],
			"Summary": "**EDIT ACCESS** permet de modifier le système de mots de passe."
		},
		"EDIT FORMULA": {
			"Syntax": "**EDIT FORMULA** ( *laTable* ; *formule* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à afficher par défaut dans l’éditeur de formules"
				],
				[
					"formule",
					"Text",
					"->",
					"Variable contenant la formule à afficher dans l’éditeur de formules ou \"\" pour uniquement afficher l’éditeur"
				],
				[
					"<-",
					"Formule validée par l’utilisateur"
				]
			],
			"Summary": "La commande **EDIT FORMULA** affiche l’éditeur de formules afin de permettre à l’utilisateur d’écrire ou de modifier une formule."
		},
		"EDIT ITEM": {
			"Syntax": "**EDIT ITEM** ( {* ;} *objet* {; élément} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est un table ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * spécifié) ou Table ou variable (si * omis)"
				],
				[
					"élément",
					"Integer",
					"->",
					"Numéro d’élément"
				]
			],
			"Summary": "La commande **EDIT ITEM** permet de passer en “mode édition” l’élément courant ou l’élément de numéro *élément* du tableau ou de la liste désigné(e) par le paramètre *objet*."
		},
		"ENABLE MENU ITEM": {
			"Syntax": "**ENABLE MENU ITEM** ( *menu* ; *ligneMenu* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				]
			],
			"Summary": "**ENABLE MENU ITEM** active la commande de menu dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*."
		},
		"ENCRYPT BLOB": {
			"Syntax": "**ENCRYPT BLOB** ( *aCrypter* ; *cléPrivEmetteur* {; *cléPubRécepteur*} )",
			"Params": [
				[
					"aCrypter",
					"Blob",
					"<->",
					"Données à crypter"
				],
				[
					"",
					"",
					"",
					"Données cryptées"
				],
				[
					"cléPrivEmetteur",
					"Blob",
					"->",
					"Clé privée de l’émetteur"
				],
				[
					"cléPubRécepteur",
					"Blob",
					"->",
					"Clé publique du récepteur"
				]
			],
			"Summary": "La commande **ENCRYPT BLOB** permet de crypter le contenu du BLOB *aCrypter* à l’aide de la clé privée de l’émetteur *cléPrivEmetteur* ainsi que, optionnellement, de la clé publique du récepteur *cléPubRécepteur*."
		},
		"Encrypt data BLOB": {
			"Syntax": "**Encrypt data BLOB** ( *blobToEncrypt* ; *keyObject* ; *salt* ; *encryptedBLOB* ) : Boolean<br/>**Encrypt data BLOB** ( *blobToEncrypt* ; *passPhrase* ; *salt* ; *encryptedBLOB* ) : Boolean",
			"Params": [
				[
					"blobToEncrypt",
					"Blob",
					"->",
					"BLOB à encrypter"
				],
				[
					"keyObject &#124; passPhrase",
					"Objet, Texte",
					"->",
					"Objet JSON contenant la clé de chiffrement ou le mot de passe pour une génération directe de clé de chiffrement (texte)"
				],
				[
					"salt",
					"Integer",
					"->",
					"Additional salt for algorithm"
				],
				[
					"encryptedBlob",
					"Blob",
					"<-",
					"BLOB encrypté"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"True si le chiffrement a été effectué correctement. Sinon False"
				]
			],
			"Summary": "La commande **Encrypt data BLOB**encrypte le paramètre *blobToEncrypt* avec le même algorithme utilisé par 4D pour encrypter les données (AES-256) et retourne le résultat dans encryptedBlob."
		},
		"Encrypt data file": {
			"Syntax": "**Encrypt data file** ( *cheminStructure* ; *cheminDonnées* {; nouvellePhraseSecrète | nouvelleCléDonnées {; *dossierArchive* {; phraseSecrèteCour | cléDonnéesCour {; *nomMéthode*}}}} ) : Text",
			"Params": [
				[
					"cheminStructure",
					"Text",
					"->",
					"Chemin d'accès du fichier de structure"
				],
				[
					"cheminDonnées",
					"Text",
					"->",
					"Chemin d'accès du fichier de données"
				],
				[
					"nouvellePhraseSecrète &#124; nouvelleCléDonnées",
					"Texte, Objet",
					"->",
					"En cas de remplacement : nouvelle phrase secrète (texte) ou nouvelle clé de chiffrement (objet)"
				],
				[
					"dossierArchive",
					"Text",
					"->",
					"Chemin d'accès du dossier dans lequel placer le fichier de données original"
				],
				[
					"phraseSecrèteCour &#124; cléDonnéesCour",
					"Texte, Objet",
					"->",
					"Phrase secrète courante (texte) ou clé de chiffrement courante (objet)"
				],
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de la méthode 4D de rétro-appel"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de chemin d'accès complet au dossier dans lequel les fichiers originaux ont été stockés"
				]
			],
			"Summary": "La commande **Encrypt data file** est utilisée pour chiffrer ou déchiffrer le fichier de données indiqué par le paramètre *cheminDonnées* associé au paramètre *cheminStructure*."
		},
		"End selection": {
			"Syntax": "**End selection** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle tester si le pointeur d'enregistrement courant est au-delà du dernier enregistrement de la sélection courante ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Oui (Vrai), Non (Faux)"
				]
			],
			"Summary": "La fonction **End selection** retourne Vrai lorsque le pointeur de l'enregistrement courant se trouve après le dernier enregistrement de la sélection courante de *laTable*."
		},
		"End SQL": {
			"Syntax": "**End SQL**",
			"Params": [],
			"Summary": "**End SQL** est un mot-clé indiquant dans l'éditeur de méthodes la fin d'une séquence de commandes SQL."
		},
		"Equal pictures": {
			"Syntax": "**Equal pictures** ( *image1* ; *image2* ; *masque* ) : Boolean",
			"Params": [
				[
					"image1",
					"Picture, Picture",
					"->",
					"Image source originale"
				],
				[
					"image2",
					"Picture, Picture",
					"->",
					"Image à comparer"
				],
				[
					"masque",
					"Picture, Picture",
					"<-",
					"Masque résultant"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si les deux images sont identiques, sinon Faux"
				]
			],
			"Summary": "La commande **Equal pictures** vous permet de comparer précisément deux images, tant au niveau de leurs dimensions que de leur contenu."
		},
		"ERASE WINDOW": {
			"Syntax": "**ERASE WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de fenêtre ou Fenêtre au premier plan du process courant si ce paramètre est omis"
				]
			],
			"Summary": "La commande **ERASE WINDOW** efface le contenu de la fenêtre dont vous avez passé la référence dans *fenêtre*."
		},
		"Euro converter": {
			"Syntax": "**Euro converter** ( *valeur* ; *deMonnaie* ; *versMonnaie* ) : Real",
			"Params": [
				[
					"valeur",
					"Real",
					"->",
					"Valeur à convertir"
				],
				[
					"deMonnaie",
					"Text",
					"->",
					"Code ISO de la monnaie dans laquelle la valeur est exprimée"
				],
				[
					"versMonnaie",
					"Text",
					"->",
					"Code ISO de la monnaie dans laquelle la valeur doit être convertie"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Valeur convertie"
				]
			],
			"Summary": "La commande **Euro converter** vous permet d’effectuer tout type de conversion de valeurs entre les différentes monnaies des pays de la “zone euro” et l’Euro lui-même."
		},
		"EXECUTE FORMULA": {
			"Syntax": "**EXECUTE FORMULA** ( *instruction* )",
			"Params": [
				[
					"instruction",
					"Text",
					"->",
					"Code à exécuter"
				]
			],
			"Summary": "**EXECUTE FORMULA** exécute *instruction* comme une ligne de code."
		},
		"EXECUTE METHOD IN SUBFORM": {
			"Syntax": "**EXECUTE METHOD IN SUBFORM** ( *objetSousForm* ; *nomMéthode* {; *retour* {; *param*} {; *param2* ; ... ; *paramN*}} )",
			"Params": [
				[
					"objetSousForm",
					"Text",
					"->",
					"Nom de l’objet sous-formulaire"
				],
				[
					"nomMéthode",
					"Object, Text",
					"->",
					"Nom de la méthode projet à exécuter"
				],
				[
					"retour",
					"*, Variable",
					"->",
					"* si la méthode ne retourne pas de valeur"
				],
				[
					"<-",
					"Valeur retournée par la méthode"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) à passer à la méthode"
				]
			],
			"Summary": "La commande **EXECUTE METHOD IN SUBFORM** permet d’exécuter le code désigné dans *formule* dans le contexte de l’objet de sous-formulaire *objetSousForm*."
		},
		"EXECUTE METHOD": {
			"Syntax": "**EXECUTE METHOD** ( *nomMéthode* {; *résultat* {; *param*}}{; *param2* ; ... ; *paramN*} )",
			"Params": [
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de méthode projet à exécuter"
				],
				[
					"résultat",
					"Variable, *",
					"<-",
					"Variable recevant le résultat de la méthode ou * pour une méthode ne retournant pas de résultat"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) de la méthode"
				]
			],
			"Summary": "La commande **EXECUTE METHOD** provoque l’exécution de la méthode projet *nomMéthode* en lui passant éventuellement les paramètres *param1."
		},
		"EXECUTE ON CLIENT": {
			"Syntax": "**EXECUTE ON CLIENT** ( *nomClient* ; *nomMéthode* {; *param*}{; *param2* ; ... ; *paramN*} )",
			"Params": [
				[
					"nomClient",
					"Text",
					"->",
					"Nom d’inscription du 4D Client"
				],
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de la méthode à exécuter"
				],
				[
					"param",
					"->",
					"Paramètre(s) de la méthode"
				]
			],
			"Summary": "La commande **EXECUTE ON CLIENT** provoque l’exécution de la méthode *nomMéthode*, avec, éventuellement, le(s) paramètre(s) *param1."
		},
		"Execute on server": {
			"Syntax": "**Execute on server** ( *procédure* ; *pile* {; *nom* {; *param* {; *param2* ; ... ; *paramN*}}}{; *} ) : Integer",
			"Params": [
				[
					"procédure",
					"Text",
					"->",
					"Procédure à exécuter dans le process"
				],
				[
					"pile",
					"Integer",
					"->",
					"Taille de la pile en octets (0 = taille par défaut)"
				],
				[
					"nom",
					"Text",
					"->",
					"Nom du process créé"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) de la procédure"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Process unique"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du process pour un process nouvellement créé ou un process déjà en cours d'exécution"
				]
			],
			"Summary": "La commande **Execute on server** lance un nouveau process sur la machine serveur (lorsqu'elle est appelée en environnement client/serveur) et retourne le numéro de ce process."
		},
		"Exp": {
			"Syntax": "**Exp** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre à évaluer"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Exponentielle de nombre"
				]
			],
			"Summary": "**Exp** retourne l'exponentielle (e=2,71828...) de *nombre*."
		},
		"EXPAND BLOB": {
			"Syntax": "**EXPAND BLOB** ( *blob* )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB à décompresser"
				]
			],
			"Summary": "**EXPAND BLOB** décompresse le BLOB *blob* préalablement compressé à l'aide de la commande COMPRESS BLOB."
		},
		"EXPORT DATA": {
			"Syntax": "**EXPORT DATA** ( *nomFichier* {; *projet* {; *}} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Chemin d’accès et nom du fichier d’export"
				],
				[
					"projet",
					"Text, Blob",
					"->",
					"Contenu du projet d’export (XML ou référence d'élément DOM ou BLOB)"
				],
				[
					"<-",
					"Nouveau contenu du projet d’export (si le paramètre * a été passé)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Affichage de la boîte de dialogue d’export et mise à jour du projet"
				]
			],
			"Summary": "La commande **EXPORT DATA** permet d’exporter des données dans le fichier *nomFichier*."
		},
		"EXPORT DIF": {
			"Syntax": "**EXPORT DIF** ( {*laTable* ;} *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle effectuer l'export ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document DIF à exporter"
				]
			],
			"Summary": "La commande **EXPORT DIF** écrit dans *document* (document DIF Windows ou Mac OS) les données des enregistrements de la sélection courante de la table *laTable* du process courant."
		},
		"Export structure file": {
			"Syntax": "**Export structure file** ( *cheminDossier* {; *options*} ) : Object",
			"Params": [
				[
					"cheminDossier",
					"Text",
					"->",
					"Chemin du dossier de destination pour les fichiers projets"
				],
				[
					"options",
					"Object",
					"->",
					"Options d'export"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statuts et messages de validation (le cas échéant)"
				]
			],
			"Summary": "La commande **Export structure file** décompose la structure de la base de données 4D courante en un ensemble de fichiers de type texte ou de fichiers natifs de type image et les stocke dans le *cheminDossier* spécifié."
		},
		"EXPORT STRUCTURE": {
			"Syntax": "**EXPORT STRUCTURE** ( *structureXML* {; *format*} )",
			"Params": [
				[
					"structureXML",
					"Text",
					"<-",
					"Export de la définition XML de la structure de la base 4D"
				],
				[
					"format",
					"Text",
					"->",
					"Export format: xml format (default) or html format"
				]
			],
			"Summary": "La commande **EXPORT STRUCTURE** exporte la définition de la structure de la base 4D courante dans exportedStructure."
		},
		"EXPORT SYLK": {
			"Syntax": "**EXPORT SYLK** ( {*laTable* ;} *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle effectuer l'export ou Table par défaut si ce paramètres est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document SYLK à exporter"
				]
			],
			"Summary": "La commande **EXPORT SYLK** écrit dans *document* (document SYLK Windows ou Mac OS) les données des enregistrements de la sélection courante de la table *laTable* du process courant."
		},
		"EXPORT TEXT": {
			"Syntax": "**EXPORT TEXT** ( {*laTable* ;} *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table depuis laquelle effectuer l'export ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document texte à exporter"
				]
			],
			"Summary": "La commande **EXPORT TEXT** écrit dans *document* (document texte Windows ou Mac OS) les données des enregistrements de la sélection courante de la table *laTable* du process courant."
		},
		"False": {
			"Syntax": "**False**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Faux"
				]
			],
			"Summary": "**False** retourne la valeur booléenne Faux."
		},
		"Field name": {
			"Syntax": "**Field name** ( ptrChamp | numTable {; *numChamp*} ) : Text",
			"Params": [
				[
					"ptrChamp &#124; numTable",
					"Pointeur, Entier long",
					"->",
					"Pointeur vers un champ ou Numéro de table"
				],
				[
					"numChamp",
					"Integer",
					"->",
					"Numéro de champ si un numéro de table est passé en premier paramètre"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom du champ"
				]
			],
			"Summary": "La commande **Field name** retourne le nom du champ dont vous avez passé le pointeur dans *ptrChamp*, ou dont vous avez passé les numéros de table et de champ dans *numTable* et *numChamp*."
		},
		"Field": {
			"Syntax": "**Field** ( *numTable* ; *numChamp* ) -> ptrChamp <br/>\n**Field** ( *ptrChamp* ) -> numChamp",
			"Params": [
				[
					"numTable",
					"Integer",
					"->",
					"Numéro de table"
				],
				[
					"numChamp",
					"Integer",
					"->",
					"Numéro de champ"
				],
				[
					"ptrChamp",
					"Pointer",
					"<-",
					"Pointeur de champ"
				],
				[
					"Field ( ptrChamp ) -> numChamp"
				],
				[
					"Paramètre",
					"Type",
					"Description"
				],
				[
					"ptrChamp",
					"Pointer",
					"->",
					"Pointeur de champ"
				],
				[
					"numChamp",
					"Integer",
					"<-",
					"Numéro de champ"
				]
			],
			"Summary": "La commande **Field** a deux syntaxes :\n\n* Si vous passez un numéro de table dans *numTable* et un numéro de champ dans *numChamp*, **Field** retourne un pointeur vers le champ."
		},
		"FILTER EVENT": {
			"Syntax": "**FILTER EVENT**",
			"Params": [],
			"Summary": "**FILTER EVENT** doit être appelée à l'intérieur d'une méthode de gestion d'événements installée par ON EVENT CALL."
		},
		"FILTER KEYSTROKE": {
			"Syntax": "**FILTER KEYSTROKE** ( *carFiltré* )",
			"Params": [
				[
					"carFiltré",
					"Text",
					"->",
					"Caractère(s) de remplacement ou Chaîne vide pour annuler le filtrage clavier"
				]
			],
			"Summary": "**FILTER KEYSTROKE** vous permet de remplacer le caractère saisi par l'utilisateur dans un champ ou une zone saisissable par le premier caractère de la chaîne *carFiltré*."
		},
		"Find in array": {
			"Syntax": "**Find in array** ( *tableau* ; *valeur* {; *départ*} ) : Integer",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau dans lequel effectuer la recherche"
				],
				[
					"valeur",
					"Expression",
					"->",
					"Valeur de même type à rechercher dans le tableau"
				],
				[
					"départ",
					"Integer",
					"->",
					"Elément à partir duquel commencer la recherche"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du premier élément trouvé correspondant à valeur"
				]
			],
			"Summary": "**Find in array** retourne le numéro du premier élément de *tableau* qui correspond à *valeur*."
		},
		"Find in field": {
			"Syntax": "**Find in field** ( *champCible* ; *valeur* ) : Integer",
			"Params": [
				[
					"champCible",
					"Field",
					"->",
					"Champ sur lequel effectuer la recherche"
				],
				[
					"valeur",
					"Field, Variable",
					"->",
					"Valeur à rechercher"
				],
				[
					"<-",
					"Valeur trouvée"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de l’enregistrement trouvé ou -1 si pas d’enregistrement trouvé"
				]
			],
			"Summary": "La commande **Find in field** retourne le numéro du premier enregistrement dont le champ *champCible* est égal à la valeur *valeur*."
		},
		"Find in list": {
			"Syntax": "**Find in list** ( {* ;} *liste* ; *valeur* ; *portée* {; *tabEléments* {; *}} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"valeur",
					"Text",
					"->",
					"Valeur à rechercher"
				],
				[
					"portée",
					"Integer",
					"->",
					"0=Liste principale, 1=Sous-listes"
				],
				[
					"tabEléments",
					"Integer array",
					"<-",
					"- Si 2e * omis : tableau des positions des éléments trouvés - Si 2e * passé : tableau des numéros de référence des éléments trouvés"
				],
				[
					"*",
					"Opérateur",
					"->",
					"- Si omis : utiliser la position des éléments - Si passé : utiliser le numéro de référence des éléments"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"- Si 2e * omis : position de l’élément trouvé - Si 2e * passé : numéro de référence de l’élément trouvé"
				]
			],
			"Summary": "La commande **Find in list** retourne la position ou la référence du premier élément de *liste* qui équivaut à la chaîne passée dans *valeur*."
		},
		"Find in sorted array": {
			"Syntax": "**Find in sorted array** ( *tableau* ; *valeur* ; > ou < {; *posDébut* {; *posFin*}} ) : Boolean",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau dans lequel effectuer la recherche"
				],
				[
					"valeur",
					"Expression",
					"->",
					"Valeur (de même type que le tableau) à rechercher dans le tableau"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"> si le tableau est trié par ordre croissant, < s'il est trié par ordre décroissant"
				],
				[
					"posDébut",
					"Integer",
					"<-",
					"Si la valeur est trouvée, position de sa première occurrence ; sinon, position où la valeur devrait être insérée"
				],
				[
					"posFin",
					"Integer",
					"<-",
					"Si la valeur est trouvée, position de sa dernière occurrence ; sinon, identique à posDébut"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si au moins un élément du tableau correspond à la valeur recherchée, sinon Faux"
				]
			],
			"Summary": "La commande **Find in sorted array** retourne **vrai** si au moins un élément du *tableau* trié correspond à *valeur*, et optionnellement retourne la position du ou des élément(s) trouvé(s)."
		},
		"Find window": {
			"Syntax": "**Find window** ( *gauche* ; *haut* {; *partieFenêtre*} ) : Integer",
			"Params": [
				[
					"gauche",
					"Integer",
					"->",
					"Coordonnée globale gauche"
				],
				[
					"haut",
					"Integer",
					"->",
					"Coordonnée globale supérieure"
				],
				[
					"partieFenêtre",
					"Integer",
					"<-",
					"3 si une fenêtre est \"touchée\", 0 sinon"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de fenêtre"
				]
			],
			"Summary": "La commande **Find window** retourne (s'il existe) le numéro de référence de la première fenêtre \"touchée\" par le point dont vous passez les coordonnées dans *gauche* et *haut*."
		},
		"FIRST RECORD": {
			"Syntax": "**FIRST RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle charger le premier enregistrement de la sélection courantes ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**FIRST RECORD** charge en mémoire le premier enregistrement de la sélection courante de *laTable* et en fait l'enregistrement courant."
		},
		"FLUSH CACHE": {
			"Syntax": "**FLUSH CACHE** {( taille | * )}",
			"Params": [
				[
					"taille &#124; *",
					"Réel, Opérateur",
					"->",
					"* pour vider le cache, ou nombre d'octets minimum de libération du cache"
				]
			],
			"Summary": "La commande **FLUSH CACHE** sauvegarde immédiatement le cache de données sur le disque."
		},
		"Focus object": {
			"Syntax": "**Focus object**  : Pointer",
			"Params": [
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers l’objet ayant le focus"
				]
			],
			"Summary": "Cette commande est conservée pour des raisons de compatibilité uniquement."
		},
		"FOLDER LIST": {
			"Syntax": "**FOLDER LIST** ( *cheminAccès* ; *dossiers* )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Chemin d'accès de volume, répertoire ou dossier"
				],
				[
					"dossiers",
					"Text array",
					"<-",
					"Noms des dossiers situés à cet endroit"
				]
			],
			"Summary": "La commande **FOLDER LIST** remplit le tableau de type Texte ou Alpha *dossiers* avec les noms des dossiers (répertoires sous Windows) situés à l'endroit que vous avez indiqué avec le paramètre *cheminAccès*."
		},
		"Font file": {
			"Syntax": "**Font file** ( *famillePolice* {; *stylePolice*} ) : any",
			"Params": [
				[
					"famillePolice",
					"Text",
					"->",
					"Nom de la famille de police"
				],
				[
					"stylePolice",
					"Integer",
					"->",
					"Style de police : 0=normale (par défaut), 1=gras, 2=italique"
				],
				[
					"Résultat",
					"Null, Object",
					"<-",
					"Objet fichier police"
				]
			],
			"Summary": "La commande **Font file** retourne un objet décrivant le fichier de polices de votre système d'exploitation correspondant à *famillePolice* et, éventuellement, à *stylePolice* que vous avez passé dans le paramètre."
		},
		"FONT LIST": {
			"Syntax": "**FONT LIST** ( *polices* {; *typeListe* } )<br/>**FONT LIST** ( *polices* {; *} )",
			"Params": [
				[
					"polices",
					"Text array",
					"<-",
					"Tableau des noms des polices vectorielles disponibles"
				],
				[
					"typeListe &#124; *",
					"Entier long, Opérateur",
					"->",
					"Type de liste de police à retourner ou * pour retourner des noms de police sous macOS"
				]
			],
			"Summary": "La commande   **FONT LIST** remplit le tableau Texte *polices* avec les noms des polices vectorielles disponibles dans votre système."
		},
		"FONT STYLE LIST": {
			"Syntax": "**FONT STYLE LIST** ( *famillePolice* ; *listeStylesPolice* ; *listeNomsPolice* )",
			"Params": [
				[
					"famillePolice",
					"Text",
					"->",
					"Nom de la famille de police"
				],
				[
					"listeStylesPolice",
					"Text array",
					"<-",
					"Liste des styles pris en charge par la famille de police"
				],
				[
					"listeNomsPolice",
					"Text array",
					"<-",
					"Liste des noms complets pris en charge par la famille de police"
				]
			],
			"Summary": "La commande **FONT STYLE LIST** retourne la liste des styles et la liste des noms complets pris en charge par la famille de police désignée par le paramètre *famillePolice*."
		},
		"FORM Convert to dynamic": {
			"Syntax": "**FORM Convert to dynamic** ( {*uneTable* ;} *nomFormulaire* ) : Object",
			"Params": [
				[
					"uneTable",
					"Table",
					"->",
					"Table du formulaire"
				],
				[
					"nomFormulaire",
					"Text",
					"->",
					"Nom d'un formulaire projet ou d'un formulaire table \"classique\""
				],
				[
					"Résultat",
					"Object",
					"<-",
					"formName converti en formulaire dynamique"
				]
			],
			"Summary": "La commande **FORM Convert to dynamic** convertit le formulaire classique *nomFormulaire* en formulaire dynamique et le retourne sous forme d'objet."
		},
		"FORM FIRST PAGE": {
			"Syntax": "**FORM FIRST PAGE**",
			"Params": [],
			"Summary": "La commande **FORM FIRST PAGE** change la page courante d'un formulaire pour afficher la première page du formulaire."
		},
		"FORM Get color scheme": {
			"Syntax": "**FORM Get color scheme**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Schéma de couleur du formulaire courant : \"light\" ou \"dark\""
				]
			],
			"Summary": "La commande **FORM Get color scheme** retourne le nom du schéma de couleurs du formulaire actuellement affiché ."
		},
		"FORM Get current page": {
			"Syntax": "**FORM Get current page** {( * )} : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Retourner le numéro de la page du sous-formulaire courant"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de la page courante du formulaire courant"
				]
			],
			"Summary": "**FORM Get current page** retourne le numéro de la page courante du formulaire actuellement affiché ou du formulaire courant chargé via la commande FORM LOAD."
		},
		"FORM GET ENTRY ORDER": {
			"Syntax": "**FORM GET ENTRY ORDER** ( *nomsObjets* {; numPage | *} )",
			"Params": [
				[
					"nomsObjets",
					"Text array",
					"<-",
					"Noms des objets triés par ordre de saisie"
				],
				[
					"numPage &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de la page dont vous voulez lire l'ordre de saisie défini (page courante si omis), ou * pour obtenir l'ordre de saisie actuel de la page courante"
				]
			],
			"Summary": "La commande **FORM GET ENTRY ORDER** retourne dans *nomsObjets* les noms des objets dans l'ordre de saisie du formulaire courant."
		},
		"FORM GET HORIZONTAL RESIZING": {
			"Syntax": "**FORM GET HORIZONTAL RESIZING** ( *redimension* {; *largeurMini* {; *largeurMaxi*}} )",
			"Params": [
				[
					"redimension",
					"Boolean",
					"<-",
					"Vrai : le formulaire est redimensionnable horizontalement, Faux : le formulaire n'est pas redimensionnable horizontalement"
				],
				[
					"largeurMini",
					"Integer",
					"<-",
					"Largeur minimale du formulaire (pixels)"
				],
				[
					"largeurMaxi",
					"Integer",
					"<-",
					"Largeur maximale du formulaire (pixels)"
				]
			],
			"Summary": "La commande **FORM GET HORIZONTAL RESIZING** retourne dans les variables *redimension*, *largeurMini* et *largeurMaxi* les propriétés de redimensionnement horizontal du formulaire courant."
		},
		"FORM GET NAMES": {
			"Syntax": "**FORM GET NAMES** ( {*laTable* ;} *tabNoms* {; *filtre* {; *marqueur*}}{; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Référence de table"
				],
				[
					"tabNoms",
					"Text array",
					"<-",
					"Tableau des noms de formulaires"
				],
				[
					"filtre",
					"Text",
					"->",
					"Filtrage des noms"
				],
				[
					"marqueur",
					"Real",
					"->",
					"Marqueur de version minimale à retourner"
				],
				[
					"<-",
					"Nouvelle valeur"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **FORM GET NAMES** remplit le tableau *tabNoms* avec les noms des formulaires de l’application."
		},
		"FORM GET OBJECTS": {
			"Syntax": "**FORM GET OBJECTS** ( *tabObjets* {; *tabVariables* {; *tabPages*}} {; optionPage | *} )",
			"Params": [
				[
					"tabObjets",
					"Text array",
					"<-",
					"Noms des objets du formulaire"
				],
				[
					"tabVariables",
					"Pointer array",
					"<-",
					"Pointeurs sur les variables ou champs associés aux objets"
				],
				[
					"tabPages",
					"Array integer",
					"<-",
					"Numéro de page de chaque objet"
				],
				[
					"optionPage &#124; *",
					"Entier long, Opérateur",
					"->",
					"1=Page courante du formulaire, 2=Toutes les pages, 4=Pages héritées<br/>Si * passé (obsolète) = page courante avec objets hérités"
				]
			],
			"Summary": "La commande **FORM GET OBJECTS** retourne sous forme de tableau(x) la liste de tous les objets présents dans le formulaire courant."
		},
		"FORM GET PROPERTIES": {
			"Syntax": "**FORM GET PROPERTIES** ( {*laTable* ;} *nomForm* ; *largeur* ; *hauteur* {; *nbPages* {; *largeurFixe* {; *hauteurFixe* {; *titre*}}}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table du formulaire ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomForm",
					"Text",
					"->",
					"Nom du formulaire"
				],
				[
					"largeur",
					"Integer",
					"<-",
					"Largeur du formulaire (en pixels)"
				],
				[
					"hauteur",
					"Integer",
					"<-",
					"Hauteur du formulaire (en pixels)"
				],
				[
					"nbPages",
					"Integer",
					"<-",
					"Nombre de pages du formulaire"
				],
				[
					"largeurFixe",
					"Boolean",
					"<-",
					"Vrai = Largeur fixe, Faux = Largeur variable"
				],
				[
					"hauteurFixe",
					"Boolean",
					"<-",
					"Vrai = Hauteur fixe, Faux = Hauteur variable"
				],
				[
					"titre",
					"Text",
					"<-",
					"Nom de la fenêtre du formulaire"
				]
			],
			"Summary": "La commande **FORM GET PROPERTIES** retourne des propriétés du formulaire *nomForm*."
		},
		"FORM GET VERTICAL RESIZING": {
			"Syntax": "**FORM GET VERTICAL RESIZING** ( *redimension* {; *hauteurMini* {; *hauteurMaxi*}} )",
			"Params": [
				[
					"redimension",
					"Boolean",
					"<-",
					"Vrai : le formulaire est redimensionnable verticalement, Faux : le formulaire n'est pas redimensionnable verticalement"
				],
				[
					"hauteurMini",
					"Integer",
					"<-",
					"Hauteur minimale du formulaire (pixels)"
				],
				[
					"hauteurMaxi",
					"Integer",
					"<-",
					"Hauteur maximale du formulaire (pixels)"
				]
			],
			"Summary": "La commande **FORM GET VERTICAL RESIZING** retourne dans les variables *redimension*, *hauteurMini* et *hauteurMaxi* les propriétés de redimensionnement vertical du formulaire courant."
		},
		"FORM GOTO PAGE": {
			"Syntax": "**FORM GOTO PAGE** ( *numéroPage* {; *} )",
			"Params": [
				[
					"numéroPage",
					"Integer",
					"->",
					"Numéro de la page à afficher"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Changer la page du sous-formulaire courant"
				]
			],
			"Summary": "**FORM GOTO PAGE** change la page courante du formulaire pour afficher la page désignée par *numéroPage*."
		},
		"FORM LAST PAGE": {
			"Syntax": "**FORM LAST PAGE**",
			"Params": [],
			"Summary": "La commande **FORM LAST PAGE** change la page courante d'un formulaire pour afficher la dernière page du formulaire."
		},
		"FORM NEXT PAGE": {
			"Syntax": "**FORM NEXT PAGE**",
			"Params": [],
			"Summary": "**FORM NEXT PAGE** change la page courante d'un formulaire pour afficher la page suivante."
		},
		"FORM PREVIOUS PAGE": {
			"Syntax": "**FORM PREVIOUS PAGE**",
			"Params": [],
			"Summary": "**FORM PREVIOUS PAGE** change la page courante d'un formulaire pour afficher la page précédente."
		},
		"FORM SCREENSHOT": {
			"Syntax": "**FORM SCREENSHOT** ( {{*laTable* ;} *nomFormulaire* ;} *imageForm* {; *pageNum*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table du formulaire"
				],
				[
					"nomFormulaire",
					"Text",
					"->",
					"Nom du formulaire"
				],
				[
					"imageForm",
					"Picture",
					"<-",
					"Image du formulaire en exécution si premier(s) paramètre(s) omis, ou <br/>Image du formulaire dans l'éditeur de formulaires si un nom de formulaire est passé"
				],
				[
					"pageNum",
					"Integer",
					"->",
					"Numéro de page du formulaire"
				]
			],
			"Summary": "La commande **FORM SCREENSHOT** retourne un formulaire sous forme d'image."
		},
		"FORM SET ENTRY ORDER": {
			"Syntax": "**FORM SET ENTRY ORDER** ( *nomsObjets* {; *numPage*} )",
			"Params": [
				[
					"nomsObjets",
					"Text array",
					"->",
					"Tableau des noms d'objets dans l'ordre de saisie souhaité"
				],
				[
					"numPage",
					"Integer",
					"->",
					"Numéro de la page dont vous voulez fixer l'ordre de saisie (page courante si omis)"
				]
			],
			"Summary": "La commande **FORM SET ENTRY ORDER** permet de fixer dynamiquement l'ordre de saisie du formulaire courant pour le process en cours, basé sur le tableau *nomsObjets*."
		},
		"FORM SET HORIZONTAL RESIZING": {
			"Syntax": "**FORM SET HORIZONTAL RESIZING** ( *redimension* {; *largeurMini* {; *largeurMaxi*}} )",
			"Params": [
				[
					"redimension",
					"Boolean",
					"->",
					"Vrai : le formulaire est redimensionnable horizontalement Faux : le formulaire n’est pas redimensionnable horizontalement"
				],
				[
					"largeurMini",
					"Integer",
					"->",
					"Largeur minimale du formulaire (pixels)"
				],
				[
					"largeurMaxi",
					"Integer",
					"->",
					"Largeur maximale du formulaire (pixels)"
				]
			],
			"Summary": "La commande **FORM SET HORIZONTAL RESIZING** permet de modifier par programmation les propriétés de redimensionnement horizontal du formulaire courant."
		},
		"FORM SET INPUT": {
			"Syntax": "**FORM SET INPUT** ( {*laTable* ;} *formulaire* {; *formUtilisateur* {; *}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle définir le formulaire entrée ou Table par défaut si ce paramètre est omis"
				],
				[
					"formulaire",
					"Text, Object",
					"->",
					"Nom du formulaire table (chaîne), ouChemin POSIX (chaîne) d'un fichier .json décrivant le formulaire, ouObjet décrivant le formulaire"
				],
				[
					"formUtilisateur",
					"Text",
					"->",
					"Nom du formulaire utilisateur à utiliser"
				],
				[
					"*",
					"Operator",
					"->",
					"Taille de fenêtre automatique"
				]
			],
			"Summary": "**FORM SET INPUT** désigne *formulaire* ou *formUtilisateur* comme formulaire entrée courant de *laTable* pour le process courant."
		},
		"FORM SET OUTPUT": {
			"Syntax": "**FORM SET OUTPUT** ( {*laTable* ;} *formulaire* {; *formUtilisateur*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle définir le formulaire sortie ou Table par défaut si ce paramètre est omis"
				],
				[
					"formulaire",
					"Text, Object",
					"->",
					"Nom du formulaire table (chaîne), ouChemin POSIX (chaîne) d'un fichier .json décrivant le formulaire, ouObjet décrivant le formulaire"
				],
				[
					"formUtilisateur",
					"Text",
					"->",
					"Nom du formulaire utilisateur à utiliser"
				]
			],
			"Summary": "**FORM SET OUTPUT** vous permet de définir *formulaire* ou *formUtilisateur* comme formulaire sortie courant de *laTable* pour le process courant."
		},
		"FORM SET SIZE": {
			"Syntax": "**FORM SET SIZE** ( {*objet* ;} *horizontal* ; *vertical* {; *} )",
			"Params": [
				[
					"objet",
					"Text",
					"->",
					"Nom d’objet indiquant les limites du formulaire"
				],
				[
					"horizontal",
					"Integer",
					"->",
					"Si * passé : marge horizontale (pixels)Si * omis : largeur (pixels)"
				],
				[
					"vertical",
					"Integer",
					"->",
					"Si * passé : marge verticale (pixels)Si * omis : hauteur (pixels)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"• Si passé, utiliser horizontal et vertical comme marges du formulaire• Si omis, utiliser horizontal et vertical comme largeur et hauteur du formulaireCe paramètre ne peut pas être passé si objet est passé"
				]
			],
			"Summary": "La commande **FORM SET SIZE** permet de modifier par programmation la taille du formulaire courant."
		},
		"FORM SET VERTICAL RESIZING": {
			"Syntax": "**FORM SET VERTICAL RESIZING** ( *redimension* {; *hauteurMini* {; *hauteurMaxi*}} )",
			"Params": [
				[
					"redimension",
					"Boolean",
					"->",
					"Vrai : le formulaire est redimensionnable verticalement Faux : le formulaire n’est pas redimensionnable verticalement"
				],
				[
					"hauteurMini",
					"Integer",
					"->",
					"Hauteur minimale du formulaire (pixels)"
				],
				[
					"hauteurMaxi",
					"Integer",
					"->",
					"Hauteur maximale du formulaire (pixels)"
				]
			],
			"Summary": "La commande **FORM SET VERTICAL RESIZING** permet de modifier par programmation les propriétés de redimensionnement vertical du formulaire courant."
		},
		"FORM UNLOAD": {
			"Syntax": "**FORM UNLOAD**",
			"Params": [],
			"Summary": "La commande **FORM UNLOAD** permet de décharger de la mémoire le formulaire courant désigné via la commande FORM LOAD."
		},
		"Frontmost process": {
			"Syntax": "**Frontmost process** {( * )} : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Numéro du process de la première fenêtre non-flottante"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du process dont la ou les fenêtre(s) est (sont) au premier plan"
				]
			],
			"Summary": "**Frontmost process** retourne le numéro du process dont la ou les fenêtre(s) est (sont) au premier plan."
		},
		"Frontmost window": {
			"Syntax": "**Frontmost window** {( * )} : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si omis = ignorer les fenêtres flottantes, Si spécifié = prendre en compte les fenêtres flottantes"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de fenêtre"
				]
			],
			"Summary": "La commande **Frontmost window** retourne le numéro de référence de la fenêtre actuellement située au premier plan."
		},
		"GENERATE CERTIFICATE REQUEST": {
			"Syntax": "**GENERATE CERTIFICATE REQUEST** ( *cléPrivée* ; *demCertif* ; *tabCodes* ; *tabLibellés* )",
			"Params": [
				[
					"cléPrivée",
					"Blob",
					"->",
					"BLOB contenant la clé privée"
				],
				[
					"demCertif",
					"Blob",
					"<-",
					"BLOB devant recevoir la demande de certificat"
				],
				[
					"tabCodes",
					"Integer array",
					"->",
					"Liste des codes d’informations"
				],
				[
					"tabLibellés",
					"Text array",
					"->",
					"Liste des libellés d’informations"
				]
			],
			"Summary": "La commande **GENERATE CERTIFICATE REQUEST** permet de générer une demande de certificat au format PKCS, directement exploitable par des autorités de certification telles que Verisign® ou Thawthe®."
		},
		"Generate digest": {
			"Syntax": "**Generate digest** ( *param* ; *algorithme* {; *} ) : Text",
			"Params": [
				[
					"param",
					"Blob, Text",
					"->",
					"Blob ou texte pour lequel obtenir une clé digest"
				],
				[
					"algorithme",
					"Integer",
					"->",
					"Algorithme utilisé pour retourner la clé : 0 = Digest MD5, 1 = Digest SHA1, 2 = Digest 4D, 3 = Digest SHA-256, 4 = Digest SHA-512"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Crypter digest en Base64URL"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur de la clé digest"
				]
			],
			"Summary": "La commande **Generate digest** retourne la clé digest d’un BLOB ou d’un texte après application d’un algorithme de cryptage."
		},
		"GENERATE ENCRYPTION KEYPAIR": {
			"Syntax": "**GENERATE ENCRYPTION KEYPAIR** ( *cléPrivée* ; *cléPublique* {; *longueur*} )",
			"Params": [
				[
					"cléPrivée",
					"Blob",
					"<-",
					"BLOB devant recevoir la clé privée"
				],
				[
					"cléPublique",
					"Blob",
					"<-",
					"BLOB devant recevoir la clé publique"
				],
				[
					"longueur",
					"Integer",
					"->",
					"Longueur des clés en bits [512...2048] Par défaut = 512"
				]
			],
			"Summary": "La commande **GENERATE ENCRYPTION KEYPAIR** génère une nouvelle paire de clés RSA."
		},
		"Generate password hash": {
			"Syntax": "**Generate password hash** ( *motDePasse* {; *options*} ) : Text",
			"Params": [
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe utilisateur (seuls les 72 premiers caractères sont utilisés)"
				],
				[
					"options",
					"Object",
					"->",
					"Objet contenant des options"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Hash du mot de passe"
				]
			],
			"Summary": "La commande **Generate password hash** retourne un *hash* de *motDePasse*, généré par un algorithme de hachage cryptographique."
		},
		"Generate UUID": {
			"Syntax": "**Generate UUID** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nouvel UUID sous forme de texte non-canonique (32 caractères)"
				]
			],
			"Summary": "La commande **Generate UUID** retourne un nouvel identifiant UUID de 32 caractères sous forme non-canonique."
		},
		"Get 4D file": {
			"Syntax": "**Get 4D file** ( *fichier* {; *} ) : Text",
			"Params": [
				[
					"fichier",
					"Integer",
					"->",
					"Type de fichier"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Retourne le chemin d'accès du fichier de la base hôte"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d'accès du fichier 4D désigné"
				]
			],
			"Summary": "La commande **Get 4D file** retourne le chemin d'accès au fichier de l'environnement 4D spécifié par le paramètre *fichier*."
		},
		"Get 4D folder": {
			"Syntax": "**Get 4D folder** {( *dossier* {; *options*} {; *})} : Text",
			"Params": [
				[
					"dossier",
					"Integer",
					"->",
					"Type de dossier (si omis=dossier 4D actif)"
				],
				[
					"options",
					"Object",
					"->",
					"Configuration du chemin du dossier base 4D Client"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Retourne le dossier de la base hôte"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d'accès du dossier désigné"
				]
			],
			"Summary": "La commande **Get 4D folder** renvoie le chemin d'accès du dossier 4D actif de l'application courante, ou du dossier de l'environnement 4D spécifié par les paramètres *dossier* et *options*, s'ils sont passés."
		},
		"Get adjusted blobs cache priority": {
			"Syntax": "**Get adjusted blobs cache priority** ( *laTable* ) : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle connaître la valeur de priorité des \"blobs\""
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de priorité courante pour les champs \"blobs\""
				]
			],
			"Summary": "La commande **Get adjusted blobs cache priority** retourrne la valeur ajustée de priorité de cache appliquée par le gestionnaire de cache aux données de type \"blobs\" de *laTable*."
		},
		"Get adjusted index cache priority": {
			"Syntax": "**Get adjusted index cache priority** ( *leChamp* ) : Integer",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ pour lequel connaître la valeur de priorité des index"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de priorité courante des index du champ"
				]
			],
			"Summary": "La commande **Get adjusted index cache priority** retourrne la valeur ajustée de priorité de cache appliquée par le gestionnaire de cache à l'index ou aux index du champ *leChamp*."
		},
		"Get adjusted table cache priority": {
			"Syntax": "**Get adjusted table cache priority** ( *laTable* ) : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle connaître la valeur de priorité des données scalaires"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de priorité courante pour les champs scalaires"
				]
			],
			"Summary": "La commande **Get adjusted table cache priority** retourrne la valeur ajustée de priorité de cache appliquée par le gestionnaire de cache aux données scalaires de laTable."
		},
		"GET ALLOWED METHODS": {
			"Syntax": "**GET ALLOWED METHODS** ( *tabMéthodes* )",
			"Params": [
				[
					"tabMéthodes",
					"Text array",
					"<-",
					"Tableau de noms de méthodes"
				]
			],
			"Summary": "La commande **GET ALLOWED METHODS** retourne dans le tableau *tabMéthodes* le nom des méthodes “autorisées” dans l’éditeur de formules, c’est-à-dire pouvant être utilisées lors de l’écriture d’une formule — ces méthodes sont listées à la fin de la liste des commandes dans l’éditeur."
		},
		"Get Application color scheme": {
			"Syntax": "**Get Application color scheme** {( * )} : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Retourne le schéma couleur de la base hôte"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Schéma de couleur de l'application courante"
				]
			],
			"Summary": "La commande **Get Application color scheme** retourne le nom du schéma de couleur utilisé dans l'application."
		},
		"Get assert enabled": {
			"Syntax": "**Get assert enabled** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = les assertions sont activées, Faux = les assertions sont inactivées"
				]
			],
			"Summary": "La commande **Get assert enabled** retourne Vrai ou Faux suivant que les assertions sont actives ou non dans le process courant."
		},
		"GET AUTOMATIC RELATIONS": {
			"Syntax": "**GET AUTOMATIC RELATIONS** ( *aller* ; *retour* )",
			"Params": [
				[
					"aller",
					"Boolean",
					"<-",
					"Statut de tous les liens de N vers 1"
				],
				[
					"retour",
					"Boolean",
					"<-",
					"Statut de tous les liens de 1 vers N"
				]
			],
			"Summary": "La commande **GET AUTOMATIC RELATIONS** permet de savoir si le statut automatique/manuel de tous les liens manuels N vers 1 et 1 vers N de la base a été modifié dans le process courant."
		},
		"Get cache size": {
			"Syntax": "**Get cache size**  : Real",
			"Params": [
				[
					"Résultat",
					"Real",
					"<-",
					"Taille, en octets, du cache de la base de données"
				]
			],
			"Summary": "La commande **Get cache size** retourne, en octets, la taille courante du cache de la base de données."
		},
		"Get current printer": {
			"Syntax": "**Get current printer**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de l’imprimante courante"
				]
			],
			"Summary": "La commande **Get current printer** retourne le nom de l’imprimante courante définie dans l’application 4D."
		},
		"Get database localization": {
			"Syntax": "**Get database localization** {( {*typeLangue*}{;}{*} )} : Text",
			"Params": [
				[
					"typeLangue",
					"Integer",
					"->",
					"Type de langue"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Return information about host database"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Code de la langue utilisée"
				]
			],
			"Summary": "La commande **Get database localization** retourne la langue par défaut de la base ou la langue désignée par *typeLangue*, exprimée dans la norme définie par la RFC 3066\\."
		},
		"Get database parameter": {
			"Syntax": "**Get database parameter** ( {*laTable* ;} *sélecteur* {; *valeurAlpha*} ) : Real",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table du paramètre ou Table par défaut si ce paramètre est omis"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Code du paramètre de la base"
				],
				[
					"valeurAlpha",
					"Text",
					"<-",
					"Valeur alpha du paramètre"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Valeur du paramètre"
				]
			],
			"Summary": "La commande **Get database parameter** permet de lire la valeur courante d'un paramètre de la base 4D."
		},
		"Get default user": {
			"Syntax": "**Get default user**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence unique de l’utilisateur"
				]
			],
			"Summary": "La commande **Get default user** retourne le numéro de référence unique de l’utilisateur désigné comme “Utilisateur par défaut” dans la boîte de dialogue des Propriétés de la base"
		},
		"GET DOCUMENT ICON": {
			"Syntax": "**GET DOCUMENT ICON** ( *cheminDoc* ; *icône* {; *taille*} )",
			"Params": [
				[
					"cheminDoc",
					"Text",
					"->",
					"Nom ou chemin d’accès du fichier duquel obtenir l’icône ou chaîne vide pour afficher la boîte de dialogue d’ouverture de fichiers"
				],
				[
					"icône",
					"Picture, Picture",
					"<-",
					"Icône du document"
				],
				[
					"taille",
					"Integer",
					"->",
					"Taille de l’icône (en pixels)"
				]
			],
			"Summary": "La commande **GET DOCUMENT ICON** retourne dans le champ ou la variable image 4D *icône*, l’icône du document dont vous avez passé le nom ou le chemin d’accès complet dans *cheminDoc*."
		},
		"Get document position": {
			"Syntax": "**Get document position** ( *docRef* ) : Real",
			"Params": [
				[
					"docRef",
					"Time",
					"->",
					"Numéro de référence de document"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Position dans le fichier (exprimée en octets) à partir du début du fichier"
				]
			],
			"Summary": "Cette commande ne fonctionne qu'avec un document déjà ouvert, dont vous avez passé le numéro de référence dans le paramètre *docRef*."
		},
		"GET DOCUMENT PROPERTIES": {
			"Syntax": "**GET DOCUMENT PROPERTIES** ( *nomFichier* ; *verrouillé* ; *invisible* ; créé le ; créé à  ; modifié le ; modifié à )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du document"
				],
				[
					"verrouillé",
					"Boolean",
					"<-",
					"Verrouillé (Vrai) ou non verrouillé (Faux)"
				],
				[
					"invisible",
					"Boolean",
					"<-",
					"Invisible (Vrai) ou visible (Faux)"
				],
				[
					"créé le",
					"Date",
					"<-",
					"Date de création"
				],
				[
					"créé à",
					"Heure",
					"<-",
					"Heure de création"
				],
				[
					"modifié le",
					"Date",
					"<-",
					"Date de la dernière modification"
				],
				[
					"modifié à",
					"Heure",
					"<-",
					"Heure de la dernière modification"
				]
			],
			"Summary": "La commande **GET DOCUMENT PROPERTIES** retourne des informations sur le document dont le nom ou le chemin d'accès est passé dans le paramètre *document*."
		},
		"Get document size": {
			"Syntax": "**Get document size** ( *document* {; *} ) : Real",
			"Params": [
				[
					"document",
					"Text, Time",
					"->",
					"Numéro de référence de document ou Nom de document"
				],
				[
					"*",
					"Opérateur",
					"->",
					"(Mac OS uniquement) Si omis : taille de la data fork, si passé : taille de la resource fork"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Taille (en octets) de document"
				]
			],
			"Summary": "La commande **Get document size** retourne la taille, exprimée en octets, d'un document."
		},
		"Get edited text": {
			"Syntax": "**Get edited text**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Texte en cours de saisie"
				]
			],
			"Summary": "La commande **Get edited text** retourne le texte en cours de saisie dans un objet de formulaire."
		},
		"Get external data path": {
			"Syntax": "**Get external data path** ( *leChamp* ) : Text",
			"Params": [
				[
					"leChamp",
					"Text, Blob, Picture",
					"->",
					"Champ dont vous souhaitez obtenir le lieu de stockage"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès complet du fichier de stockage externe"
				]
			],
			"Summary": "La commande **Get external data path** retourne le chemin d’accès complet du fichier de stockage externe des données du champ passé dans le paramètre *leChamp*, pour l’enregistrement courant."
		},
		"GET FIELD ENTRY PROPERTIES": {
			"Syntax": "**GET FIELD ENTRY PROPERTIES** ( ptrChp | numTable {; *numChamp*}; énumération ; *obligatoire* ; *nonSaisissable* ; *nonModifiable* )",
			"Params": [
				[
					"ptrChp &#124; numTable",
					"Pointeur, Entier long",
					"->",
					"Pointeur de champ ou Numéro de table"
				],
				[
					"numChamp",
					"Integer",
					"->",
					"Numéro de champ si un numéro de table est passé en premier paramètre"
				],
				[
					"énumération",
					"Text",
					"<-",
					"Nom de l’énumération associée ou Chaîne vide"
				],
				[
					"obligatoire",
					"Boolean",
					"<-",
					"Vrai = Obligatoire, Faux = Facultatif"
				],
				[
					"nonSaisissable",
					"Boolean",
					"<-",
					"Vrai = Non saisissable, Faux = Saisissable"
				],
				[
					"nonModifiable",
					"Boolean",
					"<-",
					"Vrai = Non modifiable, Faux = Modifiable"
				]
			],
			"Summary": "La commande **GET FIELD ENTRY PROPERTIES** retourne les propriétés relatives à la saisie de données du champ désigné par *numTable* et *numChamp* ou par *ptrChp*."
		},
		"GET FIELD PROPERTIES": {
			"Syntax": "**GET FIELD PROPERTIES** ( ptrChp | numTable {; *numChamp*}; *champType* {; *champLong* {; *indexé* {; *unique* {; *invisible*}}}} )",
			"Params": [
				[
					"ptrChp &#124; numTable",
					"Pointeur, Entier long",
					"->",
					"Pointeur de champ ou Numéro de table"
				],
				[
					"numChamp",
					"Integer",
					"->",
					"Numéro de champ si un numéro de table est passé en premier paramètre"
				],
				[
					"champType",
					"Integer",
					"<-",
					"Type de champ"
				],
				[
					"champLong",
					"Integer",
					"<-",
					"Longueur du champ (si alphanumérique)"
				],
				[
					"indexé",
					"Boolean",
					"<-",
					"Vrai = Indexé, Faux = Non indexé"
				],
				[
					"unique",
					"Boolean",
					"<-",
					"Vrai = Unique, Faux = Non unique"
				],
				[
					"invisible",
					"Boolean",
					"<-",
					"Vrai = Invisible, Faux = Visible"
				]
			],
			"Summary": "La commande **GET FIELD PROPERTIES** retourne des informations sur le champ désigné par *numTable* et *numChamp* ou par *ptrChp*."
		},
		"GET FIELD RELATION": {
			"Syntax": "**GET FIELD RELATION** ( *champN* ; *aller* ; *retour* {; *} )",
			"Params": [
				[
					"champN",
					"Field",
					"->",
					"Champ de départ du lien"
				],
				[
					"aller",
					"Integer",
					"<-",
					"Statut du lien aller"
				],
				[
					"retour",
					"Integer",
					"<-",
					"Statut du lien retour"
				],
				[
					"*",
					"Opérateur",
					"->",
					"• Si passé : aller et retour retournent le statut courant effectif du lien (valeurs 2 ou 3 uniquement)• Si omis (défaut) : aller et retour peuvent retourner la valeur 1 si le lien n’a pas été modifié par programmation"
				]
			],
			"Summary": "La commande **GET FIELD RELATION** permet de connaître le statut automatique/manuel du lien partant du *champN* pour le process courant."
		},
		"GET FIELD TITLES": {
			"Syntax": "**GET FIELD TITLES** ( *laTable* ; *titresChamps* ; *numChamps* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous souhaitez connaître les noms des champs"
				],
				[
					"titresChamps",
					"Text array",
					"<-",
					"Noms courants des champs"
				],
				[
					"numChamps",
					"Integer array",
					"<-",
					"Numéros des champs"
				]
			],
			"Summary": "La commande **GET FIELD TITLES** remplit les tableaux *titresChamps* et *numChamps* avec les noms et les numéros des champs de *laTable* désignée."
		},
		"Get file from pasteboard": {
			"Syntax": "**Get file from pasteboard** ( *indiceN* ) : Text",
			"Params": [
				[
					"indiceN",
					"Integer",
					"->",
					"Nième fichier inclus dans le glisser"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d'accès de fichier extrait du conteneur de données"
				]
			],
			"Summary": "La commande **Get file from pasteboard** retourne le chemin d’accès absolu d’un fichier inclus dans une opération de glisser-déposer."
		},
		"Get group access": {
			"Syntax": "**Get group access** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de nom(s) de groupe(s) au(x)quel(s) l'utilisateur appartient"
				]
			],
			"Summary": "La commande **Get group access** retourne l'adhésion du compte utilisateur 4D à la session courante."
		},
		"GET GROUP LIST": {
			"Syntax": "**GET GROUP LIST** ( *nomsGroupes* ; *numérosGroupes* )",
			"Params": [
				[
					"nomsGroupes",
					"Text array",
					"<-",
					"Noms des groupes tels qu'ils apparaissent dans l'éditeur de Mots de passe"
				],
				[
					"numérosGroupes",
					"Integer array",
					"<-",
					"Numéros de référence uniques pour chaque groupe"
				]
			],
			"Summary": "**GET GROUP LIST** remplit les tableaux *nomsGroupes* et *numérosGroupes* avec les noms et les numéros de référence uniques des groupes tels qu'ils apparaissent dans l'éditeur de Mots de passe."
		},
		"GET GROUP PROPERTIES": {
			"Syntax": "**GET GROUP PROPERTIES** ( *réfGroupe* ; *nom* ; *propriétaire* {; *membres*} )",
			"Params": [
				[
					"réfGroupe",
					"Integer",
					"->",
					"Numéro de référence du groupe"
				],
				[
					"nom",
					"Text",
					"<-",
					"Nom du groupe"
				],
				[
					"propriétaire",
					"Integer",
					"<-",
					"Numéro de référence du propriétaire du groupe"
				],
				[
					"membres",
					"Integer array",
					"<-",
					"Membres du groupe"
				]
			],
			"Summary": "**GET GROUP PROPERTIES** retourne les propriétés du groupe dont le numéro de référence est passé dans *réfGroupe*."
		},
		"GET HIGHLIGHT": {
			"Syntax": "**GET HIGHLIGHT** ( {* ;} *objet* ; *débutSél* ; *finSél* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) <br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"Field, Variable, any",
					"->",
					"Nom d’objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"<-",
					"Position du début de la sélection de texte"
				],
				[
					"finSél",
					"Integer",
					"<-",
					"Position de la fin de la sélection de texte"
				]
			],
			"Summary": "La commande **GET HIGHLIGHT** vous permet de déterminer précisément le texte actuellement sélectionné dans *objet*."
		},
		"GET HIGHLIGHTED RECORDS": {
			"Syntax": "**GET HIGHLIGHTED RECORDS** ( {*laTable* ;} *nomEnsemble* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle lire les enregistrements marqués Si omis, table du formulaire courant"
				],
				[
					"nomEnsemble",
					"Text",
					"->",
					"Ensemble dans lequel stocker les enregistrements marqués"
				]
			],
			"Summary": "La commande **GET HIGHLIGHTED RECORDS** stocke dans l’ensemble désigné par le paramètre *nomEnsemble* les enregistrements marqués (c'est-à-dire, les enregistrements “surlignés” par l'utilisateur dans le formulaire liste) de *laTable* passée en paramètre."
		},
		"Get indexed string": {
			"Syntax": "**Get indexed string** ( *resNum* ; *strNum* {; *resFichier*} ) : Text",
			"Params": [
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de ressource ou Attribut 'id' de l'élément 'group' (XLIFF)"
				],
				[
					"strNum",
					"Integer",
					"->",
					"Numéro de chaîne ou Attribut 'id' de l'élément 'trans-unit' (XLIFF)"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources Si omis : tous les fichiers XLIFF ou les fichiers de ressources ouverts"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur de la chaîne indexée"
				]
			],
			"Summary": "une des chaînes stockées dans la ressource liste de chaînes (\"STR#\") dont vous avez passé le numéro d'ID dans *resNum*"
		},
		"Get list item font": {
			"Syntax": "**Get list item font** ( {* ;} *liste* ; refElément | * ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d’élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de police"
				]
			],
			"Summary": "La commande **Get list item font** retourne le nom de la police de caractères courante de l’élément désigné par le paramètre *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d’objet dans *liste*."
		},
		"GET LIST ITEM ICON": {
			"Syntax": "**GET LIST ITEM ICON** ( {* ;} *liste* ; refElément | * ; *icône* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Opérateur, Entier long",
					"->",
					"Numéro de référence d’élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"icône",
					"Picture",
					"<-",
					"Icône associée à l'élément"
				]
			],
			"Summary": "La commande **GET LIST ITEM ICON** retourne dans *icône* l’icône associée à l’élément dont vous avez passé le numéro de référence dans *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d’objet dans *liste*."
		},
		"GET LIST ITEM PARAMETER ARRAYS": {
			"Syntax": "**GET LIST ITEM PARAMETER ARRAYS** ( {* ;} *liste* ; refElément | * ; *tabSélecteurs* {; *tabValeurs*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne)Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ouNom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d’élément ou0 pour le dernier élément ajouté à la liste ou* pour l’élément courant de la liste"
				],
				[
					"tabSélecteurs",
					"Text array",
					"<-",
					"Tableau des noms de paramètres"
				],
				[
					"tabValeurs",
					"Text array",
					"<-",
					"Tableau des valeurs de paramètres"
				]
			],
			"Summary": "La commande **GET LIST ITEM PARAMETER ARRAYS** permet de récupérer en un seul appel l’ensemble des paramètres (ainsi que, optionnellement, leurs valeurs) associés à l’élément *refElément* de la liste hiérarchique dont vous avez passé la référence ou le nom d’objet dans le paramètre *liste*."
		},
		"GET LIST ITEM PARAMETER": {
			"Syntax": "**GET LIST ITEM PARAMETER** ( {* ;} *liste* ; refElément | * ; *sélecteur* ; *valeur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d’élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"sélecteur",
					"Text",
					"->",
					"Constante de paramètre"
				],
				[
					"valeur",
					"Text, Boolean, Real",
					"<-",
					"Valeur courante du paramètre"
				]
			],
			"Summary": "La commande **GET LIST ITEM PARAMETER** permet de connaître la *valeur* courante du paramètre *sélecteur* pour l’élément *réfElément* de la liste hiérarchique dont vous avez passé la référence ou le nom d’objet dans le paramètre *liste*."
		},
		"GET LIST ITEM PROPERTIES": {
			"Syntax": "**GET LIST ITEM PROPERTIES** ( {* ;} *liste* ; refElément | * ; *saisissable* {; *style* {; *icône* {; *couleur*}}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Opérateur, Entier long",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"saisissable",
					"Boolean",
					"<-",
					"Vrai = Saisissable, Faux = Non-saisissable"
				],
				[
					"style",
					"Integer",
					"<-",
					"Style de police de l'élément"
				],
				[
					"icône",
					"Text, Integer",
					"<-",
					"131072 + numéro de référence d'image"
				],
				[
					"couleur",
					"Integer",
					"<-",
					"Valeur de couleur RVB"
				]
			],
			"Summary": "La commande **GET LIST ITEM PROPERTIES** retourne les propriétés de l'élément désigné par le paramètre *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"GET LIST ITEM": {
			"Syntax": "**GET LIST ITEM** ( {* ;} *liste* ; positionElém | * ; *réfElément* ; *libelléElément* {; sous_Liste ; *déployée*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"positionElém &#124; *",
					"Opérateur, Entier long",
					"->",
					"Position de l'élément dans la ou les liste(s) déployée(s)/contractée(s) ou * pour l‘élément courant de la liste"
				],
				[
					"réfElément",
					"Integer",
					"<-",
					"Numéro de référence de l'élément"
				],
				[
					"libelléElément",
					"Text",
					"<-",
					"Libellé de l'élément"
				],
				[
					"sous_Liste",
					"Integer",
					"<-",
					"Numéro de référence de sous-liste (s'il y en a)"
				],
				[
					"déployée",
					"Boolean",
					"<-",
					"Si une sous-liste est rattachée à l'élément : Vrai = la sous-liste est déployée Faux = la sous-liste est contractée"
				]
			],
			"Summary": "La commande **GET LIST ITEM** retourne des informations sur l'élément désigné par le paramètre *positionElém* de la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"GET LIST PROPERTIES": {
			"Syntax": "**GET LIST PROPERTIES** ( *liste* ; *apparence* {; *icône* {; *hauteurLigne* {; *doubleClic* {; *multiSélection* {; *modifiable*}}}}} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de la liste"
				],
				[
					"apparence",
					"Integer",
					"<-",
					"Style graphique de la liste 1 = Liste hiérarchique à la Macintosh 2 = Liste hiérarchique à la Windows"
				],
				[
					"icône",
					"Integer",
					"<-",
					"*** Paramètre obsolète, retourne 0 ***"
				],
				[
					"hauteurLigne",
					"Integer",
					"<-",
					"Hauteur minimale de la ligne (pixels)"
				],
				[
					"doubleClic",
					"Integer",
					"<-",
					"Déploiement/contraction sur double-clic 0 = autorisé, 1= empêché"
				],
				[
					"multiSélection",
					"Integer",
					"<-",
					"Sélections multiples : 0 = interdites, 1 = autorisées"
				],
				[
					"modifiable",
					"Integer",
					"<-",
					"Enumération modifiable : 0 = non, 1 = oui"
				]
			],
			"Summary": "La commande **GET LIST PROPERTIES** retourne des informations sur la liste hiérarchique dont vous avez passé le numéro de référence dans le paramètre *liste*."
		},
		"GET MACRO PARAMETER": {
			"Syntax": "**GET MACRO PARAMETER** ( *sélecteur* ; *paramTexte* )",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Sélection à utiliser"
				],
				[
					"paramText",
					"Text",
					"<-",
					"Texte récupéré"
				]
			],
			"Summary": "La commande **GET MACRO PARAMETER** retourne dans *paramTexte* une partie ou la totalité du texte de la méthode depuis laquelle elle a été appelée."
		},
		"Get menu bar reference": {
			"Syntax": "**Get menu bar reference** {( *process* )} : Text",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Identifiant de la barre de menus"
				]
			],
			"Summary": "La commande **Get menu bar reference** renvoie l’identifiant unique de la barre de menus courante ou de la barre de menus d’un process spécifique."
		},
		"GET MENU ITEM ICON": {
			"Syntax": "**GET MENU ITEM ICON** ( *menu* ; *ligneMenu* ; *refIcône* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"refIcône",
					"Text, Integer",
					"<-",
					"Nom ou numéro de l’image associée à la ligne de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "La commande **GET MENU ITEM ICON** retourne dans la variable *refIcône* la référence de l’icône éventuellement associée à la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"Get menu item key": {
			"Syntax": "**Get menu item key** ( *menu* ; *ligneMenu* {; *process*} ) : Integer",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de la ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code de caractère de de la touche de raccourci standard associée à la ligne de menu"
				]
			],
			"Summary": "La commande **Get menu item key** retourne le code de la touche **Ctrl** (sous Windows) ou **Commande** (macOS) utilisée comme raccourci clavier pour la commande de menu dont le numéro ou la référence de menu et le numéro de ligne ont été passés dans *menu* et *ligneMenu*."
		},
		"Get menu item mark": {
			"Syntax": "**Get menu item mark** ( *menu* ; *ligneMenu* {; *process*} ) : Text",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Marque de ligne de menu courante"
				]
			],
			"Summary": "La commande **Get menu item mark** retourne la marque (ou \"coche\") de la ligne de menu dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*."
		},
		"Get menu item method": {
			"Syntax": "**Get menu item method** ( *menu* ; *ligneMenu* {; *process*} ) : Text",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la méthode"
				]
			],
			"Summary": "La commande **Get menu item method** retourne le nom de la méthode projet 4D associée à la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"Get menu item modifiers": {
			"Syntax": "**Get menu item modifiers** ( *menu* ; *ligneMenu* {; *process*} ) : Integer",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ouNuméro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Touche(s) de modification associée(s) à la ligne de menu"
				]
			],
			"Summary": "La commande **Get menu item modifiers** retourne le ou les modificateur(s) additionnel(s) associé(s) au raccourci standard de la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"Get menu item parameter": {
			"Syntax": "**Get menu item parameter** ( *menu* ; *ligneMenu* ) : Text",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Paramètre personnalisé de la ligne de menu"
				]
			],
			"Summary": "La commande **Get menu item parameter** retourne la chaîne de caractères personnalisée associée à la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"GET MENU ITEM PROPERTY": {
			"Syntax": "**GET MENU ITEM PROPERTY** ( *menu* ; *ligneMenu* ; *propriété* ; *valeur* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"propriété",
					"Text",
					"->",
					"Type de propriété"
				],
				[
					"valeur",
					"any",
					"<-",
					"Valeur de la propriété"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "La commande **GET MENU ITEM PROPERTY** retourne dans le paramètre *valeur* la valeur courante de la propriété de la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"Get menu item style": {
			"Syntax": "**Get menu item style** ( *menu* ; *ligneMenu* {; *process*} ) : Integer",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Style courant de la ligne de menu"
				]
			],
			"Summary": "La commande **Get menu item style** retourne le style de police de la ligne de menu dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*."
		},
		"Get menu item": {
			"Syntax": "**Get menu item** ( *menu* ; *ligneMenu* {; *process*} ) : Text",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Libellé de la ligne de menu"
				]
			],
			"Summary": "La commande **Get menu item** retourne le libellé de la commande de menu dont le numéro ou la référence de menu et le numéro de commande ont été passés dans *menu* et *ligneMenu*."
		},
		"GET MENU ITEMS": {
			"Syntax": "**GET MENU ITEMS** ( *menu* ; *tabTitresMenus* ; *tabRefsMenus* )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"tabTitresMenus",
					"Text array",
					"<-",
					"Tableau des libellés du menu"
				],
				[
					"tabRefsMenus",
					"Text array",
					"<-",
					"Tableau des références du menu"
				]
			],
			"Summary": "La commande **GET MENU ITEMS** retourne dans les tableaux *tabTitresMenu* et *tabRefsMenu* les libellés et les identifiants de toutes les lignes du menu ou de la barre de menus désigné(e) par le paramètre *menu*."
		},
		"Get menu title": {
			"Syntax": "**Get menu title** ( *menu* {; *process*} ) : Text",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Titre du menu"
				]
			],
			"Summary": "La commande **Get menu title** retourne le titre du menu dont vous avez passé le numéro ou la référence dans *menu*."
		},
		"GET MISSING TABLE NAMES": {
			"Syntax": "**GET MISSING TABLE NAMES** ( *tabManquantes* )",
			"Params": [
				[
					"tabManquantes",
					"Text array",
					"<-",
					"Noms des tables manquantes dans la base"
				]
			],
			"Summary": "La commande **GET MISSING TABLE NAMES** retourne dans le tableau *tabManquantes* les noms de toutes les tables manquantes de la base courante."
		},
		"GET PASTEBOARD DATA TYPE": {
			"Syntax": "**GET PASTEBOARD DATA TYPE** ( *signatures4D* ; *typesNatifs* {; *nomsFormats*} )",
			"Params": [
				[
					"signatures4D",
					"Text array",
					"<-",
					"Signatures 4D des types de données"
				],
				[
					"typesNatifs",
					"Text array",
					"<-",
					"Types de données natifs"
				],
				[
					"nomsFormats",
					"Text array",
					"<-",
					"Noms ou descriptions des formats"
				]
			],
			"Summary": "La commande **GET PASTEBOARD DATA TYPE** permet d’obtenir la liste des types de données présents dans le conteneur."
		},
		"GET PASTEBOARD DATA": {
			"Syntax": "**GET PASTEBOARD DATA** ( *typeDonnées* ; *données* )",
			"Params": [
				[
					"typeDonnées",
					"Text",
					"->",
					"Type de données à extraire du conteneur"
				],
				[
					"données",
					"Blob",
					"<-",
					"Données extraites du conteneur"
				]
			],
			"Summary": "**GET PASTEBOARD DATA** retourne dans le champ ou la variable de type BLOB *données* les données qui se trouvent dans le conteneur de données et dont le type est passé dans *typeDonnées*."
		},
		"Get picture file name": {
			"Syntax": "**Get picture file name** ( *image* ) : Text",
			"Params": [
				[
					"image",
					"Picture, Picture",
					"->",
					"Image dont vous souhaitez obtenir le nom par défaut"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom par défaut du fichier image"
				]
			],
			"Summary": "La commande **Get picture file name** retourne le nom par défaut courant de l’image passée en paramètre."
		},
		"GET PICTURE FORMATS": {
			"Syntax": "**GET PICTURE FORMATS** ( *image* ; *tabCodecs* )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"champ ou variable Image à analyser"
				],
				[
					"tabCodecs",
					"Text array",
					"<-",
					"Liste des codecs de l'image"
				]
			],
			"Summary": "La commande **GET PICTURE FORMATS** remplit le tableau *tabCodecs* de tous les identifiants des codecs (formats image) de l'image contenue dans le paramètre *image*."
		},
		"GET PICTURE FROM LIBRARY": {
			"Syntax": "**GET PICTURE FROM LIBRARY** ( *refImage * ; *image* )<br/>**GET PICTURE FROM LIBRARY** ( *nomImage* ; *image* )",
			"Params": [
				[
					"refImage &#124; nomImage",
					"Entier long, Chaîne",
					"->",
					"Numéro de référence ou Nom d'une image de la bibliothèque d’images"
				],
				[
					"image",
					"Picture",
					"<-",
					"Image de la bibliothèque d'images"
				]
			],
			"Summary": "La commande **GET PICTURE FROM LIBRARY** retourne dans *image* l'image de la bibliothèque dont vous avez passé le numéro de référence dans *refImage* ou le nom dans *nomImage*."
		},
		"GET PICTURE FROM PASTEBOARD": {
			"Syntax": "**GET PICTURE FROM PASTEBOARD** ( *image* )",
			"Params": [
				[
					"image",
					"Picture",
					"<-",
					"Image extraite du conteneur de données"
				]
			],
			"Summary": "**GET PICTURE FROM PASTEBOARD** retourne l'image présente dans le conteneur de données dans le champ ou la variable *image*."
		},
		"GET PICTURE KEYWORDS": {
			"Syntax": "**GET PICTURE KEYWORDS** ( *image* ; *tabMotsclés* {; *} )",
			"Params": [
				[
					"image",
					"Picture, Picture",
					"->",
					"Image dont vous souhaitez lire les mots-clés associés"
				],
				[
					"tabMotsclés",
					"Text array",
					"<-",
					"Tableau contenant les mots-clés extraits"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = utiliser les valeurs distinctes"
				]
			],
			"Summary": "La commande **GET PICTURE KEYWORDS** retourne dans le tableau *tabMotsclés* la liste des mots-clés associés à l’image passée en paramètre."
		},
		"GET PICTURE METADATA": {
			"Syntax": "**GET PICTURE METADATA** ( *image* ; *nomMeta* ; *contenuMeta* {; *nomMeta2* ; *contenuMeta2* ; ... ; *nomMetaN* ; *contenuMetaN*} )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image dont vous souhaitez lire les métadonnées"
				],
				[
					"nomMeta",
					"Text",
					"->",
					"Nom ou chemin du bloc à lire"
				],
				[
					"contenuMeta",
					"Variable",
					"<-",
					"Contenu de la métadonnée"
				]
			],
			"Summary": "La commande **GET PICTURE METADATA** permet de lire le contenu de métadonnées (ou méta-balises) présentes dans *image* (champ ou une variable image 4D)."
		},
		"GET PICTURE RESOURCE": {
			"Syntax": "**GET PICTURE RESOURCE** ( *resNum* ; *resDonnées* {; *resFichier*} )",
			"Params": [
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de ressource"
				],
				[
					"resDonnées",
					"Field, Variable",
					"->",
					"Champ ou variable image devant recevoir l'image"
				],
				[
					"<-",
					"Contenu de la ressource PICT"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources ou tous les fichiers de ressources ouverts si ce paramètre est omis"
				]
			],
			"Summary": "La commande **GET PICTURE RESOURCE** retourne dans le champ ou la variable image désigné(e) par *resDonnées* l'image stockée dans la ressource image (\"PICT\") dont vous passé le numéro dans *resNum*."
		},
		"Get plugin access": {
			"Syntax": "**Get plugin access** ( *plugIn* ) : Text",
			"Params": [
				[
					"plugIn",
					"Integer",
					"->",
					"Numéro du plug-in"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom du groupe associé au plug-in"
				]
			],
			"Summary": "La commande **Get plugin access** retourne le nom du groupe d’utilisateurs autorisé à utiliser le plug-in dont le numéro a été passé dans le paramètre *plugIn*."
		},
		"Get pointer": {
			"Syntax": "**Get pointer** ( *nomVar* ) : Pointer",
			"Params": [
				[
					"nomVar",
					"Text",
					"->",
					"Nom d'une variable process ou interprocess"
				],
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers une variable process ou interprocess"
				]
			],
			"Summary": "**Get pointer** retourne un pointeur vers la variable process ou interprocess dont le nom est passé dans *nomVar*."
		},
		"Get print marker": {
			"Syntax": "**Get print marker** ( *numTaquet* ) : Integer",
			"Params": [
				[
					"numTaquet",
					"Integer",
					"->",
					"Numéro de taquet"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Position du taquet"
				]
			],
			"Summary": "La commande **Get print marker** permet de récupérer la position courante d’un taquet lors d’une impression."
		},
		"GET PRINT OPTION": {
			"Syntax": "**GET PRINT OPTION** ( *option* ; *valeur1* {; *valeur2*} )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Numéro d’option ou Code d'option PDF"
				],
				[
					"valeur1",
					"Integer, Text",
					"<-",
					"Valeur 1 de l’option"
				],
				[
					"valeur2",
					"Integer, Text",
					"<-",
					"Valeur 2 de l’option"
				]
			],
			"Summary": "La commande **GET PRINT OPTION** retourne la ou les valeur(s) courante(s) d’une option d’impression."
		},
		"Get print preview": {
			"Syntax": "**Get print preview**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = Impression à l’écran, Faux = Pas d’impression écran"
				]
			],
			"Summary": "La commande **Get print preview** retourne Vrai si l’instruction SET PRINT PREVIEW a été appelée avec la valeur **Vrai** dans le process courant."
		},
		"GET PRINTABLE AREA": {
			"Syntax": "**GET PRINTABLE AREA** ( *hauteur* {; *largeur*} )",
			"Params": [
				[
					"hauteur",
					"Integer",
					"<-",
					"Hauteur de la zone d’impression"
				],
				[
					"largeur",
					"Integer",
					"<-",
					"Largeur de la zone d’impression"
				]
			],
			"Summary": "La commande **GET PRINTABLE AREA** retourne dans les paramètres *hauteur* et *largeur* la taille en pixels de la zone d’impression."
		},
		"GET PRINTABLE MARGIN": {
			"Syntax": "**GET PRINTABLE MARGIN** ( *gauche* ; *haut* ; *droite* ; *bas* )",
			"Params": [
				[
					"gauche",
					"Integer",
					"<-",
					"Marge gauche"
				],
				[
					"haut",
					"Integer",
					"<-",
					"Marge supérieure"
				],
				[
					"droite",
					"Integer",
					"<-",
					"Marge droite"
				],
				[
					"bas",
					"Integer",
					"<-",
					"Marge inférieure"
				]
			],
			"Summary": "La commande **GET PRINTABLE MARGIN** retourne les valeurs courantes des différentes marges définies lors de l’utilisation des commandes Print form, PRINT SELECTION et PRINT RECORD."
		},
		"Get printed height": {
			"Syntax": "**Get printed height**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Position du marqueur"
				]
			],
			"Summary": "La commande **Get printed height** retourne la hauteur globale (en pixels) de la section imprimée par la commande Print form."
		},
		"GET PROCESS VARIABLE": {
			"Syntax": "**GET PROCESS VARIABLE** ( *process* ; *varSource* ; *varDestination* {; *varSource2* ; *varDestination2* ; ... ; *varSourceN* ; *varDestinationN*} )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de process source"
				],
				[
					"varSource",
					"Variable",
					"->",
					"Variable source"
				],
				[
					"varDestination",
					"Variable",
					"<-",
					"Variable de destination"
				]
			],
			"Summary": "La commande **GET PROCESS VARIABLE** lit la valeur de la ou des variable(s) process *varSource* (*varSource2*, etc.) depuis le process source dont le numéro est passé dans *process* et la retourne dans la ou les variables(s) *varDestination* ( *varDestination2*, etc.) du process courant."
		},
		"GET QUERY DESTINATION": {
			"Syntax": "**GET QUERY DESTINATION** ( *destinationType* ; *destinationObjet* ; *destinationPtr* )",
			"Params": [
				[
					"destinationType",
					"Integer",
					"<-",
					"0 = sélection courante, 1 = ensemble, 2 = sélection temporaire, 3 = variable"
				],
				[
					"destinationObjet",
					"Text",
					"<-",
					"Nom de l'ensemble ou Nom de la sélection temporaire ou Chaîne vide"
				],
				[
					"destinationPtr",
					"Pointer",
					"<-",
					"Pointeur vers variable locale si destinationType = 3"
				]
			],
			"Summary": "La commande **GET QUERY DESTINATION** retourne la destination courante des résultats des recherches pour le process en cours."
		},
		"Get query limit": {
			"Syntax": "**Get query limit** : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre limite d’enregistrements, 0 = nombre illimité"
				]
			],
			"Summary": "La commande **Get query limit** retourne la limite du nombre d’enregistrements qu’une recherche pourra trouver dans le process courant."
		},
		"GET REGISTERED CLIENTS": {
			"Syntax": "**GET REGISTERED CLIENTS** ( *listeClients* ; *nbMéthodes* )",
			"Params": [
				[
					"listeClients",
					"Text array",
					"<-",
					"Liste des 4D Client enregistrés"
				],
				[
					"nbMéthodes",
					"Integer array",
					"<-",
					"Liste des méthodes restant à exécuter"
				]
			],
			"Summary": "La commande **GET REGISTERED CLIENTS** remplit deux tableaux"
		},
		"GET RELATION PROPERTIES": {
			"Syntax": "**GET RELATION PROPERTIES** ( ptrChp | numTable {; *numChamp*}; *tableDest* ; *champDest* {; *discriminant* {; *allerAuto* {; *retourAuto*}}} )",
			"Params": [
				[
					"ptrChp &#124; numTable",
					"Pointeur, Entier long",
					"->",
					"Pointeur de champ ou Numéro de table"
				],
				[
					"numChamp",
					"Integer",
					"->",
					"Numéro de champ si un numéro de table est passé en premier paramètre"
				],
				[
					"tableDest",
					"Integer",
					"<-",
					"Numéro de la table cible ou 0 si aucun lien ne part du champ"
				],
				[
					"champDest",
					"Integer",
					"<-",
					"Numéro du champ cible ou 0 si aucun lien ne part du champ"
				],
				[
					"discriminant",
					"Integer",
					"<-",
					"Numéro du champ discriminant ou 0 si aucun champ discriminant"
				],
				[
					"allerAuto",
					"Boolean",
					"<-",
					"Vrai = Lien aller automatique, Faux = Lien aller manuel"
				],
				[
					"retourAuto",
					"Boolean",
					"<-",
					"Vrai = Lien retour automatique, Faux = Lien retour manuel"
				]
			],
			"Summary": "La commande **GET RELATION PROPERTIES** retourne les propriétés du lien, s’il y en a un, qui part du champ source, désigné par *numTable* et *numChamp* ou par *ptrChp*."
		},
		"Get resource name": {
			"Syntax": "**Get resource name** ( *resType* ; *resNum* {; *resFichier*} ) : Text",
			"Params": [
				[
					"resType",
					"Text",
					"->",
					"Type de ressource (4 caractères)"
				],
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de référence de ressource (ID)"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence du fichier de ressource ou Tous les fichiers de ressources ouverts si omis"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la ressource"
				]
			],
			"Summary": "**Get resource name** retourne le nom de la ressource dont le type est passé dans *resType* et le numéro de référence (ID) dans *resNum*."
		},
		"Get resource properties": {
			"Syntax": "**Get resource properties** ( *resType* ; *resNum* {; *resFichier*} ) : Integer",
			"Params": [
				[
					"resType",
					"Text",
					"->",
					"Type de ressource (4 caractères)"
				],
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de référence de ressource (ID)"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence du fichier de ressource ou Tous les fichiers de ressources ouverts si omis"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Attributs de la ressource"
				]
			],
			"Summary": "**Get resource properties** retourne les attributs de la ressource dont le type est passé dans le paramètre *resType* et le numéro de référence dans *resNum*."
		},
		"GET RESOURCE": {
			"Syntax": "**GET RESOURCE** ( *resType* ; *resNum* ; *resDonnées* {; *resFichier*} )",
			"Params": [
				[
					"resType",
					"Text",
					"->",
					"Type de ressource (4 caractères)"
				],
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de ressource"
				],
				[
					"resDonnées",
					"Blob",
					"->",
					"Champ ou variable BLOB devant recevoir les données"
				],
				[
					"<-",
					"Contenu de la ressource"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources ou Tous les fichiers de ressources ouverts si omis"
				]
			],
			"Summary": "La commande **GET RESOURCE** retourne dans le champ ou la variable BLOB *resDonnées* le contenu de la ressource dont le type et le numéro sont passés dans *resType* et *resNum*."
		},
		"Get selected menu item parameter": {
			"Syntax": "**Get selected menu item parameter**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Paramètre personnalisé de la ligne de menu"
				]
			],
			"Summary": "La commande **Get selected menu item parameter** retourne la chaîne de caractères personnalisée associée à la ligne de menu sélectionnée."
		},
		"GET SERIAL PORT MAPPING": {
			"Syntax": "**GET SERIAL PORT MAPPING** ( *tabNums* ; *tabLibellés* )",
			"Params": [
				[
					"tabNums",
					"Integer array",
					"<-",
					"Tableau de numéros de ports série"
				],
				[
					"tabLibellés",
					"Text array",
					"<-",
					"Tableau de noms de ports série"
				]
			],
			"Summary": "La commande **GET SERIAL PORT MAPPING** retourne deux tableaux *tabNums* et *tabLibellés* contenant respectivement la liste des numéros et des noms des ports série de la machine courante."
		},
		"Get string resource": {
			"Syntax": "**Get string resource** ( *resNum* {; *resFichier*} ) : Text",
			"Params": [
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de ressource"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources ou tous les fichiers de ressources ouverts si ce paramètre est omis"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Contenu de la ressource STR"
				]
			],
			"Summary": "La commande **Get string resource** retourne la chaîne stockée dans la ressource chaîne (\"STR \") dont vous avez passé le numéro d'ID dans *resNum*."
		},
		"GET STYLE SHEET INFO": {
			"Syntax": "**GET STYLE SHEET INFO** ( *nomFeuilleStyle* ; *police* ; *taille* ; *styles* )",
			"Params": [
				[
					"nomFeuilleStyle",
					"Text",
					"->",
					"Nom de la feuille de style"
				],
				[
					"police",
					"Text",
					"<-",
					"Police de caractères"
				],
				[
					"taille",
					"Integer",
					"<-",
					"Taille de police"
				],
				[
					"styles",
					"Integer",
					"<-",
					"Valeur de style"
				]
			],
			"Summary": "La commande **GET STYLE SHEET INFO** retourne la configuration courante de la feuille de style *nomFeuilleStyle*."
		},
		"Get subrecord key": {
			"Syntax": "**Get subrecord key** ( *champID* ) : Integer",
			"Params": [
				[
					"champID",
					"Field",
					"->",
					"Champ de type \"Lien sous-table\" ou de type \"Entier long\" d’une ancienne relation sous-table"
				],
				[
					"Entier long",
					"Integer",
					"<-",
					"Clé interne du lien"
				]
			],
			"Summary": "La commande **Get subrecord key** est destinée à faciliter la migration du code 4D utilisant des sous-tables converties vers le code standard de manipulation des tables."
		},
		"GET SYSTEM FORMAT": {
			"Syntax": "**GET SYSTEM FORMAT** ( *format* ; *valeur* )",
			"Params": [
				[
					"format",
					"Integer",
					"->",
					"Formatage système à lire"
				],
				[
					"valeur",
					"Text",
					"<-",
					"Valeur de formatage définie dans le système"
				]
			],
			"Summary": "La commande **GET SYSTEM FORMAT** retourne la valeur courante de plusieurs paramètres régionaux définis dans le système d’exploitation."
		},
		"GET TABLE PROPERTIES": {
			"Syntax": "**GET TABLE PROPERTIES** ( ptrTable | numTable ; *invisible* {; *trigSvgdeNouv* {; *trigSvgdeEnr* {; *trigSupprEnr* {; *trigChargEnr*}}}} )",
			"Params": [
				[
					"ptrTable &#124; numTable",
					"Pointeur, Entier long",
					"->",
					"Pointeur de table ou Numéro de table"
				],
				[
					"invisible",
					"Boolean",
					"<-",
					"Vrai = Invisible, Faux = Visible"
				],
				[
					"trigSvgdeNouv",
					"Boolean",
					"<-",
					"Vrai = Trigger “Sur sauvegarde nouvel enreg” activé, sinon Faux"
				],
				[
					"trigSvgdeEnr",
					"Boolean",
					"<-",
					"Vrai = Trigger “Sur sauvegarde enregistrement” activé, sinon Faux"
				],
				[
					"trigSupprEnr",
					"Boolean",
					"<-",
					"Vrai = Trigger “Sur suppression enreg” activé, sinon Faux"
				],
				[
					"trigChargEnr",
					"Boolean",
					"<-",
					"*** Ne pas utiliser (obsolète) ***"
				]
			],
			"Summary": "La commande **GET TABLE PROPERTIES** retourne les propriétés de la table désignée par *ptrTable* ou *numTable*."
		},
		"GET TABLE TITLES": {
			"Syntax": "**GET TABLE TITLES** ( *titresTables* ; *numTables* )",
			"Params": [
				[
					"titresTables",
					"Text array",
					"<-",
					"Noms courants des tables"
				],
				[
					"numTables",
					"Integer array",
					"<-",
					"Numéros des tables"
				]
			],
			"Summary": "La commande **GET TABLE TITLES** remplit les tableaux *titresTables* et *numTables* avec les noms et les numéros des tables de la base définis dans la fenêtre de Structure ou via la commande SET TABLE TITLES."
		},
		"Get text from pasteboard": {
			"Syntax": "**Get text from pasteboard**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Texte présent dans le conteneur de données"
				]
			],
			"Summary": "**Get text from pasteboard** retourne le texte présent dans le conteneur de données."
		},
		"GET TEXT KEYWORDS": {
			"Syntax": "**GET TEXT KEYWORDS** ( *texte* ; *tabMotsClés* {; *} )",
			"Params": [
				[
					"texte",
					"Text",
					"->",
					"Texte original"
				],
				[
					"tabMotsClés",
					"Text array",
					"<-",
					"Tableau contenant les mots-clés"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = mots uniques"
				]
			],
			"Summary": "La commande **GET TEXT KEYWORDS** découpe la totalité du *texte* en mots et crée, pour chaque mot obtenu, un élément dans le tableau texte *tabMotsClés*."
		},
		"Get text resource": {
			"Syntax": "**Get text resource** ( *resNum* {; *resFichier*} ) : Text",
			"Params": [
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de ressource"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources ou tous les fichiers de ressources ouverts si ce paramètre est omis"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Contenu de la ressource TEXT"
				]
			],
			"Summary": "La commande **Get text resource** retourne le texte stocké dans la ressource texte (\"TEXT\") dont vous avez passé le numéro d'ID dans *resNum*."
		},
		"GET USER LIST": {
			"Syntax": "**GET USER LIST** ( *nomsUtil* ; *réfUtil* )",
			"Params": [
				[
					"nomsUtil",
					"Text array",
					"<-",
					"Noms des utilisateurs tels qu'ils apparaissent dans l'éditeur de Mots de passe"
				],
				[
					"réfUtil",
					"Integer array",
					"<-",
					"Numéros de référence uniques pour chaque utilisateur"
				]
			],
			"Summary": "La commande **GET USER LIST** remplit les tableaux *nomsUtil* et *réfsUtil* avec les noms et les numéros de référence uniques des utilisateurs tels qu'ils apparaissent dans la fenêtre des Mots de passe de 4D."
		},
		"GET USER PROPERTIES": {
			"Syntax": "**GET USER PROPERTIES** ( *réfUtilisateur* ; *nom* ; *démarrage* ; *motDePasse* ; *nbUtilisations* ; *dernièreUtilisation* {; *adhésions* {; *groupePropriétaire*}} )",
			"Params": [
				[
					"réfUtilisateur",
					"Integer",
					"->",
					"Numéro de référence unique de l'utilisateur"
				],
				[
					"nom",
					"Text",
					"<-",
					"Nom de l'utilisateur"
				],
				[
					"démarrage",
					"Text",
					"<-",
					"Nom de la méthode de démarrage"
				],
				[
					"motDePasse",
					"Text",
					"<-",
					"*** obsolète (chaîne vide)  ***"
				],
				[
					"nbUtilisations",
					"Integer",
					"<-",
					"Nombre d'utilisations de la base"
				],
				[
					"dernièreUtilisation",
					"Date",
					"<-",
					"Date de la dernière utilisation de la base"
				],
				[
					"adhésions",
					"Integer array",
					"<-",
					"Numéros de référence des groupes auxquels l'utilisateur appartient"
				],
				[
					"groupePropriétaire",
					"Integer",
					"<-",
					"Numéro de référence du groupe propriétaire de l’utilisateur"
				]
			],
			"Summary": "**GET USER PROPERTIES** retourne les informations concernant l'utilisateur dont le numéro de référence est passé dans le paramètre *réfUtilisateur*."
		},
		"GET WINDOW RECT": {
			"Syntax": "**GET WINDOW RECT** ( *gauche* ; *haut* ; *droite* ; *bas* {; *fenêtre*} )",
			"Params": [
				[
					"gauche",
					"Integer",
					"<-",
					"Coordonnée gauche de l'intérieur de la fenêtre"
				],
				[
					"haut",
					"Integer",
					"<-",
					"Coordonnée supérieure de l'intérieur de la fenêtre"
				],
				[
					"droite",
					"Integer",
					"<-",
					"Coordonnée droite de l'intérieur de la fenêtre"
				],
				[
					"bas",
					"Integer",
					"<-",
					"Coordonnée inférieure de l'intérieur de la fenêtre"
				],
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process si omis ou Fenêtre MDI si -1 (Windows)"
				]
			],
			"Summary": "La commande **GET WINDOW RECT** retourne les coordonnées globales de la fenêtre dont vous avez passé le numéro de référence dans le paramètre *fenêtre*."
		},
		"Get window title": {
			"Syntax": "**Get window title** {( *fenêtre* )} : Text",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process courant si omis"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Titre de la fenêtre"
				]
			],
			"Summary": "La commande **Get window title** retourne le titre de la fenêtre dont le numéro de référence est passé dans *fenêtre*."
		},
		"GOTO OBJECT": {
			"Syntax": "**GOTO OBJECT** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d’objet (chaîne) Si omis = objet est un champ ou une variable"
				],
				[
					"objet",
					"Field, Variable",
					"->",
					"Nom d’objet (si * spécifié) sinon Variable ou champ saisissable à sélectionner"
				]
			],
			"Summary": "La commande **GOTO OBJECT** permet de sélectionner l'objet saisissable *objet* (variable ou champ) en tant que zone active du formulaire."
		},
		"GOTO RECORD": {
			"Syntax": "**GOTO RECORD** ( {*laTable* ;} *enregistrement* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement de destination ou Table par défaut si ce paramètre est omis"
				],
				[
					"enregistrement",
					"Integer",
					"->",
					"Numéro renvoyé par Numero enregistrement"
				]
			],
			"Summary": "**GOTO RECORD** sélectionne l'enregistrement courant de *table*."
		},
		"GOTO SELECTED RECORD": {
			"Syntax": "**GOTO SELECTED RECORD** ( {*laTable* ;} *enregistrement* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle aller à l'enregistrement spécifié ou Table par défaut si ce paramètre est omis"
				],
				[
					"enregistrement",
					"Integer",
					"->",
					"Position de l'enregistrement dans la sélection"
				]
			],
			"Summary": "La commande **GOTO SELECTED RECORD** fait de l'enregistrement spécifié parmi la sélection courante de *laTable* l'enregistrement courant."
		},
		"GOTO XY": {
			"Syntax": "**GOTO XY** ( *x* ; *y* )",
			"Params": [
				[
					"x",
					"Integer",
					"->",
					"Coordonnée x (horizontale) du curseur"
				],
				[
					"y",
					"Integer",
					"->",
					"Coordonnée y (verticale) du curseur"
				]
			],
			"Summary": "La commande **GOTO XY** est destinée à être utilisée conjointement avec la commande MESSAGE lorsque vous affichez des messages dans une fenêtre ouverte par la commande Open window."
		},
		"GRAPH SETTINGS": {
			"Syntax": "**GRAPH SETTINGS** ( *graphImage* ; *xmin* ; *xmax* ; *ymin* ; *ymax* ; *xprop* ; *grilleX* ; *grilleY* ; *titre* {; *titre2* ; ... ; *titreN*} )",
			"Params": [
				[
					"graphImage",
					"Picture",
					"->",
					"Variable image"
				],
				[
					"xmin",
					"Integer, Date, Time",
					"->",
					"Valeur minimale de l'échelle des X pour graphe proportionnel (lignes ou points)"
				],
				[
					"xmax",
					"Integer, Date, Time",
					"->",
					"Valeur maximale de l'échelle des X pour graphe proportionnel (lignes ou points)"
				],
				[
					"ymin",
					"Integer",
					"->",
					"Valeur minimale de l'échelle des Y"
				],
				[
					"ymax",
					"Integer",
					"->",
					"Valeur maximale de l'échelle des Y"
				],
				[
					"xprop",
					"Boolean",
					"->",
					"VRAI pour l'échelle des X proportionnelle ; FAUX pour l'échelle des X normale (lignes ou points)"
				],
				[
					"grilleX",
					"Boolean",
					"->",
					"VRAI pour la grille sur l'axe des X ; FAUX pour pas de grille sur l'axe des X (seulement si xprop est VRAI)"
				],
				[
					"grilleY",
					"Boolean",
					"->",
					"VRAI pour la grille sur l'axe des Y; FAUX pour pas de grille sur l'axe des Y"
				],
				[
					"titre",
					"Text",
					"->",
					"Titre(s) pour les titre(s) des série(s)"
				]
			],
			"Summary": "La commande **GRAPH SETTINGS** permet de paramétrer les échelles et les grilles d'un graphe placé dans un formulaire."
		},
		"GRAPH": {
			"Syntax": "**GRAPH** ( *graphImage* ; graphNum | graphParams ; *xCatégories* {; *zValeurs*} {; *zValeurs2* ; ... ; *zValeursN*} )",
			"Params": [
				[
					"graphImage",
					"Picture",
					"->",
					"Variable image"
				],
				[
					"graphNum &#124; graphParams",
					"Entier long, Objet",
					"->",
					"Entier long : Numéro de type de graphe, Objet (64 bits uniquement) : Paramètres du graphe"
				],
				[
					"xCatégories",
					"Array",
					"->",
					"Catégories sur l'axe des x"
				],
				[
					"zValeurs",
					"Array",
					"->",
					"Valeurs à représenter graphiquement (jusqu'à 8 valeurs)"
				]
			],
			"Summary": "La commande **GRAPH** crée un graphe dans une variable image à partir de valeurs provenant de tableaux."
		},
		"HIDE MENU BAR": {
			"Syntax": "**HIDE MENU BAR**",
			"Params": [],
			"Summary": "La commande **HIDE MENU BAR** rend invisible la barre de menus."
		},
		"HIDE PROCESS": {
			"Syntax": "**HIDE PROCESS** ( *process* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro du process à cacher"
				]
			],
			"Summary": "**HIDE PROCESS** masque toutes les fenêtres appartenant au process dont le numéro est *process*."
		},
		"HIDE TOOL BAR": {
			"Syntax": "**HIDE TOOL BAR**",
			"Params": [],
			"Summary": "La commande **HIDE TOOL BAR** permet de gérer l'affichage des barres d'outils personnalisées créées par la commande Open form window pour le process courant."
		},
		"HIDE WINDOW": {
			"Syntax": "**HIDE WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process courant si omis"
				]
			],
			"Summary": "La commande **HIDE WINDOW** permet de masquer la fenêtre dont vous avez passé le numéro de référence dans *fenêtre* ou, si ce paramètre est omis, la fenêtre de premier plan du process courant."
		},
		"HIGHLIGHT RECORDS": {
			"Syntax": "**HIGHLIGHT RECORDS** ( {*laTable* }{;}{ *nomEnsemble* {; *}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle marquer les enregistrements Si omis, table du formulaire courant"
				],
				[
					"nomEnsemble",
					"Text",
					"->",
					"Ensemble d’enregistrements à marquer ou Ensemble Userset si ce paramètre est omis"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Inactiver le défilement automatique de la liste"
				]
			],
			"Summary": "La commande **HIGHLIGHT RECORDS** permet de “surligner” des enregistrements dans un formulaire en liste."
		},
		"HIGHLIGHT TEXT": {
			"Syntax": "**HIGHLIGHT TEXT** ( {* ;} *objet* ; *débutSél* ; *finSél* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) <br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"Field, Variable, any",
					"->",
					"Nom d'objet (si * est spécifié) ou Champ ou variable saisissable (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Nouvelle position de début de sélection de texte"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Nouvelle position de fin de sélection de texte"
				]
			],
			"Summary": "La commande **HIGHLIGHT TEXT** sélectionne une partie du texte dans *objet*."
		},
		"HTTP AUTHENTICATE": {
			"Syntax": "**HTTP AUTHENTICATE** ( *nom* ; *motDePasse* {; *méthodeAuth*} {; *} )",
			"Params": [
				[
					"nom",
					"Text",
					"->",
					"Nom de l’utilisateur"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe de l’utilisateur"
				],
				[
					"méthodeAuth",
					"Integer",
					"->",
					"Méthode d’authentification : 0 ou omis=non définie, 1=BASIC, 2=DIGEST"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : authentification par proxy"
				]
			],
			"Summary": "La commande **HTTP AUTHENTICATE** vous permet d’effectuer des requêtes HTTP vers des serveurs nécessitant l’authentification de l’application cliente."
		},
		"HTTP Get certificates folder": {
			"Syntax": "**HTTP Get certificates folder**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès complet du dossier de certificats actif"
				]
			],
			"Summary": "La commande **HTTP Get certificates folder** retourne le chemin d’accès complet du dossier de certificats client actif."
		},
		"HTTP GET OPTION": {
			"Syntax": "**HTTP GET OPTION** ( *option* ; *valeur* )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Code de l’option à lire"
				],
				[
					"valeur",
					"Integer",
					"<-",
					"Valeur courante de l’option"
				]
			],
			"Summary": "La commande **HTTP GET OPTION** retourne la valeur courante des options HTTP (options utilisées par le client pour la prochaine requête déclenchée par la commande HTTP Get ou HTTP Request)."
		},
		"HTTP Get": {
			"Syntax": "**HTTP Get** ( *url* ; *réponse* {; *nomsEnTêtes* ; *valeursEnTêtes*}{; *} ) : Integer",
			"Params": [
				[
					"url",
					"Text",
					"->",
					"URL auquel envoyer la requête"
				],
				[
					"réponse",
					"Text, Blob, Picture, Object",
					"<-",
					"Résultat de la requête"
				],
				[
					"nomsEnTêtes",
					"Text array",
					"->",
					"Noms des en-têtes de la requête"
				],
				[
					"<-",
					"Noms d’en-têtes retournés"
				],
				[
					"valeursEnTêtes",
					"Text array",
					"->",
					"Valeurs d’en-têtes de la requête"
				],
				[
					"<-",
					"Valeurs d’en-têtes retournées"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé, la connexion est maintenue (keep-alive)<br/>Si omis, la connexion est automatiquement refermée"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code de statut HTTP"
				]
			],
			"Summary": "La commande **HTTP Get** permet d’envoyer directement une requête HTTP GET vers un URL spécifique et de traiter la réponse du serveur HTTP."
		},
		"HTTP Request": {
			"Syntax": "**HTTP Request** ( *méthodeHTTP* ; *url* ; *contenu* ; *réponse* {; *nomsEnTêtes* ; *valeursEnTêtes*}{; *} ) : Integer",
			"Params": [
				[
					"méthodeHTTP",
					"Text",
					"->",
					"Méthode HTTP pour la requête"
				],
				[
					"url",
					"Text",
					"->",
					"URL auquel envoyer la requête"
				],
				[
					"contenu",
					"Text, Blob, Picture, Object",
					"->",
					"Contenu du corps (body) de la requête"
				],
				[
					"réponse",
					"Text, Blob, Picture, Object",
					"<-",
					"Résultat de la requête"
				],
				[
					"nomsEnTêtes",
					"Text array",
					"->",
					"Noms des en-têtes de la requête"
				],
				[
					"<-",
					"Noms d’en-têtes retournés"
				],
				[
					"valeursEnTêtes",
					"Text array",
					"->",
					"Valeurs d’en-têtes de la requête"
				],
				[
					"<-",
					"Valeurs d’en-têtes retournées"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé, la connexion est maintenue (keep-alive)<br/>Si omis, la connexion est automatiquement refermée"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code de statut HTTP"
				]
			],
			"Summary": "La commande **HTTP Request** permet d’envoyer tout type de requête HTTP vers un URL spécifique et de traiter la réponse du serveur HTTP."
		},
		"HTTP SET CERTIFICATES FOLDER": {
			"Syntax": "**HTTP SET CERTIFICATES FOLDER** ( *dossierCertificats* )",
			"Params": [
				[
					"dossierCertificats",
					"Text",
					"->",
					"Chemin d’accès et nom du dossier des certificats du client"
				]
			],
			"Summary": "La commande **HTTP SET CERTIFICATES FOLDER** permet de modifier le dossier de certificats client actif pour l'ensemble des process dans la session courante."
		},
		"HTTP SET OPTION": {
			"Syntax": "**HTTP SET OPTION** ( *option* ; *valeur* )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Code de l’option à fixer"
				],
				[
					"valeur",
					"Integer",
					"->",
					"Valeur de l’option"
				]
			],
			"Summary": "La commande **HTTP SET OPTION** permet de définir différentes options qui seront utilisées lors de la prochaine requête HTTP déclenchée par les commandes HTTP Get ou HTTP Request."
		},
		"IDLE": {
			"Syntax": "**IDLE**",
			"Params": [],
			"Summary": "**IDLE** est destinée uniquement à une utilisation avec le compilateur."
		},
		"IMPORT DATA": {
			"Syntax": "**IMPORT DATA** ( *nomFichier* {; *projet* {; *}} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Chemin d’accès et nom du fichier à importer"
				],
				[
					"projet",
					"Text, Blob",
					"->",
					"Contenu du projet d’import (XML ou référence d'élément DOM ou BLOB)"
				],
				[
					"<-",
					"Nouveau contenu du projet d’import (si le paramètre * a été passé)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Affichage de la boîte de dialogue d’import et mise à jour du projet"
				]
			],
			"Summary": "La commande **IMPORT DATA** permet d’importer des données depuis le fichier *nomFichier*."
		},
		"IMPORT DIF": {
			"Syntax": "**IMPORT DIF** ( {*laTable* ;} *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle effectuer l'import ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document DIF à importer"
				]
			],
			"Summary": "La commande **IMPORT DIF** lit les données de *document* (document DIF Windows ou Mac OS) et les écrit dans la table *laTable* en créant de nouveaux enregistrements."
		},
		"IMPORT STRUCTURE": {
			"Syntax": "**IMPORT STRUCTURE** ( *structureXML* )",
			"Params": [
				[
					"structureXML",
					"Text",
					"->",
					"Définition XML de la structure de la base 4D"
				]
			],
			"Summary": "La commande **IMPORT STRUCTURE** vous permet d'importer, dans la base courante, la définition XML de la structure de la base 4D passée dans le paramètre *structureXML*."
		},
		"IMPORT SYLK": {
			"Syntax": "**IMPORT SYLK** ( {*laTable* ;} *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle effectuer l'import ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document SYLK à importer"
				]
			],
			"Summary": "La commande **IMPORT SYLK** lit les données de *document* (document SYLK Windows ou Mac OS) et les écrit dans la table *laTable* en créant de nouveaux enregistrements."
		},
		"IMPORT TEXT": {
			"Syntax": "**IMPORT TEXT** ( {*laTable* ;} *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle effectuer l'import ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document texte à importer"
				]
			],
			"Summary": "La commande **IMPORT TEXT** lit les données de *document* (document texte Windows ou Mac OS) et les écrit dans la table *laTable* en créant de nouveaux enregistrements."
		},
		"In break": {
			"Syntax": "**In break**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est en rupture"
				]
			],
			"Summary": "**In break** retourne Vrai pour le cycle d'exécution En rupture."
		},
		"In footer": {
			"Syntax": "**In footer**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est en pied"
				]
			],
			"Summary": "**In footer** retourne Vrai pour le cycle d'exécution En pied."
		},
		"In header": {
			"Syntax": "**In header**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est en entête"
				]
			],
			"Summary": "**In header** retourne Vrai pour le cycle d'exécution En entête."
		},
		"In transaction": {
			"Syntax": "**In transaction**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"VRAI si le process courant est en transaction, FAUX sinon"
				]
			],
			"Summary": "La commande **In transaction** retourne Vrai si le process courant est en transaction, sinon elle retourne Faux."
		},
		"INSERT IN ARRAY": {
			"Syntax": "**INSERT IN ARRAY** ( *tableau* ; *positionDépart* {; *combien*} )",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Nom du tableau dans lequel insérer des éléments"
				],
				[
					"positionDépart",
					"Integer",
					"->",
					"Position de départ du ou des élément(s) à insérer"
				],
				[
					"combien",
					"Integer",
					"->",
					"Nombre d'éléments à insérer ou 1 élément si ce paramètre est omis"
				]
			],
			"Summary": "**INSERT IN ARRAY** insère un ou plusieurs éléments ou \"lignes\" dans le tableau *tableau*."
		},
		"INSERT IN BLOB": {
			"Syntax": "**INSERT IN BLOB** ( *blob* ; *décalage* ; *nombre* {; *remplisseur*} )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB dans lequel insérer les octets"
				],
				[
					"décalage",
					"Integer",
					"->",
					"Position de début d'insertion des octets"
				],
				[
					"nombre",
					"Integer",
					"->",
					"Nombre d'octets à insérer"
				],
				[
					"remplisseur",
					"Integer",
					"->",
					"Valeur d'octet par défaut (0x00..0xFF) 0x00 si ce paramètre est omis"
				]
			],
			"Summary": "**INSERT IN BLOB** insère le nombre d'octets spécifié par *nombre* dans le BLOB *blob* à la position spécifiée par *décalage*."
		},
		"INSERT IN LIST": {
			"Syntax": "**INSERT IN LIST** ( {* ;} *liste* ; avantElément | * ; *libelléElément* ; *réfElément* {; sous_Liste ; *déployée*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"avantElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste ou * pour l'élément de la liste actuellement sélectionné"
				],
				[
					"libelléElément",
					"Text",
					"->",
					"Libellé du nouvel élément"
				],
				[
					"réfElément",
					"Integer",
					"->",
					"Numéro de référence unique du nouvel élément"
				],
				[
					"sous_Liste",
					"Integer",
					"->",
					"Sous-liste optionnelle rattachée au nouvel élément"
				],
				[
					"déployée",
					"Boolean",
					"->",
					"Indique si la sous-liste doit être déployée ou non"
				]
			],
			"Summary": "La commande **INSERT IN LIST** insère l'élément désigné par le paramètre *réfElément* dans la liste dont le numéro de référence ou le nom d'objet est passé dans *liste*."
		},
		"INSERT MENU ITEM": {
			"Syntax": "**INSERT MENU ITEM** ( *menu* ; *aprèsLigne* ; *libelléElément* {; *sousMenu* {; *process*}}{; *} )",
			"Params": [
				[
					"menu",
					"Integer",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"aprèsLigne",
					"Integer",
					"->",
					"Numéro de commande de menu"
				],
				[
					"libelléElément",
					"Text",
					"->",
					"Libellé de la ligne de menu à insérer"
				],
				[
					"sousMenu",
					"Text",
					"->",
					"Référence du sous-menu associé à la ligne"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : considérer les métacaractères comme des caractères standard"
				]
			],
			"Summary": "La commande **INSERT MENU ITEM** insère de nouvelles lignes dans le menu dont vous avez passé le numéro ou la référence dans *menu* et les place après la ligne de menu dont le numéro est passé dans *aprèsLigne*."
		},
		"Insert string": {
			"Syntax": "**Insert string** ( *source* ; *insertion* ; *positionDépart* ) : Text",
			"Params": [
				[
					"source",
					"Text",
					"->",
					"Chaîne dans laquelle effectuer l'insertion"
				],
				[
					"insertion",
					"Text",
					"->",
					"Chaîne à insérer dans source"
				],
				[
					"positionDépart",
					"Integer",
					"->",
					"Position de l'insertion"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne résultante"
				]
			],
			"Summary": "**Insert string** insère la chaîne de caractères alphanumériques *insertion* dans la chaîne *source* à partir de *position* et retourne la chaîne de caractères résultante."
		},
		"Int": {
			"Syntax": "**Int** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Valeur dont vous voulez obtenir la partie entière"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Partie entière de nombre"
				]
			],
			"Summary": "**Int** retourne la partie entière de *nombre* en l'arrondissant à l'entier inférieur."
		},
		"INTEGER TO BLOB": {
			"Syntax": "**INTEGER TO BLOB** ( *integer* ; *blob* ; *byteOrder* {; offset} )<br/>**INTEGER TO BLOB** ( *integer* ; *blob* ; *byteOrder* {; *} )",
			"Params": [
				[
					"entier",
					"Integer",
					"->",
					"Valeur entière à écrire dans le BLOB"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB devant recevoir la valeur entière"
				],
				[
					"ordreOctet",
					"Integer",
					"->",
					"0=Ordre des octets en mode natif, 1=Ordre des octets Macintosh, 2=Ordre des octets PC"
				],
				[
					"offset &#124; *",
					"Variable, Opérateur",
					"<->",
					"Offset (en octets) de l'entier dans le BLOB ou * pour ajouter la valeur à la fin du BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après écriture si * omis"
				]
			],
			"Summary": "**INTEGER TO BLOB** écrit la valeur entière (2 octets) *entier* dans le BLOB *blob*."
		},
		"INTEGRATE MIRROR LOG FILE": {
			"Syntax": "**INTEGRATE MIRROR LOG FILE** ( *cheminAccès* ; *numOpération* {; *mode* {; *objErreur*}} )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Nom ou chemin d’accès du fichier d’historique à intégrer"
				],
				[
					"numOpération",
					"Real",
					"->",
					"Numéro de la dernière opération intégrée ou -2 pour tout intégrer"
				],
				[
					"<-",
					"Nouveau numéro de la dernière opération intégrée"
				],
				[
					"mode",
					"Integer",
					"->",
					"0=mode strict (mode par défaut), 1=mode réparation auto"
				],
				[
					"objErreur",
					"Object",
					"<-",
					"Opération(s) manquante(s)"
				]
			],
			"Summary": "**Note préliminaire :** Cette commande ne fonctionne qu’avec 4D Server."
		},
		"INTERSECTION": {
			"Syntax": "**INTERSECTION** ( *ensemble1* ; *ensemble2* ; *résultat* )",
			"Params": [
				[
					"ensemble1",
					"Text",
					"->",
					"Premier ensemble"
				],
				[
					"ensemble2",
					"Text",
					"->",
					"Second ensemble"
				],
				[
					"résultat",
					"Text",
					"->",
					"Ensemble résultant"
				]
			],
			"Summary": "**INTERSECTION** compare *ensemble1* et *ensemble2* et sélectionne uniquement les enregistrements se trouvant à la fois dans *ensemble1* et dans *ensemble2*."
		},
		"INVOKE ACTION": {
			"Syntax": "**INVOKE ACTION** ( *action* {; *cible*} )",
			"Params": [
				[
					"action",
					"Text",
					"->",
					"Nom de l'action standard ou syntaxe avec paramètre si celui-ci est requis"
				],
				[
					"cible",
					"Integer",
					"->",
					"Définit le lieu d'exécution de l'action : le formulaire courant (par défaut) ou le formulaire principal"
				]
			],
			"Summary": "La commande **INVOKE ACTION** déclenche l'action standard définie par le paramètre *action*, optionnellement dans le contexte de la *cible*."
		},
		"Is a list": {
			"Syntax": "**Is a list** ( *liste* ) : Boolean",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Référence de la liste à tester"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si liste est une liste hiérarchique Faux si liste n'est pas une liste hiérarchique"
				]
			],
			"Summary": "La fonction **Is a list** retourne VRAI si la valeur passée dans le paramètre *liste* est une référence valide à une liste hiérarchique."
		},
		"Is a variable": {
			"Syntax": "**Is a variable** ( *pointeur* ) : Boolean",
			"Params": [
				[
					"pointeur",
					"Pointer",
					"->",
					"Pointeur à tester"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"VRAI = Pointeur pointe vers une variable FAUX = Pointeur ne pointe pas vers une variable"
				]
			],
			"Summary": "La fonction **Is a variable** retourne Vrai si le pointeur passé dans le paramètre *pointeur* référence une variable définie."
		},
		"Is compiled mode": {
			"Syntax": "**Is compiled mode** {( * )} : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Retourner l'information de la base hôte"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Mode compilé (Vrai), mode interprété (Faux)"
				]
			],
			"Summary": "La fonction **Is compiled mode** teste si la base tourne en mode compilé (Vrai) ou en mode interprété (Faux)."
		},
		"Is data file locked": {
			"Syntax": "**Is data file locked**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = fichier/segment verrouillé Faux = fichier/segment non verrouillé"
				]
			],
			"Summary": "La commande **Is data file locked** retourne Vrai si le fichier de données de la base ouverte ou l’un de ses segments au moins est verrouillé — c’est-à-dire, protégé en écriture."
		},
		"Is editing text": {
			"Syntax": "**Is editing text**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le texte est en cours de saisie, sinon faux"
				]
			],
			"Summary": "La commande **Is editing text** retourne **Vrai** si l'utilisateur saisit des valeurs dans un objet de formulaire d'entrée, et **Faux** dans tous les autres cas."
		},
		"Is field number valid": {
			"Syntax": "**Is field number valid** ( numTable | ptrTable ; *numChamp* ) : Boolean",
			"Params": [
				[
					"numTable &#124; ptrTable",
					"Entier long, Pointeur",
					"->",
					"Numéro de table ou Pointeur vers une table"
				],
				[
					"numChamp",
					"Integer",
					"->",
					"Numéro de champ"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = le champ existe dans la table, Faux = le champ n’existe pas dans la table"
				]
			],
			"Summary": "La commande **Is field number valid** retourne Vrai si le champ dont le numéro est passé dans *numChamp* existe dans la table dont le numéro ou le pointeur est passé dans le paramètre *numTable* ou *ptrTable*."
		},
		"Is field value Null": {
			"Syntax": "**Is field value Null** ( *leChamp* ) : Boolean",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ à évaluer"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = le champ est NULL, Faux = le champ n'est pas NULL"
				]
			],
			"Summary": "La commande **Is field value Null** retourne Vrai si le champ désigné par le paramètre *leChamp* contient la valeur NULL, et Faux sinon."
		},
		"Is in print preview": {
			"Syntax": "**Is in print preview**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = Impression à l’écran, Faux = Pas d’impression écran"
				]
			],
			"Summary": "La commande **Is in print preview** retourne Vrai si l’option **Aperçu avant impression** est cochée dans la boîte de dialogue d’impression, et Faux sinon."
		},
		"Is in set": {
			"Syntax": "**Is in set** ( *ensemble* ) : Boolean",
			"Params": [
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble à tester"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"L'enregistrement courant est dans l'ensemble (Vrai) ou l'enregistrement courant n'est pas dans l'ensemble (Faux)"
				]
			],
			"Summary": "**Is in set** teste si l'enregistrement courant de la table est inclus dans *ensemble*."
		},
		"Is license available": {
			"Syntax": "**Is license available** {( *licence* )} : Boolean",
			"Params": [
				[
					"licence",
					"Integer",
					"->",
					"Plug-in duquel tester la validité de la licence"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le plug-in est disponible, sinon Faux"
				]
			],
			"Summary": "La commande **Is license available** permet de connaître la disponibilité d’un plug-in."
		},
		"Is macOS": {
			"Syntax": "**Is macOS** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le système d'exploitation est macOS, sinon Faux"
				]
			],
			"Summary": "La commande **Is macOS** retourne Vrai si le système d'exploitation courant est macOS."
		},
		"Is new record": {
			"Syntax": "**Is new record** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l’enregistrement à examiner ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l’enregistrement est en cours de création, Faux sinon"
				]
			],
			"Summary": "La commande **Is new record** retourne Vrai lorsque l’enregistrement courant de *laTable* est en cours de création et n’a pas encore été sauvegardé dans le process courant."
		},
		"Is nil pointer": {
			"Syntax": "**Is nil pointer** ( *pointeur* ) : Boolean",
			"Params": [
				[
					"pointeur",
					"Pointer",
					"->",
					"Pointeur à tester"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"VRAI = Pointeur Nil (->[]) FAUX = Pointeur valide vers un objet existant"
				]
			],
			"Summary": "**Is nil pointer** retourne Vrai si le pointeur que vous passez dans *pointeur* est **Nil** (*\\->\\[\\]*)."
		},
		"Is picture file": {
			"Syntax": "**Is picture file** ( *cheminFichier* {; *} ) : Boolean",
			"Params": [
				[
					"cheminFichier",
					"Text",
					"->",
					"Chemin d’accès de fichier"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Valider les données"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = cheminFichier désigne un fichier image, sinon Faux"
				]
			],
			"Summary": "La commande **Is picture file** teste le fichier désigné par le paramètre *cheminFichier* et retourne Vrai s’il s’agit d’un fichier image valide."
		},
		"Is record loaded": {
			"Syntax": "**Is record loaded** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l’enregistrement à examiner ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l’enregistrement est chargé, Faux sinon"
				]
			],
			"Summary": "La commande **Is record loaded** retourne Vrai si l’enregistrement courant de *laTable* est chargé dans le process en cours."
		},
		"Is table number valid": {
			"Syntax": "**Is table number valid** ( *numTable* ) : Boolean",
			"Params": [
				[
					"numTable",
					"Integer",
					"->",
					"Numéro de table"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = la table existe dans la base, Faux = la table n’existe pas dans la base"
				]
			],
			"Summary": "La commande **Is table number valid** retourne Vrai si la table dont le numéro est passé dans *numTable* existe dans la base et Faux sinon."
		},
		"Is user deleted": {
			"Syntax": "**Is user deleted** ( *réfUtilisateur* ) : Boolean",
			"Params": [
				[
					"réfUtilisateur",
					"Integer",
					"->",
					"Numéro d'identification de l'utilisateur"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = le compte de l'utilisateur est supprimé ou n'existe pas Faux = le compte de l'utilisateur est actif"
				]
			],
			"Summary": "La commande **Is user deleted** teste le compte de l'utilisateur dont le numéro d'identification unique est passé dans *réfUtilisateur*."
		},
		"Is waiting mouse up": {
			"Syntax": "**Is waiting mouse up**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'objet est en attente d'un relâchement souris, Faux sinon"
				]
			],
			"Summary": "La commande **Is waiting mouse up** retourne **Vrai** si l'objet courant a été cliqué et que le bouton de la souris n'a pas été relâché, alors que la fenêtre contenant l'objet a le focus."
		},
		"Is window maximized": {
			"Syntax": "**Is window maximized** ( *window* ) : Boolean",
			"Params": [
				[
					"window",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si la fenêtre est maximisée, sinon Faux"
				]
			],
			"Summary": "La commande **Is window maximized** retourne **Vrai** si la fenêtre dont le numéro de référence est passé dans *window* est actuellement maximisée, et **Faux** dans le cas contraire."
		},
		"Is window reduced": {
			"Syntax": "**Is window reduced** ( *window* ) : Boolean",
			"Params": [
				[
					"window",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si la fenêtre est réduite dans la barre des tâches ou dans le dock, sinon Faux"
				]
			],
			"Summary": "La commande **Is window reduced** retourne **Vrai** si la fenêtre dont le numéro de référence est passé dans *window* est actuellement réduite dans la barre des tâches (Windows) ou dans le dock (macOS), et **Faux** dans le cas contraire."
		},
		"Is Windows": {
			"Syntax": "**Is Windows** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le système d'exploitation est Windows, Sinon Faux"
				]
			],
			"Summary": "La commande **Is Windows** retourne Vrai si le système d'exploitation courant est Windows."
		},
		"JSON PARSE ARRAY": {
			"Syntax": "**JSON PARSE ARRAY** ( *chaîneJSON* ; *tab* )",
			"Params": [
				[
					"chaîneJSON",
					"Text",
					"->",
					"Chaîne en JSON à analyser"
				],
				[
					"tab",
					"Array",
					"<-",
					"Tableau contenant le résultat de l’analyse de la chaîne JSON"
				]
			],
			"Summary": "La commande **JSON PARSE ARRAY** analyse (*parse*) le contenu d’une chaîne formatée en JSON et place les données extraites dans le tableau *tab*."
		},
		"JSON Parse": {
			"Syntax": "**JSON Parse** ( *chaîneJSON* {; *type*}{; *} ) : any",
			"Params": [
				[
					"chaîneJSON",
					"Text",
					"->",
					"Chaîne en JSON à analyser"
				],
				[
					"type",
					"Integer",
					"->",
					"Type dans lequel convertir les valeurs"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Ajouter la ligne et la position de chaque propriété si la valeur retournée est un objet"
				],
				[
					"Résultat",
					"Object, any",
					"<-",
					"Valeurs extraites de la chaîne JSON"
				]
			],
			"Summary": "La commande **JSON Parse** analyse (parse) le contenu d’une chaîne formatée en JSON et en extrait des valeurs que vous pouvez stocker dans un champ ou une variable 4D."
		},
		"JSON Resolve pointers": {
			"Syntax": "**JSON Resolve pointers** ( *objet* {; *options*} ) : Object",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet contenant des pointeurs JSON à résoudre"
				],
				[
					"<-",
					"Objet avec pointeurs JSON résolus (uniquement si Résultat est un objet)"
				],
				[
					"options",
					"Object",
					"->",
					"Options pour la résolution des pointeurs"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contenant le résultat du traitement"
				]
			],
			"Summary": "La commande **JSON Resolve pointers** résout tous les pointeurs JSON présents dans *objet*, en tenant compte des *options* définies (s'il y en a)."
		},
		"JSON Stringify array": {
			"Syntax": "**JSON Stringify array** ( *tab* {; *} ) : Text",
			"Params": [
				[
					"tab",
					"Text array, Real array, Boolean array, Pointer array, Object array",
					"->",
					"Tableau dont le contenu doit être sérialisé"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Améliorer le formatage"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne contenant le tableau JSON sérialisé"
				]
			],
			"Summary": "La commande **JSON Stringify array** convertit le tableau 4D *tab* en un tableau JSON sérialisé."
		},
		"JSON Stringify": {
			"Syntax": "**JSON Stringify** ( *valeur* {; *} ) : Text",
			"Params": [
				[
					"valeur",
					"Object, any",
					"->",
					"Données à convertir en chaîne JSON"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Améliorer la présentation"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne contenant le texte JSON sérialisé"
				]
			],
			"Summary": "La commande **JSON Stringify** convertit le paramètre *valeur* en une chaîne JSON."
		},
		"JSON TO SELECTION": {
			"Syntax": "**JSON TO SELECTION** ( *laTable* ; *jsonTab* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table 4D dans laquelle copier les éléments"
				],
				[
					"jsonTab",
					"Text",
					"->",
					"Tableau d'objets en JSON"
				]
			],
			"Summary": "La commande **JSON TO SELECTION** copie le contenu du tableau d'objets JSON *jsonTab* vers la sélection d’enregistrements de *laTable*."
		},
		"JSON Validate": {
			"Syntax": "**JSON Validate** ( *vJson* ; *vSchema* ) : Object",
			"Params": [
				[
					"vJson",
					"Object",
					"->",
					"Objet JSON à valider"
				],
				[
					"vSchema",
					"Object",
					"->",
					"Schéma JSON utilisé pour valider les objets JSON"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Statut de la validation et erreurs (éventuellement)"
				]
			],
			"Summary": "La commande **JSON Validate** vérifie la conformité des contenus JSON de *vJson* avec les règles définies dans le schéma JSON *vSchema*."
		},
		"Keystroke": {
			"Syntax": "**Keystroke**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Caractère saisi par l'utilisateur"
				]
			],
			"Summary": "**Keystroke** retourne le caractère tapé par l'utilisateur dans un champ ou une zone saisissable."
		},
		"KILL WORKER": {
			"Syntax": "**KILL WORKER** {( *process* )}",
			"Params": [
				[
					"process",
					"Text, Integer",
					"->",
					"Nom ou numéro du process worker à tuer (process courant si omis)"
				]
			],
			"Summary": "La commande **KILL WORKER** envoie un message au process worker dont vous avez passé le nom ou le numéro dans *process*, lui demandant d'ignorer tous les messages en attente (s'il y a) et de terminer son exécution à l'issue de la tâche en cours."
		},
		"Last field number": {
			"Syntax": "**Last field number** ( numTable | ptrTable ) : Integer",
			"Params": [
				[
					"numTable &#124; ptrTable",
					"Entier long, Pointeur",
					"->",
					"Numéro de table ou Pointeur vers une table"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de champ le plus élevé dans la table"
				]
			],
			"Summary": "La commande **Last field number** retourne le numéro de champ le plus élevé parmi les champs de la table dont le numéro ou le pointeur est passé dans le paramètre *numTable* ou *ptrTable*."
		},
		"Last query path": {
			"Syntax": "**Last query path** ( *formatDesc* ) : Text",
			"Params": [
				[
					"formatDesc",
					"Integer",
					"->",
					"Format de description (Texte ou XML)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Description du chemin de la dernière recherche exécutée"
				]
			],
			"Summary": "La commande **Last query path** retourne la description interne détaillée du chemin réel de la dernière recherche effectuée sur les données."
		},
		"Last query plan": {
			"Syntax": "**Last query plan** ( *formatDesc* ) : Text",
			"Params": [
				[
					"formatDesc",
					"Integer",
					"->",
					"Format de description (Texte ou XML)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Description du plan de la dernière recherche exécutée"
				]
			],
			"Summary": "La commande **Last query plan** retourne la description interne du plan d’exécution prévu pour la dernière recherche effectuée sur les données."
		},
		"LAST RECORD": {
			"Syntax": "**LAST RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle vous voulez aller au dernier enregistrement ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**LAST RECORD** désigne le dernier enregistrement de la sélection de *laTable* comme enregistrement courant et le charge en mémoire."
		},
		"Last table number": {
			"Syntax": "**Last table number**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de table le plus élevé dans la base"
				]
			],
			"Summary": "**Last table number** retourne le numéro de table le plus élevé parmi les tables de la base."
		},
		"Last update log path": {
			"Syntax": "**Get last update log path** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès du journal de mise à jour le plus récent"
				]
			],
			"Summary": "La commande **Get last update log path** retourne le chemin d’accès complet du fichier journal de mise à jour le plus récent sur le poste où elle est appelée."
		},
		"LAUNCH EXTERNAL PROCESS": {
			"Syntax": "**LAUNCH EXTERNAL PROCESS** ( *nomFichier* {; *fluxEntrée* {; *fluxSortie* {; *fluxErreur*}}}{; *pid*} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Chemin d’accès et arguments du fichier à lancer"
				],
				[
					"fluxEntrée",
					"Text, Blob",
					"->",
					"Flux d’entrée (stdin)"
				],
				[
					"fluxSortie",
					"Text, Blob",
					"<-",
					"Flux de sortie (stdout)"
				],
				[
					"fluxErreur",
					"Text, Blob",
					"<-",
					"Flux d’erreur (stderr)"
				],
				[
					"pid",
					"Integer",
					"<-",
					"Identifiant unique du process externe"
				]
			],
			"Summary": "À partir de 4D v19 R4, nous recommandons l'utilisation de la classe `4D.SystemWorker class` pour exécuter et contrôler les process externes."
		},
		"LDAP LOGIN": {
			"Syntax": "**LDAP LOGIN** ( *url* ; *login* ; *motDePasse* {; *digest*} )",
			"Params": [
				[
					"url",
					"Text",
					"->",
					"URL du serveur LDAP auquel se connecter"
				],
				[
					"login",
					"Text",
					"->",
					"Compte de l'utilisateur"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe de l’utilisateur"
				],
				[
					"digest",
					"Integer",
					"->",
					"0 = envoyer mot de passe en digest MD5 (défaut), 1 = envoyer mot de passe sans encryptage"
				]
			],
			"Summary": "La commande **LDAP LOGIN** ouvre une connexion en lecture seule sur le serveur LDAP désigné par le paramètre *url* avec les identifiants *login* et *motDePasse* fournis."
		},
		"LDAP LOGOUT": {
			"Syntax": "**LDAP LOGOUT**",
			"Params": [],
			"Summary": "La commande **LDAP LOGOUT** referme la connexion LDAP active dans le process courant (le cas échéant)."
		},
		"LDAP SEARCH ALL": {
			"Syntax": "**LDAP SEARCH ALL** ( *dnRootEntry* ; *tabRésultat* ; *filtre* {; *scope* {; *attributs* {; *attributsEnTableau*}}} )",
			"Params": [
				[
					"dnRootEntry",
					"Text",
					"->",
					"Distinguished Name de l'élément racine où démarrer la recherche"
				],
				[
					"tabRésultat",
					"Object array",
					"<-",
					"Résultat de la recherche"
				],
				[
					"filtre",
					"Text",
					"->",
					"Filtre de recherche LDAP"
				],
				[
					"scope",
					"Text",
					"->",
					"Champ d'action de la recherche : \"base\" (défaut), \"one\" ou \"sub\""
				],
				[
					"attributs",
					"Text array",
					"->",
					"Attribut(s) à récupérer"
				],
				[
					"attributsEnTableau",
					"Boolean array",
					"->",
					"Vrai = forcer le retour des attributs en tableaux, Faux = forcer le retour des attributs en variables simples"
				]
			],
			"Summary": "La commande **LDAP SEARCH ALL** recherche sur le server LDAP cible toutes les occurrences correspondant aux critères définis."
		},
		"LDAP Search": {
			"Syntax": "**LDAP Search** ( *dnRootEntry* ; *filtre* {; *scope* {; *attributs* {; *attributsEnTableau*}}} ) : Object",
			"Params": [
				[
					"dnRootEntry",
					"Text",
					"->",
					"Distinguished Name de l'élément racine où démarrer la recherche"
				],
				[
					"filtre",
					"Text",
					"->",
					"Filtre de recherche LDAP"
				],
				[
					"scope",
					"Text",
					"->",
					"Champ d'action de la recherche : \"base\" (défaut), \"one\" ou \"sub\""
				],
				[
					"attributs",
					"Text array",
					"->",
					"Attribut(s) à récupérer"
				],
				[
					"attributsEnTableau",
					"Boolean array",
					"->",
					"Vrai = forcer le retour des attributs en tableaux, Faux = forcer le retour des attributs en variables simples"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Attributs clé/valeur"
				]
			],
			"Summary": "La commande **LDAP Search** recherche sur le serveur LDAP cible la première occurrence correspondant aux critères définis."
		},
		"Length": {
			"Syntax": "**Length** ( *chaîne* ) : Integer",
			"Params": [
				[
					"chaîne",
					"Text",
					"->",
					"Chaîne dont vous voulez connaître la longueur"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de caractères de chaîne"
				]
			],
			"Summary": "**Length** vous permet d'obtenir la longueur de *laChaîne*."
		},
		"Level": {
			"Syntax": "**Level**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Niveau de rupture ou d'en-tête courant"
				]
			],
			"Summary": "La fonction **Level** sert à déterminer le niveau de rupture ou d'en-tête courant."
		},
		"License usage": {
			"Syntax": "**License usage** : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Une collection d'objets contenant des informations sur les licences utilisées"
				]
			],
			"Summary": "La commande **License usage** retourne une collection d'objets contenant des informations sur les licences utilisées\\[#/descv\\]."
		},
		"List item parent": {
			"Syntax": "**List item parent** ( {* ;} *liste* ; refElément | * ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Opérateur, Entier long",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste ou * pour l'élément courant de la liste"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de l'élément parent ou 0 s'il n'y en a pas"
				]
			],
			"Summary": "La commande **List item parent** retourne le numéro de référence de l'élément parent."
		},
		"List item position": {
			"Syntax": "**List item position** ( {* ;} *liste* ; *réfElément* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"réfElément",
					"Integer",
					"->",
					"Numéro de référence d'élément"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Position de l'élément parmi la ou les liste(s) déployée(s)/contractée(s)"
				]
			],
			"Summary": "La commande **List item position** retourne la position de l'élément dont vous avez passé le numéro de référence dans *réfElément* parmi la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"LIST OF CHOICE LISTS": {
			"Syntax": "**LIST OF CHOICE LISTS** ( *tabNums* ; *tabNoms* )",
			"Params": [
				[
					"tabNums",
					"Integer array",
					"<-",
					"Numéros des énumérations"
				],
				[
					"tabNoms",
					"Text array",
					"<-",
					"Noms des énumérations"
				]
			],
			"Summary": "La commande **LIST OF CHOICE LISTS** retourne dans les tableaux synchronisés *tabNums* et *tabNoms* les numéros et les noms des énumérations définies dans l’éditeur d’énumérations en mode Développement."
		},
		"LIST OF STYLE SHEETS": {
			"Syntax": "**LIST OF STYLE SHEETS** ( *tabFeuillesStyle* )",
			"Params": [
				[
					"tabFeuillesStyle",
					"Text array",
					"<-",
					"Noms des feuilles de style définies dans l’application"
				]
			],
			"Summary": "La commande **LIST OF STYLE SHEETS** retourne la liste des feuilles de style de l’application dans le tableau *tabFeuillesStyle*."
		},
		"LIST TO ARRAY": {
			"Syntax": "**LIST TO ARRAY** ( *liste* ; *tableau* {; *réfEléments*} )",
			"Params": [
				[
					"liste",
					"Text, Integer",
					"->",
					"Nom ou référence de la liste de laquelle copier les éléments du premier niveau"
				],
				[
					"tableau",
					"Array",
					"<-",
					"Tableau dans lequel copier les éléments de la liste"
				],
				[
					"réfEléments",
					"Array",
					"<-",
					"Numéros de référence des éléments de la liste"
				]
			],
			"Summary": "La commande **LIST TO ARRAY** crée ou remplace le tableau *tableau* avec les éléments du premier niveau de la liste ou de l'énumération *liste*."
		},
		"LIST TO BLOB": {
			"Syntax": "**LIST TO BLOB** ( *liste* ; *blob* {; *blob*} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Liste hiérarchique à stocker dans le BLOB"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB devant recevoir la liste hiérarchique"
				],
				[
					"blob",
					"*",
					"->",
					"Ajouter la liste à la fin du BLOB"
				]
			],
			"Summary": "La commande **LIST TO BLOB** stocke la liste hiérarchique *liste* dans le BLOB *blob*."
		},
		"LISTBOX COLLAPSE": {
			"Syntax": "**LISTBOX COLLAPSE** ( {* ;} *objet* {; *récursive* {; *sélecteur* {; *ligne* {; *colonne*}}}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable (si * omis)"
				],
				[
					"récursive",
					"Boolean",
					"->",
					"Vrai = contracter les sous-niveaux, Faux = ne pas contracter les sous-niveaux"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Partie de la list box à contracter"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne de la rupture à contracter ou Numéro de niveau de la list box à contracter"
				],
				[
					"colonne",
					"Integer",
					"->",
					"Numéro de colonne de la rupture à contracter"
				]
			],
			"Summary": "La commande **LISTBOX COLLAPSE** vous permet de provoquer la contraction des lignes de rupture de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX DELETE COLUMN": {
			"Syntax": "**LISTBOX DELETE COLUMN** ( {* ;} *objet* ; *positionCol* {; *nombre*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"positionCol",
					"Integer",
					"->",
					"Numéro courant de la colonne à supprimer"
				],
				[
					"nombre",
					"Integer",
					"->",
					"Nombre de colonnes à supprimer"
				]
			],
			"Summary": "La commande **LISTBOX DELETE COLUMN** supprime une ou plusieurs colonne(s) (visibles ou non) dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX DELETE ROWS": {
			"Syntax": "**LISTBOX DELETE ROWS** ( {* ;} *objet* ; *positionLigne* {; *nbLignes*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"positionLigne",
					"Integer",
					"->",
					"Numéro de la première ligne à supprimer"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à supprimer"
				]
			],
			"Summary": "La commande **LISTBOX DELETE ROWS** supprime une ou plusieurs ligne(s) à partir de la ligne numéro *positionLigne* (visible ou non) de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX DUPLICATE COLUMN": {
			"Syntax": "**LISTBOX DUPLICATE COLUMN** ( {* ;} *objet* ; *positionCol* ; *nomCol* ; *variableCol* ; *nomEntête* ; *varEntête* {; *nomPied* ; *variablePied*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis) de la colonne à dupliquer"
				],
				[
					"positionCol",
					"Integer",
					"->",
					"Emplacement de la nouvelle colonne dupliquée"
				],
				[
					"nomCol",
					"Text",
					"->",
					"Nom de la nouvelle colonne"
				],
				[
					"variableCol",
					"Array, Field, Variable, Pointer",
					"->",
					"Nom de la variable tableau de la colonne ou champ ou variable"
				],
				[
					"nomEntête",
					"Text",
					"->",
					"Nom d’objet de l’en-tête de la colonne"
				],
				[
					"varEntête",
					"Integer, Pointer",
					"->",
					"Variable d’en-tête de la colonne"
				],
				[
					"nomPied",
					"Text",
					"->",
					"Nom d’objet du pied de la colonne"
				],
				[
					"variablePied",
					"Variable, Pointer",
					"->",
					"Variable du pied de la colonne"
				]
			],
			"Summary": "La commande **LISTBOX DUPLICATE COLUMN** permet de dupliquer la colonne désignée par le(s) paramètre(s) *objet* et *\\** dans le contexte du formulaire en cours d’exécution (mode Application)."
		},
		"LISTBOX EXPAND": {
			"Syntax": "**LISTBOX EXPAND** ( {* ;} *objet* {; *récursive* {; *sélecteur* {; *ligne* {; *colonne*}}}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"récursive",
					"Boolean",
					"->",
					"Vrai = déployer les sous-niveaux, Faux = ne pas déployer les sous-niveaux"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Partie de la list box à déployer"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne de la rupture à déployer ou Numéro de niveau de la list box à déployer"
				],
				[
					"colonne",
					"Integer",
					"->",
					"Numéro de colonne de la rupture à déployer"
				]
			],
			"Summary": "La commande **LISTBOX EXPAND** vous permet de provoquer le déploiement des lignes de rupture de l’objet list box affiché en mode hiérarchique désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get array": {
			"Syntax": "**LISTBOX Get array** ( {* ;} *objet* ; *typeTab* ) : Pointer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"typeTab",
					"Integer",
					"->",
					"Type de tableau"
				],
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers le tableau associé à la propriété"
				]
			],
			"Summary": "**Note :** Cette commande fonctionne uniquement avec les list box de type tableau."
		},
		"LISTBOX GET ARRAYS": {
			"Syntax": "**LISTBOX GET ARRAYS** ( {* ;} *objet* ; *tabNomsCols* ; *tabNomsEntêtes* ; *tabVarCols* ; *tabVarEntêtes* ; *tabColsVisibles* ; *tabStyles* {; *tabNomsPieds* ; *tabVarPieds*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabNomsCols",
					"Text array",
					"<-",
					"Noms d’objet des colonnes"
				],
				[
					"tabNomsEntêtes",
					"Text array",
					"<-",
					"Noms d’objet des en-têtes"
				],
				[
					"tabVarCols",
					"Pointer array",
					"<-",
					"Pointeurs vers les variables des colonnes ou Pointeurs vers les champs des colonnes ou Nil"
				],
				[
					"tabVarEntêtes",
					"Pointer array",
					"<-",
					"Pointeurs vers les variables des en-têtes"
				],
				[
					"tabColsVisibles",
					"Boolean array",
					"<-",
					"Visibilité de chaque colonne"
				],
				[
					"tabStyles",
					"Pointer array",
					"<-",
					"Pointeurs vers les tableaux ou les variables de styles de couleurs et de contrôle des lignes ou Nil"
				],
				[
					"tabNomsPieds",
					"Text array",
					"<-",
					"Noms d’objet des pieds de colonnes"
				],
				[
					"tabVarPieds",
					"Pointer array",
					"<-",
					"Pointeurs vers les variables des pieds de colonnes"
				]
			],
			"Summary": "La commande **LISTBOX GET ARRAYS** retourne un ensemble de tableaux synchronisés fournissant diverses informations sur chaque colonne (visible ou non) de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get auto row height": {
			"Syntax": "**LISTBOX Get auto row height** ( {* ;} *objet* ; *sélecteur* {; *unité*} )  : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (une chaîne). Si omis, objet est une variable."
				],
				[
					"objet",
					"any",
					"->",
					"Nom de l'objet (si * est spécifié) ou variable (si * est omis)"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Valeur de hauteur à lire : lk hauteur ligne min ou lk hauteur ligne max"
				],
				[
					"unité",
					"Integer",
					"->",
					"Valeur d'unité de hauteur : 0 = pixels, 1 = lignes"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de la limite de hauteur de ligne sélectionnée"
				]
			],
			"Summary": "La commande **LISTBOX Get auto row height** retourne la limite minimum ou maximum de hauteur de ligne automatique définie pour l'objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET CELL COORDINATES": {
			"Syntax": "**LISTBOX GET CELL COORDINATES** ( {* ;} *objet* ; *colonne* ; *ligne* ; *gauche* ; *haut* ; *droite* ; *bas* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"colonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"gauche",
					"Integer",
					"<-",
					"Coordonnée gauche de l'objet"
				],
				[
					"haut",
					"Integer",
					"<-",
					"Coordonnée supérieure de l’objet"
				],
				[
					"droite",
					"Integer",
					"<-",
					"Coordonnée droite de l’objet"
				],
				[
					"bas",
					"Integer",
					"<-",
					"Coordonnée inférieure de l’objet"
				]
			],
			"Summary": "La commande **LISTBOX GET CELL COORDINATES** retourne dans les variables ou champs *gauche*, *haut*, *droite* et *bas* les coordonnées (en points) de la cellule désignée par les paramètres *colonne* et *ligne* dans la list box définie par *\\** et *objet*."
		},
		"LISTBOX GET CELL POSITION": {
			"Syntax": "**LISTBOX GET CELL POSITION** ( {* ;} *objet* {; *x* ; *y* }; *colonne* ; *ligne* {; *varCol*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"x",
					"Real",
					"->",
					"Coordonnée horizontale de la souris"
				],
				[
					"y",
					"Real",
					"->",
					"Coordonnée verticale de la souris"
				],
				[
					"colonne",
					"Integer",
					"<-",
					"Numéro de colonne"
				],
				[
					"ligne",
					"Integer",
					"<-",
					"Numéro de ligne"
				],
				[
					"varCol",
					"Pointer",
					"<-",
					"Pointeur sur la variable de colonne"
				]
			],
			"Summary": "La commande **LISTBOX GET CELL POSITION** retourne les numéros de la *colonne* et de la *ligne* correspondant à l’emplacement du dernier clic ou de la dernière action de sélection effectuée dans la list box désignée par *\\** et objet."
		},
		"LISTBOX Get column formula": {
			"Syntax": "**LISTBOX Get column formula** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Formule associée à la colonne"
				]
			],
			"Summary": "La commande **LISTBOX Get column formula** retourne la formule associée à la colonne de list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get column width": {
			"Syntax": "**LISTBOX Get column width** ( {* ;} *objet* {; *largeurMini* {; *largeurMaxi*}} )  : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"largeurMini",
					"Integer",
					"<-",
					"Largeur minimale de la colonne (en pixels)"
				],
				[
					"largeurMaxi",
					"Integer",
					"<-",
					"Largeur maximale de la colonne (en pixels)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Largeur de colonne en pixels"
				]
			],
			"Summary": "La commande **LISTBOX Get column width** retourne la largeur (en pixels) de la colonne de list box désignée par les paramètres *objet* et *\\** ."
		},
		"LISTBOX Get footer calculation": {
			"Syntax": "**LISTBOX Get footer calculation** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type de calcul"
				]
			],
			"Summary": "La commande **LISTBOX Get footer calculation** retourne le type de calcul associé à la zone de pied de list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get footers height": {
			"Syntax": "**LISTBOX Get footers height** ( {* ;} *objet* {; *unité*} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"unité",
					"Integer",
					"->",
					"Unité de la valeur de hauteur : <br/>0 ou omis = pixels, 1 = lignes"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur de la ligne"
				]
			],
			"Summary": "La commande **LISTBOX Get footers height** retourne la hauteur de la ligne de pied de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET GRID COLORS": {
			"Syntax": "**LISTBOX GET GRID COLORS** ( {* ;} *objet* ; *couleurH* ; *couleurV* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"couleurH",
					"Text, Integer",
					"<-",
					"Valeur de couleur RVB pour les traits horizontaux"
				],
				[
					"couleurV",
					"Text, Integer",
					"<-",
					"Valeur de couleur RVB pour les traits verticaux"
				]
			],
			"Summary": "La commande **LISTBOX GET GRID COLORS** retourne la couleur des lignes horizontales et verticales composant la grille de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET GRID": {
			"Syntax": "**LISTBOX GET GRID** ( {* ;} *objet* ; *horizontal* ; *vertical* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"horizontal",
					"Boolean",
					"<-",
					"Vrai = affichée, Faux = cachée"
				],
				[
					"vertical",
					"Boolean",
					"<-",
					"Vrai = affichée, Faux = cachée"
				]
			],
			"Summary": "La commande **LISTBOX GET GRID** retourne le statut affiché/masqué des lignes horizontales et/ou verticales composant la grille de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get headers height": {
			"Syntax": "**LISTBOX Get headers height** ( {* ;} *objet* {; *unité*} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"unité",
					"Integer",
					"->",
					"Unité de la valeur de hauteur : <br/>0 ou omis = pixels, 1 = lignes"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur de la ligne"
				]
			],
			"Summary": "La commande **LISTBOX Get headers height** retourne la hauteur de la ligne d’en-tête de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET HIERARCHY": {
			"Syntax": "**LISTBOX GET HIERARCHY** ( {* ;} *objet* ; *hiérarchique* {; *hiérarchie*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"hiérarchique",
					"Boolean",
					"<-",
					"Vrai = list box hiérarchique, Faux = list box non hiérarchique"
				],
				[
					"hiérarchie",
					"Pointer array",
					"<-",
					"Tableau de pointeurs"
				]
			],
			"Summary": "La commande **LISTBOX GET HIERARCHY** vous permet de connaître les propriétés hiérarchiques de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get locked columns": {
			"Syntax": "**LISTBOX Get locked columns** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de colonnes verrouillées"
				]
			],
			"Summary": "La commande **LISTBOX Get locked columns** retourne le nombre de colonnes verrouillées dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get number of columns": {
			"Syntax": "**LISTBOX Get number of columns** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de colonnes"
				]
			],
			"Summary": "La commande **LISTBOX Get number of columns** retourne le nombre total de colonnes (visibles ou non) présentes dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get number of rows": {
			"Syntax": "**LISTBOX Get number of rows** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de lignes"
				]
			],
			"Summary": "La commande **LISTBOX Get number of rows** retourne le nombre de lignes présentes dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET OBJECTS": {
			"Syntax": "**LISTBOX GET OBJECTS** ( {* ;} *objet* ; *tabNomsObj* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabNomsObj",
					"Text array",
					"<-",
					"Noms des sous-objets de la list box (en-têtes, colonnes, pieds)"
				]
			],
			"Summary": "La commande **LISTBOX GET OBJECTS** retourne un tableau contenant les noms de chaque objet composant la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET PRINT INFORMATION": {
			"Syntax": "**LISTBOX GET PRINT INFORMATION** ( {* ;} *objet* ; *sélecteur* ; *info* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable (si * omis)"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Information à obtenir"
				],
				[
					"info",
					"Integer",
					"<-",
					"Valeur courante"
				]
			],
			"Summary": "La commande LISTBOX GET PRINT INFORMATION retourne des informations courantes relatives à l’impression de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get row color as number": {
			"Syntax": "**LISTBOX Get row color as number** ( {* ;} *objet* ; *ligne* {; *typeCouleur*} )  : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"typeCouleur",
					"Integer",
					"->",
					"lk couleur de police (défaut) ou lk couleur de fond"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de couleur"
				]
			],
			"Summary": "**Note :** Cette commande fonctionne uniquement avec les list box de type tableau."
		},
		"LISTBOX Get row color": {
			"Syntax": "**LISTBOX Get row color** ( {* ;} *objet* ; *ligne* {; *typeCouleur*} )  : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, l'objet est un nom d'objet (chaîne). Si omis, l'objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"typeCouleur",
					"Integer",
					"->",
					"Couleur de police de la listbox (par défaut) ou couleur de fond de la listbox"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur de la couleur"
				]
			],
			"Summary": "**Note :** Cette commande ne fonctionne qu'avec les list box de type tableau."
		},
		"LISTBOX Get row font style": {
			"Syntax": "**LISTBOX Get row font style** ( {* ;} *objet* ; *ligne* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de style"
				]
			],
			"Summary": "**Note :** Cette commande fonctionne uniquement avec les list box de type tableau."
		},
		"LISTBOX Get row height": {
			"Syntax": "**LISTBOX Get row height** ( {* ;} *objet* ; *ligne* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Ligne de la List box dont on veut récupérer la hauteur"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur de la ligne"
				]
			],
			"Summary": "La commande **LISTBOX Get row height** retourne la hauteur de la *ligne* spécifiée dans l'objet List box désigné en utilisant les paramètres *objet* et éventuellement *\\**."
		},
		"LISTBOX Get rows height": {
			"Syntax": "**LISTBOX Get rows height** ( {* ;} *objet* {; *unité*} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"unité",
					"Integer",
					"->",
					"Unité de la valeur de hauteur : <br/>0 ou omis = pixels, 1 = lignes"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur de ligne en pixels"
				]
			],
			"Summary": "La commande **LISTBOX Get rows height** retourne la hauteur courante des lignes de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX Get static columns": {
			"Syntax": "**LISTBOX Get static columns** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de colonnes statiques"
				]
			],
			"Summary": "La commande **LISTBOX Get static columns** retourne le nombre de colonnes statiques dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX GET TABLE SOURCE": {
			"Syntax": "**LISTBOX GET TABLE SOURCE** ( {* ;} *objet* ; *numTable* {; *nom* {; *nomSurlignage*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"numTable",
					"Integer",
					"<-",
					"Numéro de la table de la sélection"
				],
				[
					"nom",
					"Text",
					"<-",
					"Nom de la sélection temporaire ou \"\" pour la sélection courante"
				],
				[
					"nomSurlignage",
					"Text",
					"<-",
					"Nom de l’ensemble de surlignage"
				]
			],
			"Summary": "La commande **LISTBOX GET TABLE SOURCE** permet de connaître la source courante des données affichées dans la list box désignée par les paramètres *\\** et *objet*."
		},
		"LISTBOX INSERT COLUMN FORMULA": {
			"Syntax": "**LISTBOX INSERT COLUMN FORMULA** ( {* ;} *objet* ; *positionCol* ; *nomCol* ; *formule* ; *typeDonnées* ; *nomEnTête* ; *variableEntête* {; *nomPied* ; *variablePied*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"positionCol",
					"Integer",
					"->",
					"Emplacement de la colonne à insérer"
				],
				[
					"nomCol",
					"Text",
					"->",
					"Nom d’objet de la colonne"
				],
				[
					"formule",
					"Text",
					"->",
					"Formule 4D associée à la colonne"
				],
				[
					"typeDonnées",
					"Integer",
					"->",
					"Type de résultat de la formule"
				],
				[
					"nomEnTête",
					"Text",
					"->",
					"Nom d'objet de l'en-tête de la colonne"
				],
				[
					"variableEntête",
					"Integer, Pointer",
					"->",
					"Variable d'en-tête de la colonne"
				],
				[
					"nomPied",
					"Text",
					"->",
					"Nom d’objet du pied de la colonne"
				],
				[
					"variablePied",
					"Variable, Pointer",
					"->",
					"Variable du pied de la colonne"
				]
			],
			"Summary": "La commande **LISTBOX INSERT COLUMN FORMULA** insère une colonne dans la list box désignée par les paramètres *objet* et *\\** ."
		},
		"LISTBOX INSERT COLUMN": {
			"Syntax": "**LISTBOX INSERT COLUMN** ( {* ;} *objet* ; *positionCol* ; *nomCol* ; *variableCol* ; *nomEnTête* ; *variableEntête* {; *nomPied* ; *variablePied*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"positionCol",
					"Integer",
					"->",
					"Emplacement de la colonne à insérer"
				],
				[
					"nomCol",
					"Text",
					"->",
					"Nom d’objet de la colonne"
				],
				[
					"variableCol",
					"Array, Field, Variable, Pointer",
					"->",
					"Nom de la variable tableau de la colonne ou champ ou variable"
				],
				[
					"nomEnTête",
					"Text",
					"->",
					"Nom d’objet de l’en-tête de la colonne"
				],
				[
					"variableEntête",
					"Integer, Pointer",
					"->",
					"Variable d’en-tête de la colonne"
				],
				[
					"nomPied",
					"Text",
					"->",
					"Nom d’objet du pied de la colonne"
				],
				[
					"variablePied",
					"Variable, Pointer",
					"->",
					"Variable du pied de la colonne"
				]
			],
			"Summary": "La commande **LISTBOX INSERT COLUMN** insère une colonne dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX INSERT ROWS": {
			"Syntax": "**LISTBOX INSERT ROWS** ( {* ;} *objet* ; *positionLigne* {; *nbLignes*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"positionLigne",
					"Integer",
					"->",
					"Emplacement de la ligne à insérer"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à insérer"
				]
			],
			"Summary": "La commande **LISTBOX INSERT ROWS** insère une ou plusieurs nouvelle(s) ligne(s) dans l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX MOVE COLUMN": {
			"Syntax": "**LISTBOX MOVE COLUMN** ( {* ;} *objet* ; *positionCol* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis) de la colonne à déplacer"
				],
				[
					"positionCol",
					"Integer",
					"->",
					"Nouvel emplacement de la colonne"
				]
			],
			"Summary": "La commande **LISTBOX MOVE COLUMN** permet de déplacer par programmation la colonne désignée par le(s) paramètre(s) *objet* et *\\** dans le contexte du formulaire en cours d’exécution (mode Application)."
		},
		"LISTBOX MOVED COLUMN NUMBER": {
			"Syntax": "**LISTBOX MOVED COLUMN NUMBER** ( {* ;} *objet* ; *ancPosition* ; *nouvPosition* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ancPosition",
					"Integer",
					"<-",
					"Ancienne position de la colonne déplacée"
				],
				[
					"nouvPosition",
					"Integer",
					"<-",
					"Nouvelle position de la colonne déplacée"
				]
			],
			"Summary": "La commande **LISTBOX MOVED COLUMN NUMBER** retourne dans les paramètres *ancPosition* et *nouvPosition* des numéros indiquant respectivement la précédente position et la nouvelle position de la colonne déplacée dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX MOVED ROW NUMBER": {
			"Syntax": "**LISTBOX MOVED ROW NUMBER** ( {* ;} *objet* ; *ancPosition* ; *nouvPosition* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ancPosition",
					"Integer",
					"<-",
					"Précédente position de la ligne déplacée"
				],
				[
					"nouvPosition",
					"Integer",
					"<-",
					"Nouvelle position de la ligne déplacée"
				]
			],
			"Summary": "La commande **LISTBOX MOVED ROW NUMBER** retourne dans les paramètres *ancPosition* et *nouvPosition* des numéros indiquant respectivement la précédente position et la nouvelle position de la ligne déplacée dans la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SELECT BREAK": {
			"Syntax": "**LISTBOX SELECT BREAK** ( {* ;} *objet* ; *ligne* ; *colonne* {; *action*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable (si * omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne de la rupture"
				],
				[
					"colonne",
					"Integer",
					"->",
					"Numéro de colonne de la rupture"
				],
				[
					"action",
					"Integer",
					"->",
					"Action de sélection"
				]
			],
			"Summary": "La commande **LISTBOX SELECT BREAK** permet de sélectionner des lignes de rupture dans l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SELECT ROW": {
			"Syntax": "**LISTBOX SELECT ROW** ( {* ;} *objet* ; *positionLigne* {; *action*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"positionLigne",
					"Integer",
					"->",
					"Numéro de la ligne à sélectionner"
				],
				[
					"action",
					"Integer",
					"->",
					"Action de sélection"
				]
			],
			"Summary": "La commande **LISTBOX SELECT ROW** provoque la sélection de la ligne de numéro *positionLigne* dans l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SELECT ROWS": {
			"Syntax": "**LISTBOX SELECT ROWS** ( {* ;} *objet* ; *sélection* {; *action*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, l'objet est un nom d'objet (chaîne). Si omis, l'objet est une variable."
				],
				[
					"objet",
					"any",
					"->",
					"Nom de l'objet (si * est spécifié) ou Variable (si * est spécifié)"
				],
				[
					"sélection",
					"Object, Collection",
					"->",
					"Objet ou collection décrivant les lignes à sélectionner"
				],
				[
					"action",
					"Integer",
					"->",
					"lk remplacer sélection (omis par défaut), lk ajouter à sélection, lk supprimer de sélection"
				]
			],
			"Summary": "La commande **LISTBOX SELECT ROWS**  provoque la sélection des lignes d'une list box entity selection ou une list box collection correspondant aux entités ou objets contenus dans le paramètre *sélection*."
		},
		"LISTBOX SET ARRAY": {
			"Syntax": "**LISTBOX SET ARRAY** ( {* ;} *objet* ; *typeTab* ; *ptrTab* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"typeTab",
					"Integer",
					"->",
					"Type de tableau"
				],
				[
					"ptrTab",
					"Pointer",
					"->",
					"Tableau à associer à la propriété"
				]
			],
			"Summary": "**Note :** Cette commande fonctionne uniquement avec les list box de type tableau."
		},
		"LISTBOX SET AUTO ROW HEIGHT": {
			"Syntax": "**LISTBOX SET AUTO ROW HEIGHT** ( {* ;} *objet* ; *sélecteur* ; *valeur* ; *unité* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Limite de hauteur à définir : lk hauteur ligne min ou lk hauteur ligne max"
				],
				[
					"valeur",
					"Integer",
					"->",
					"Hauteur de ligne minimum ou maximum"
				],
				[
					"unité",
					"Integer",
					"->",
					"Valeur d'unité de hauteur : 0 = pixels, 1 = lignes"
				]
			],
			"Summary": "La commande **LISTBOX SET AUTO ROW HEIGHT** vous permet de définir une *valeur* de hauteur minimum ou maximum dans l'objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET COLUMN FORMULA": {
			"Syntax": "**LISTBOX SET COLUMN FORMULA** ( {* ;} *objet* ; *formule* ; *typeDonnées* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"formule",
					"Text",
					"->",
					"Formule 4D associée à la colonne"
				],
				[
					"typeDonnées",
					"Integer",
					"->",
					"Type de résultat de la formule"
				]
			],
			"Summary": "La commande **LISTBOX SET COLUMN FORMULA** permet de modifier la *formule* associée à la colonne de list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET COLUMN WIDTH": {
			"Syntax": "**LISTBOX SET COLUMN WIDTH** ( {* ;} *objet* ; *largeur* {; *largeurMini* {; *largeurMaxi*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"largeur",
					"Integer",
					"->",
					"Largeur de colonne (en pixels)"
				],
				[
					"largeurMini",
					"Integer",
					"->",
					"Largeur minimale de colonne (en pixels)"
				],
				[
					"largeurMaxi",
					"Integer",
					"->",
					"Largeur maximale de colonne (en pixels)"
				]
			],
			"Summary": "La commande **LISTBOX SET COLUMN WIDTH** permet de modifier par programmation la largeur d’une ou de toutes les colonne(s) de l’objet (list box, colonne ou en-tête) désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET FOOTER CALCULATION": {
			"Syntax": "**LISTBOX SET FOOTER CALCULATION** ( {* ;} *objet* ; *calcul* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"calcul",
					"Integer",
					"->",
					"Calcul pour la zone de pied"
				]
			],
			"Summary": "La commande **LISTBOX SET FOOTER CALCULATION** permet de définir le calcul automatique associé à la zone de pied de list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET FOOTERS HEIGHT": {
			"Syntax": "**LISTBOX SET FOOTERS HEIGHT** ( {* ;} *objet* ; *hauteur* {; *unité*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de la ligne"
				],
				[
					"unité",
					"Integer",
					"->",
					"Unité de la valeur de hauteur : 0 ou omis = pixels, 1 = lignes"
				]
			],
			"Summary": "La commande **LISTBOX SET FOOTERS HEIGHT** permet de modifier par programmation la hauteur de la ligne de pied de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET GRID COLOR": {
			"Syntax": "**LISTBOX SET GRID COLOR** ( {* ;} *objet* ; *couleur* ; *horizontal* ; *vertical* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"couleur",
					"Text, Integer",
					"->",
					"Valeur de couleur RVB"
				],
				[
					"horizontal",
					"Boolean",
					"->",
					"Utiliser la couleur pour les traits horizontaux"
				],
				[
					"vertical",
					"Boolean",
					"->",
					"Utiliser la couleur pour les traits verticaux"
				]
			],
			"Summary": "La commande **LISTBOX SET GRID COLOR** permet de modifier la couleur de la grille de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET GRID": {
			"Syntax": "**LISTBOX SET GRID** ( {* ;} *objet* ; *horizontal* ; *vertical* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"horizontal",
					"Boolean",
					"->",
					"Vrai=montrer, Faux=cacher"
				],
				[
					"vertical",
					"Boolean",
					"->",
					"Vrai=montrer, Faux=cacher"
				]
			],
			"Summary": "La commande **LISTBOX SET GRID** permet d’afficher ou de masquer les traits horizontaux et/ou verticaux composant la grille de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET HEADERS HEIGHT": {
			"Syntax": "**LISTBOX SET HEADERS HEIGHT** ( {* ;} *objet* ; *hauteur* {; *unité*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de la ligne"
				],
				[
					"unité",
					"Integer",
					"->",
					"Unité de la valeur de hauteur : <br/>0 ou omis = pixels, 1 = lignes"
				]
			],
			"Summary": "La commande **LISTBOX SET HEADERS HEIGHT** permet de modifier par programmation la hauteur de la ligne d’en-tête de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET HIERARCHY": {
			"Syntax": "**LISTBOX SET HIERARCHY** ( {* ;} *objet* ; *hiérarchique* {; *hiérarchie*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"hiérarchique",
					"Boolean",
					"->",
					"Vrai = list box hiérarchique, Faux = list box non hiérarchique"
				],
				[
					"hiérarchie",
					"Pointer array",
					"->",
					"Tableau de pointeurs"
				]
			],
			"Summary": "La commande **LISTBOX SET HIERARCHY** vous permet de configurer l'objet list box désigné par les paramètres *objet* et *\\** en mode hiérarchique ou non."
		},
		"LISTBOX SET LOCKED COLUMNS": {
			"Syntax": "**LISTBOX SET LOCKED COLUMNS** ( {* ;} *objet* ; *nbColonnes* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"nbColonnes",
					"Integer",
					"->",
					"Nombre de colonnes à verrouiller"
				]
			],
			"Summary": "La commande **LISTBOX SET LOCKED COLUMNS** permet de verrouiller les *nbColonnes* premières colonnes gauches de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET ROW COLOR": {
			"Syntax": "**LISTBOX SET ROW COLOR** ( {* ;} *objet* ; *ligne* ; *couleur* {; *typeCouleur*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"couleur",
					"Text, Integer",
					"->",
					"Valeur de couleur RVB"
				],
				[
					"typeCouleur",
					"Integer",
					"->",
					"Listbox couleur de police (défaut) ou Listbox couleur de fond"
				]
			],
			"Summary": "**Note :** Cette commande fonctionne uniquement avec les list box de type tableau."
		},
		"LISTBOX SET ROW FONT STYLE": {
			"Syntax": "**LISTBOX SET ROW FONT STYLE** ( {* ;} *objet* ; *ligne* ; *style* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"style",
					"Integer",
					"->",
					"Style de police"
				]
			],
			"Summary": "**Note :** Cette commande fonctionne uniquement avec les list box de type tableau."
		},
		"LISTBOX SET ROW HEIGHT": {
			"Syntax": "**LISTBOX SET ROW HEIGHT** ( {* ;} *objet* ; *ligne* ; *hauteur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Ligne de la List box dont la hauteur doit être fixée."
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de la ligne de la List box"
				]
			],
			"Summary": "La commande **LISTBOX SET ROW HEIGHT** permet de modifier la hauteur de la ligne spécifiée dans le paramètre *ligne* dans la List box désignée par les paramètres *objet* et éventuellement *\\**."
		},
		"LISTBOX SET ROWS HEIGHT": {
			"Syntax": "**LISTBOX SET ROWS HEIGHT** ( {* ;} *objet* ; *hauteur* {; *unité*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de ligne"
				],
				[
					"unité",
					"Integer",
					"->",
					"Unité de la valeur de hauteur : 0 ou omis = pixels, 1 = lignes"
				]
			],
			"Summary": "La commande **LISTBOX SET ROWS HEIGHT** permet de modifier par programmation la hauteur des lignes de l’objet list box désigné par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET STATIC COLUMNS": {
			"Syntax": "**LISTBOX SET STATIC COLUMNS** ( {* ;} *objet* ; *nbColonnes* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"nbColonnes",
					"Integer",
					"->",
					"Nombre de colonnes à rendre statiques"
				]
			],
			"Summary": "La commande **LISTBOX SET STATIC COLUMNS** permet de rendre statiques les *nbColonnes* premières colonnes gauches de la list box désignée par les paramètres *objet* et *\\**."
		},
		"LISTBOX SET TABLE SOURCE": {
			"Syntax": "**LISTBOX SET TABLE SOURCE** ( {* ;} *objet* ; numTable | tempo {; *nomSurlignage*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"numTable &#124; tempo",
					"Entier long, Chaîne",
					"->",
					"Numéro de la table de laquelle utiliser la sélection courante ou Nom de la sélection temporaire à utiliser"
				],
				[
					"nomSurlignage",
					"Text",
					"->",
					"Nom de l’ensemble de surlignage"
				]
			],
			"Summary": "La commande **LISTBOX SET TABLE SOURCE** vous permet de modifier la source des données affichées dans la list box désignée par les paramètres *\\** et *objet*."
		},
		"LISTBOX SORT COLUMNS": {
			"Syntax": "**LISTBOX SORT COLUMNS** ( {* ;} *objet* ; *numColonne* ; *sensDuTri* {; *numColonne2* ; *sensDuTri2* ; ... ; *numColonneN* ; *sensDuTriN*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro(s) de colonne(s) à trier"
				],
				[
					"sensDuTri",
					"*",
					"->",
					"\">\"pour effectuer un tri croissant ou \"<\" pour effectuer un tri décroissant"
				]
			],
			"Summary": "La commande **LISTBOX SORT COLUMNS** permet de trier (réordonner) toutes les lignes de la list box définie dans les paramètres *objet* et *\\** sur la base des valeurs d’une ou plusieurs colonne(s)."
		},
		"Load 4D View document": {
			"Syntax": "**Load 4D View document** ( *document4DView* ) : Object",
			"Params": [
				[
					"document4DView",
					"Blob",
					"->",
					"Document du plug-in 4D View"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Représentation du document 4D View sous forme d'objet"
				]
			],
			"Summary": "La commande **Load 4D View document** convertit un document 4D View en objet 4D."
		},
		"Load list": {
			"Syntax": "**Load list** ( *nomListe* ) : Integer",
			"Params": [
				[
					"nomListe",
					"Text",
					"->",
					"Nom de liste créée dans l'éditeur d'énumérations"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de la liste nouvellement créée"
				]
			],
			"Summary": "La commande **Load list** crée une liste hiérarchique dont le contenu est copié depuis la liste *nomListe* créée en mode Développement, dans l'éditeur d'énumérations."
		},
		"LOAD RECORD": {
			"Syntax": "**LOAD RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle charger l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**LOAD RECORD** charge l'enregistrement courant de *laTable*."
		},
		"LOAD SET": {
			"Syntax": "**LOAD SET** ( {*laTable* ;} *ensemble* ; *nomFichier* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à laquelle appartient l'ensemble ou Table par défaut si ce paramètre est omis"
				],
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble à créer en mémoire"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document disque contenant l'ensemble"
				]
			],
			"Summary": "**LOAD SET** charge un ensemble depuis le fichier *nomFichier*, créé à l'aide de la commande SAVE SET."
		},
		"LOAD VARIABLES": {
			"Syntax": "**LOAD VARIABLES** ( *nomFichier* ; *variable* {; *variable2* ; ... ; *variableN*} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Document contenant la ou les variable(s) à lire"
				],
				[
					"variable",
					"Variable",
					"<-",
					"Nom de(s) variable(s) devant recevoir les valeurs"
				]
			],
			"Summary": "La commande **LOAD VARIABLES** charge une ou plusieurs variable(s) depuis le document désigné par *document*."
		},
		"Localized document path": {
			"Syntax": "**Localized document path** ( *cheminRelatif* ) : Text",
			"Params": [
				[
					"cheminRelatif",
					"Text",
					"->",
					"Chemin d’accès relatif du document dont on veut obtenir la version localisée"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès absolu du document localisé"
				]
			],
			"Summary": "La commande **Localized document path** retourne le chemin d’accès complet (absolu) d’un document désigné par *cheminRelatif* et situé dans un dossier xxx."
		},
		"Localized string": {
			"Syntax": "**Localized string** ( *resName* ) : Text",
			"Params": [
				[
					"resName",
					"Text",
					"->",
					"Nom d’attribut resname"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur de la chaîne désignée par resName dans le langage courant"
				]
			],
			"Summary": "La commande **Localized string** retourne la valeur de la chaîne désignée par l’attribut *resName* pour la langue courante."
		},
		"LOCKED BY": {
			"Syntax": "**LOCKED BY** ( {*laTable* ;} *process* ; *utilisateur4D* ; *utilisateurSession* ; *nomProcess* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement verrouillé ou Table par défaut si ce paramètre est omis"
				],
				[
					"process",
					"Integer",
					"<-",
					"Numéro du process"
				],
				[
					"utilisateur4D",
					"Text",
					"<-",
					"Nom de l'utilisateur 4D"
				],
				[
					"utilisateurSession",
					"Text",
					"<-",
					"Nom de l'utilisateur ayant ouvert la session de travail"
				],
				[
					"nomProcess",
					"Text",
					"<-",
					"Nom du process"
				]
			],
			"Summary": "**LOCKED BY** retourne des informations sur l'utilisateur et le process qui ont verrouillé l'enregistrement."
		},
		"Locked records info": {
			"Syntax": "**Locked records info** ( *laTable* ) : Object",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle vous souhaitez connaître les enregistrements verrouillés"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Description des enregistrements verrouillés (le cas échéant)"
				]
			],
			"Summary": "La commande **Locked records info** retourne un objet décrivant le ou les enregistrement(s) actuellement verrouillé(s) dans *laTable*."
		},
		"Locked": {
			"Syntax": "**Locked** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement dont vous voulez tester le verrouillage ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"L'enregistrement est verrouillé (Vrai) ou L'enregistrement n'est pas verrouillé (Faux)"
				]
			],
			"Summary": "**Locked** teste si l'enregistrement courant de *laTable* est verrouillé."
		},
		"LOG EVENT": {
			"Syntax": "**LOG EVENT** ( {*typeSortie* ;} *message* {; *importance*} )",
			"Params": [
				[
					"typeSortie",
					"Integer",
					"->",
					"Type de sortie du message"
				],
				[
					"message",
					"Text",
					"->",
					"Contenu du message"
				],
				[
					"importance",
					"Integer",
					"->",
					"Niveau d’importance du message (Windows uniquement)"
				]
			],
			"Summary": "La commande **LOG EVENT** vous permet de mettre en place un système personnalisé d'enregistrement des événements internes qui se produisent au cours de l'utilisation de votre application."
		},
		"LOG FILE TO JSON": {
			"Syntax": "**LOG FILE TO JSON** ( *cheminDossierDest* {; *tailleMax* {; *cheminHistorique* {; *attribChamp*}}} )",
			"Params": [
				[
					"cheminDossierDest",
					"Text",
					"->",
					"Chemin d'accès du dossier de destination du fichier sauvegardé"
				],
				[
					"tailleMax",
					"Integer",
					"->",
					"Taille maximale du fichier JSON à créer (octets)"
				],
				[
					"cheminHistorique",
					"Text",
					"->",
					"Chemin d'accès du fichier d'historique à exporter ; utiliser l'historique courant si omis"
				],
				[
					"attribChamp",
					"Integer",
					"->",
					"Attribut de description du champ : 1 = utiliser numéro (défaut), 2 = utiliser nom"
				]
			],
			"Summary": "La commande **LOG FILE TO JSON** sauvegarde au format JSON le fichier d'historique courant ou tout fichier d'historique spécifié."
		},
		"Log file": {
			"Syntax": "**Log file**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom long du fichier d’historique de la base"
				]
			],
			"Summary": "La commande **Log file** retourne le nom long (c’est-à-dire le chemin d’accès complet au fichier, y compris son nom) du fichier d’historique courant de la base ouverte."
		},
		"Log": {
			"Syntax": "**Log** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre dont vous voulez obtenir le logarithme népérien"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Logarithme népérien de nombre"
				]
			],
			"Summary": "**Log** retourne le logarithme népérien de *nombre*."
		},
		"LONGINT ARRAY FROM SELECTION": {
			"Syntax": "**LONGINT ARRAY FROM SELECTION** ( *laTable* ; *tabEnrg* {; *tempo*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de la sélection courante"
				],
				[
					"tabEnrg",
					"Integer array",
					"<-",
					"Tableau de numéros d’enregistrements"
				],
				[
					"tempo",
					"Text",
					"->",
					"Nom de la sélection temporaire ou Sélection courante si ce paramètre est omis"
				]
			],
			"Summary": "La commande **LONGINT ARRAY FROM SELECTION** remplit le tableau *tabEnrg* avec les numéros (absolus) des enregistrements faisant partie de la sélection temporaire *tempo*."
		},
		"LONGINT TO BLOB": {
			"Syntax": "**LONGINT TO BLOB** ( *entierLong* ; *blob* ; *ordreOctet* {; offset | *} )",
			"Params": [
				[
					"entierLong",
					"Integer",
					"->",
					"Valeur de type Entier long à écrire dans BLOB"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB devant recevoir l'entier long"
				],
				[
					"ordreOctet",
					"Integer",
					"->",
					"0=Ordre d'octets natif, 1=Ordre d'octets Macintosh, 2=Ordre d'octets PC"
				],
				[
					"offset &#124; *",
					"Variable, Opérateur",
					"<->",
					"Offset (en octets) dans le BLOB ou * pour ajouter la valeur à la fin du BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après l'écriture si * omis"
				]
			],
			"Summary": "La commande **LONGINT TO BLOB** écrit la valeur de type Entier long (4 octets) *entierLong* dans le BLOB *blob*."
		},
		"Lowercase": {
			"Syntax": "**Lowercase** ( *laChaîne* {; *} ) : Text",
			"Params": [
				[
					"laText",
					"Text",
					"->",
					"Chaîne à convertir en minuscules"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : conserver les accents Si omis : supprimer les accents"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"chaîne en minuscules"
				]
			],
			"Summary": "**Lowercase** retourne une chaîne de caractères égale à *laChaîne* dont tous les caractères alphabétiques ont été convertis en minuscules."
		},
		"Macintosh command down": {
			"Syntax": "**Macintosh command down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Commande Macintosh ou Etat de la touche Ctrl Windows"
				]
			],
			"Summary": "**Macintosh command down** retourne Vrai si la touche **Commande** Macintosh est enfoncée."
		},
		"Macintosh control down": {
			"Syntax": "**Macintosh control down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Control du Macintosh"
				]
			],
			"Summary": "**Macintosh control down** retourne Vrai si la touche **Control** du Macintosh est enfoncée."
		},
		"Macintosh option down": {
			"Syntax": "**Macintosh option down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Option Macintosh ou Etat de la touche Alt Windows"
				]
			],
			"Summary": "**Macintosh option down** retourne Vrai si la touche **Option** Macintosh est enfoncée."
		},
		"Match regex": {
			"Syntax": "**Match regex** ( *motif* ; *laChaîne* ; *début* {; pos_trouvée ; long_trouvée}{; *} ) -> Résultat <br/>\n**Match regex** ( *motif* ; *laChaîne* ) -> Résultat",
			"Params": [
				[
					"motif",
					"Text",
					"->",
					"Expression régulière"
				],
				[
					"laChaîne",
					"Text",
					"->",
					"Chaîne dans laquelle s’effectue la recherche"
				],
				[
					"début",
					"Integer",
					"->",
					"Position dans laChaîne où doit débuter la recherche"
				],
				[
					"pos_trouvée",
					"Integer array, Integer",
					"<-",
					"Position de l’occurence"
				],
				[
					"long_trouvée",
					"Integer array, Integer",
					"<-",
					"Longueur de l’occurence"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : rechercher uniquement à la position indiquée"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = la recherche a trouvé une occurrence, Faux sinon"
				],
				[
					"Match regex ( motif ; laChaîne ) -> Résultat"
				],
				[
					"Paramètre",
					"Type",
					"Description"
				],
				[
					"motif",
					"Text",
					"->",
					"Expression régulière (égalité complète)"
				],
				[
					"laChaîne",
					"Text",
					"->",
					"Chaîne dans laquelle s'effectue la recherche"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = la recherche a trouvé une occurrence, Faux sinon"
				]
			],
			"Summary": "La commande **Match regex** permet de tester la conformité d’une chaîne de caractères par rapport à un ensemble de règles synthétisé au moyen d’un méta-langage appelé “expression régulière” ou “expression rationnelle”."
		},
		"Max": {
			"Syntax": "**Max** ( *séries* {; *cheminAttribut*} ) : any",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs desquelles dont vous voulez obtenir la plus élevée"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Chemin d'attribut duquel calculer la valeur maximale"
				],
				[
					"Résultat",
					"Date, Number",
					"<-",
					"Valeur la plus élevée de séries"
				]
			],
			"Summary": "**Max** retourne la valeur la plus élevée contenue dans *séries*."
		},
		"MAXIMIZE WINDOW": {
			"Syntax": "**MAXIMIZE WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre Si omis = Toutes les fenêtres (Windows) ou Fenêtre de premier plan du process courant (macOS)"
				]
			],
			"Summary": "La commande **MAXIMIZE WINDOW** provoque le zoom de la fenêtre dont vous avez passé le numéro de référence dans *fenêtre* ou, si ce paramètre est omis, de toutes les fenêtres de l'application (sous Windows) ou de la fenêtre de premier plan du process courant (sous Mac OS)."
		},
		"MEMORY STATISTICS": {
			"Syntax": "**MEMORY STATISTICS** ( *typeInfo* ; *tabNoms* ; *tabValeurs* ; *tabNombre* )",
			"Params": [
				[
					"typeInfo",
					"Integer",
					"->",
					"Sélecteur d’information à obtenir"
				],
				[
					"tabNoms",
					"Text array",
					"<-",
					"Libellés des informations"
				],
				[
					"tabValeurs",
					"Real array",
					"<-",
					"Valeurs des informations"
				],
				[
					"tabNombre",
					"Real array",
					"<-",
					"Nombre d’objets concernés (si disponible)"
				]
			],
			"Summary": "La commande **MEMORY STATISTICS** permet de récupérer des informations relatives à l’utilisation du cache de données par 4D."
		},
		"Menu bar height": {
			"Syntax": "**Menu bar height**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur (exprimée en pixels) de la barre de menus (retourne zéro si la barre de menus est cachée)"
				]
			],
			"Summary": "La commande **Menu bar height** retourne la hauteur de la barre de menus, exprimée en pixels."
		},
		"Menu bar screen": {
			"Syntax": "**Menu bar screen**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de l'écran contenant la barre de menus"
				]
			],
			"Summary": "La commande **Menu bar screen** retourne le numéro de l'écran dans lequel se trouve la barre de menus."
		},
		"Menu selected": {
			"Syntax": "**Menu selected** {( *sousMenu* )} : Integer",
			"Params": [
				[
					"sousMenu",
					"Text",
					"<-",
					"Référence du menu contenant la ligne sélectionnée"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Commande de menu sélectionnée : Mot machine haut = n° de menu, Mot machine bas = n° de commande de menu"
				]
			],
			"Summary": "**Menu selected** ne s'utilise que lorsqu'un formulaire est affiché."
		},
		"MESSAGE": {
			"Syntax": "**MESSAGE** ( *message* )",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message à afficher"
				]
			],
			"Summary": "La commande **MESSAGE** affiche *message* à l'écran dans une fenêtre spéciale de message qui est ouverte et refermée à chaque fois que vous l'appelez (à moins que vous ne travailliez dans une fenêtre préalablement ouverte par la commande Open window, cf."
		},
		"MESSAGES OFF": {
			"Syntax": "**MESSAGES OFF**",
			"Params": [],
			"Summary": "Les commandes **MESSAGES OFF** et MESSAGES ON suppriment ou font apparaître les thermomètres de progression affichés par 4D lorsque le programme exécute des opérations de longue durée."
		},
		"MESSAGES ON": {
			"Syntax": "**MESSAGES ON**",
			"Params": [],
			"Summary": "Reportez-vous à la description de la commande MESSAGES OFF."
		},
		"Method called on error": {
			"Syntax": "**Method called on error** {( *portée* )} : Text",
			"Params": [
				[
					"portée",
					"Integer",
					"->",
					"Portée de la méthode de gestion d'erreur"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la méthode d’appel sur erreur"
				]
			],
			"Summary": "La commande **Method called on error** retourne le nom de la méthode installée par la commande ON ERR CALL pour le process courant ou la *portée* définie."
		},
		"Method called on event": {
			"Syntax": "**Method called on event**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la méthode d’appel sur evenement"
				]
			],
			"Summary": "La commande **Method called on event** retourne le nom de la méthode installée par la commande ON EVENT CALL."
		},
		"METHOD Get attribute": {
			"Syntax": "**METHOD Get attribute** ( *chemin* ; *typeAttribut* {; *} ) : Boolean",
			"Params": [
				[
					"chemin",
					"Text",
					"->",
					"Chemin de méthode projet"
				],
				[
					"typeAttribut",
					"Integer",
					"->",
					"Type d’attribut à obtenir"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = attribut sélectionné, sinon Faux"
				]
			],
			"Summary": "La commande **METHOD Get attribute** retourne la valeur de l’attribut *typeAttribut* pour la méthode projet désignée par le paramètre *chemin*."
		},
		"METHOD GET ATTRIBUTES": {
			"Syntax": "**METHOD GET ATTRIBUTES** ( *chemin* ; *attributs* {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Chemin(s) de méthode(s)"
				],
				[
					"attributs",
					"Object, Object array",
					"<-",
					"Attribut(s) de méthode(s)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET ATTRIBUTES** retourne, dans le paramètre *attributs*, la valeur courante de tous les attributs de la ou des méthode(s) spécifiée(s) dans le paramètre *chemin*."
		},
		"METHOD GET CODE": {
			"Syntax": "**METHOD GET CODE** ( *chemin* ; *code* {; *option*} {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Texte ou Tableau texte contenant un ou plusieurs chemin(s) de méthode(s)"
				],
				[
					"code",
					"Text, Text array",
					"<-",
					"Code de(s) méthode(s) désignée(s)"
				],
				[
					"option",
					"Integer",
					"->",
					"0 ou omis = export simple (sans tokens), 1 = export avec tokens"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET CODE** retourne dans le paramètre *code* le contenu de la ou des méthode(s) désignée(s) par le paramètre *chemin*."
		},
		"METHOD GET COMMENTS": {
			"Syntax": "**METHOD GET COMMENTS** ( *chemin* ; *commentaires* {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Texte ou Tableau texte contenant un ou plusieurs chemin(s) de méthode(s)"
				],
				[
					"commentaires",
					"Text, Text array",
					"<-",
					"Documentation de la ou des méthode(s) désignée(s)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET COMMENTS** retourne dans le paramètre *commentaires* la documentation de la ou des méthode(s) désignée(s) par le paramètre *chemin*."
		},
		"METHOD GET FOLDERS": {
			"Syntax": "**METHOD GET FOLDERS** ( *tabNoms* {; *filtre*}{; *} )",
			"Params": [
				[
					"tabNoms",
					"Text array",
					"<-",
					"Tableau des noms de dossiers de la page Démarrage"
				],
				[
					"filtre",
					"Text",
					"->",
					"Filtrage des noms"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET FOLDERS** retourne dans le tableau *tabNoms* les noms des dossiers créés dans la page Démarrage de l’Explorateur de 4D"
		},
		"METHOD GET MODIFICATION DATE": {
			"Syntax": "**METHOD GET MODIFICATION DATE** ( *chemin* ; *dateMod* ; *heureMod* {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Texte ou Tableau texte contenant un ou plusieurs chemin(s) de méthode(s)"
				],
				[
					"dateMod",
					"Date, Date array",
					"<-",
					"Date(s) de modification de méthode(s)"
				],
				[
					"heureMod",
					"Time, Integer array",
					"<-",
					"Heure(s) de modification de méthode(s)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET MODIFICATION DATE** retourne dans les paramètres *dateMod* et *heureMod* les dates et heures de dernière modification de la ou des méthode(s) désignée(s) par le paramètre *chemin*."
		},
		"METHOD GET NAMES": {
			"Syntax": "**METHOD GET NAMES** ( *tabNoms* {; *filtre*}{; *} )",
			"Params": [
				[
					"tabNoms",
					"Text array",
					"<-",
					"Tableau des noms de méthodes projet"
				],
				[
					"filtre",
					"Text",
					"->",
					"Filtrage des noms"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET NAMES** remplit le tableau *tabNoms* avec les noms des méthodes projet créées dans l’application."
		},
		"METHOD Get path": {
			"Syntax": "**METHOD Get path** ( *typeMéthode* {; *laTable*}{; *nomObjet*{; *nomObjetForm*}}{; *} ) : Text",
			"Params": [
				[
					"typeMéthode",
					"Integer",
					"->",
					"Sélecteur de type d’objet du développement"
				],
				[
					"laTable",
					"Table",
					"->",
					"Référence de table"
				],
				[
					"nomObjet",
					"Text",
					"->",
					"Nom de formulaire ou de méthode"
				],
				[
					"nomObjetForm",
					"Text",
					"<-",
					"Nom d’objet du formulaire"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin complet de l’objet"
				]
			],
			"Summary": "La commande **METHOD Get path** retourne le chemin d’accès interne complet d’une méthode."
		},
		"METHOD GET PATHS FORM": {
			"Syntax": "**METHOD GET PATHS FORM** ( {*laTable* ;} *tabChemins* {; *filtre*}{; *marqueur*}{; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Référence de table"
				],
				[
					"tabChemins",
					"Text array",
					"<-",
					"Tableau des chemins et noms des méthodes"
				],
				[
					"filtre",
					"Text",
					"->",
					"Filtrage des noms"
				],
				[
					"marqueur",
					"Real",
					"->",
					"Valeur minimum de marqueur"
				],
				[
					"<-",
					"Nouvelle valeur courante"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET PATHS FORM** remplit le tableau *tabChemins* avec les chemins d’accès internes et les noms des méthodes de tous les objets des formulaires, ainsi que des méthodes formulaire."
		},
		"METHOD GET PATHS": {
			"Syntax": "**METHOD GET PATHS** ( {*nomDossier* ;} *typeMéthode* ; *tabChemins* {; *marqueur*}{; *} )",
			"Params": [
				[
					"nomDossier",
					"Text",
					"->",
					"Nom de dossier de la page Démarrage"
				],
				[
					"typeMéthode",
					"Integer",
					"->",
					"Sélecteur de type de méthode à récupérer"
				],
				[
					"tabChemins",
					"Text array",
					"<-",
					"Tableau des chemins et noms des méthodes"
				],
				[
					"marqueur",
					"Real",
					"->",
					"Valeur minimum de marqueur"
				],
				[
					"<-",
					"Nouvelle valeur courante"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD GET PATHS** remplit le tableau *tabChemins* avec les chemins d’accès internes et les noms des méthodes de l’application du type défini par le paramètre *typeMéthode*."
		},
		"METHOD OPEN PATH": {
			"Syntax": "**METHOD OPEN PATH** ( *chemin* {; *line*}{; *} )",
			"Params": [
				[
					"chemin",
					"Text",
					"->",
					"Chemin de la méthode à ouvrir"
				],
				[
					"line",
					"Number",
					"->",
					"Line number"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD OPEN PATH** ouvre, dans l’éditeur de méthodes de 4D, la méthode dont vous avez passé le chemin d’accès interne dans le paramètre *chemin*."
		},
		"METHOD RESOLVE PATH": {
			"Syntax": "**METHOD RESOLVE PATH** ( *chemin* ; *typeMéthode* ; *ptrTable* ; *nomObjet* ; *nomObjetForm* {; *} )",
			"Params": [
				[
					"chemin",
					"Text",
					"->",
					"Chemin à résoudre"
				],
				[
					"typeMéthode",
					"Integer",
					"<-",
					"Sélecteur de type d’objet"
				],
				[
					"ptrTable",
					"Pointer",
					"<-",
					"Référence de table"
				],
				[
					"nomObjet",
					"Text",
					"<-",
					"Nom de formulaire ou de méthode base"
				],
				[
					"nomObjetForm",
					"Text",
					"<-",
					"Nom d’objet du formulaire"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD RESOLVE PATH** analyse le chemin d’accès interne passé dans le paramètre *chemin* et retourne ses différentes composantes dans les paramètres *typeMéthode*, *ptrTable*, *nomObjet* et *nomObjetForm*."
		},
		"METHOD SET ACCESS MODE": {
			"Syntax": "**METHOD SET ACCESS MODE** ( *mode* )",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"Mode d’accès aux objets verrouillés"
				]
			],
			"Summary": "La commande **METHOD SET ACCESS MODE** vous permet de définir le comportement de 4D lorsque vous tentez d’accéder en écriture à un objet déjà chargé en modification par un autre utilisateur ou process."
		},
		"METHOD SET ATTRIBUTE": {
			"Syntax": "**METHOD SET ATTRIBUTE** ( *chemin* ; *typeAttribut* ; *valeurAttribut* {; *typeAttribut2* ; *valeurAttribut2* ; ... ; *typeAttributN* ; *valeurAttributN*}{; *} )",
			"Params": [
				[
					"chemin",
					"Text",
					"->",
					"Chemin de méthode projet"
				],
				[
					"typeAttribut",
					"Integer",
					"->",
					"Type d’attribut"
				],
				[
					"valeurAttribut",
					"Boolean, Text",
					"->",
					"Vrai = sélectionner l’attribut, Faux = désélectionner l’attribut ou Nom du dossier"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD SET ATTRIBUTE** permet de définir la valeur d'un ou plusieurs attribut(s) *typeAttribut* pour la méthode projet désignée par le paramètre *chemin*."
		},
		"METHOD SET ATTRIBUTES": {
			"Syntax": "**METHOD SET ATTRIBUTES** ( *chemin* ; *attributs* {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Chemin(s) de méthode(s)"
				],
				[
					"attributs",
					"Object, Object array",
					"->",
					"Attribut(s) de méthode(s) à définir"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD SET ATTRIBUTES** vous permet de définir les valeurs des *attributs* pour la ou les méthode(s) spécifiée(s) dans le paramètre *chemin*."
		},
		"METHOD SET CODE": {
			"Syntax": "**METHOD SET CODE** ( *chemin* ; *code* {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Texte ou Tableau texte contenant un ou plusieurs chemin(s) de méthode(s)"
				],
				[
					"code",
					"Text, Text array",
					"->",
					"Code de(s) méthode(s) désignée(s)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD SET CODE** modifie le code de la ou des méthode(s) désignée(s) par le paramètre *chemin* avec le contenu passé dans le paramètre *code*."
		},
		"METHOD SET COMMENTS": {
			"Syntax": "**METHOD SET COMMENTS** ( *chemin* ; *commentaires* {; *} )",
			"Params": [
				[
					"chemin",
					"Text, Text array",
					"->",
					"Texte ou Tableau texte contenant un ou plusieurs chemin(s) de méthode(s)"
				],
				[
					"commentaires",
					"Text, Text array",
					"->",
					"Documentation de(s) méthode(s) désignée(s)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = la commande s’applique à la base hôte lorsqu’elle est exécutée depuis un composant (paramètre ignoré hors de ce contexte)"
				]
			],
			"Summary": "La commande **METHOD SET COMMENTS** remplace la documentation de la ou des méthode(s) désignée(s) par le paramètre *chemin* par ceux définis dans le paramètre *commentaires*."
		},
		"Milliseconds": {
			"Syntax": "**Milliseconds**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de millisecondes (1000ème de seconde) écoulées depuis le démarrage de la machine"
				]
			],
			"Summary": "**Milliseconds** retourne le nombre de millisecondes (1 milliseconde = 1/1000ème de seconde) écoulées depuis le démarrage de la machine."
		},
		"Min": {
			"Syntax": "**Min** ( *séries* {; *cheminAttribut*} ) : any",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs desquelles vous voulez obtenir la plus basse"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Chemin d'attribut duquel calculer la valeur minimale"
				],
				[
					"Résultat",
					"Date, Number",
					"<-",
					"Valeur la plus basse de séries"
				]
			],
			"Summary": "**Min** retourne la valeur la plus faible de *séries*."
		},
		"MINIMIZE WINDOW": {
			"Syntax": "**MINIMIZE WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre Si omis = Toutes les fenêtres (Windows) ou Fenêtre de premier plan du process courant (macOS)"
				]
			],
			"Summary": "La commande **MINIMIZE WINDOW** provoque un zoom arrière de la fenêtre dont vous avez passé le numéro de référence dans *fenêtre* ou, si ce paramètre est omis, de toutes les fenêtres de l'application (sous Windows) ou de la fenêtre de premier plan du process courant (sous Mac OS)."
		},
		"MOBILE APP REFRESH SESSIONS": {
			"Syntax": "**MOBILE APP REFRESH SESSIONS**",
			"Params": [],
			"Summary": "La commande **MOBILE APP REFRESH SESSIONS** vérifie tous les fichiers de session d'application mobile situés dans le dossier MobileApps du serveur et met à jour le contenu de la session existante en mémoire pour tous les fichiers modifiés."
		},
		"Mod": {
			"Syntax": "**Mod** ( *nombre1* ; *nombre2* ) : Real",
			"Params": [
				[
					"nombre1",
					"Integer",
					"->",
					"Nombre à diviser (numérateur)"
				],
				[
					"nombre2",
					"Integer",
					"->",
					"Nombre diviseur (dénominateur)"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Reste de la division entière de nombre1 par nombre2"
				]
			],
			"Summary": "La fonction **Mod** divise *nombre1* par *nombre2* et retourne le reste sous forme d'un nombre entier."
		},
		"Modified record": {
			"Syntax": "**Modified record** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle tester si l'enregistrement courant a été modifié ou Table par défaut si paramètre omis"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"L'enregistrement a été modifié (Vrai) ou L'enregistrement n'a pas été modifié (Faux)"
				]
			],
			"Summary": "**Modified record** retourne Vrai si l'enregistrement courant de *laTable* a été modifié et non encore stocké."
		},
		"Modified": {
			"Syntax": "**Modified** ( *leChamp* ) : Boolean",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ dont vous voulez tester la modification"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si une nouvelle valeur a été assignée au champ, sinon Faux"
				]
			],
			"Summary": "**Modified** retourne **Vrai** si une valeur a été assignée par programmation au champ *leChamp* ou s'il a été modifié lors de la saisie de données."
		},
		"MODIFY RECORD": {
			"Syntax": "**MODIFY RECORD** ( {*laTable*}{;}{*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle modifier des données ou Table par défaut si ce paramètre est omis"
				],
				[
					"*",
					"Operator",
					"->",
					"Cacher les barres de défilement"
				]
			],
			"Summary": "La commande **MODIFY RECORD** permet à l'utilisateur de modifier l'enregistrement courant de *laTable*, ou de la table par défaut si ce paramètre est omis."
		},
		"MODIFY SELECTION": {
			"Syntax": "**MODIFY SELECTION** ( {*laTable*}{; *modeSélection*}{; *saisieListe*}{; *}{; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à afficher et modifier ou Table par défaut si ce paramètre est omis"
				],
				[
					"modeSélection",
					"Integer",
					"->",
					"Mode de sélection"
				],
				[
					"saisieListe",
					"Boolean",
					"->",
					"Autoriser saisie en liste"
				],
				[
					"*",
					"Operator",
					"->",
					"Utiliser formulaire sortie pour un seul enregistrement et cacher les barres de défilement dans le formulaire entrée"
				],
				[
					"*",
					"Operator",
					"->",
					"Afficher les barres de défilement dans le formulaire entrée (= annuler le second effet du premier paramètre *)"
				]
			],
			"Summary": "La commande **MODIFY SELECTION** est quasiment identique à la commande DISPLAY SELECTION."
		},
		"Monitored activity": {
			"Syntax": "**Monitored activity**  : Collection",
			"Params": [
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'activités suivies"
				]
			],
			"Summary": "La commande **Monitored activity** retourne une collection d'objets décrivant les opérations enregistrées selon les spécifications définies par la commande START MONITORING ACTIVITY."
		},
		"Month of": {
			"Syntax": "**Month of** ( *laDate* ) : Integer",
			"Params": [
				[
					"laDate",
					"Date",
					"->",
					"Date dont vous voulez extraire le mois"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre indiquant le mois de date"
				]
			],
			"Summary": "**Month of** retourne un nombre représentant le numéro du mois de *laDate*."
		},
		"MOUSE POSITION": {
			"Syntax": "**MOUSE POSITION** ( *sourisX* ; *sourisY* ; *boutonSouris* {; *} )",
			"Params": [
				[
					"sourisX",
					"Real",
					"<-",
					"Coordonnée horizontale de la souris"
				],
				[
					"sourisY",
					"Real",
					"<-",
					"Coordonnée verticale de la souris"
				],
				[
					"boutonSouris",
					"Integer",
					"<-",
					"Etat du bouton de la souris : 0 = Bouton relâché 1 = Bouton enfoncé 2 = Bouton droit enfoncé 3 = Les deux boutons enfoncés"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, utiliser le système de coordonnées globales Si omis, utiliser le système de coordonnées locales"
				]
			],
			"Summary": "La commande **MOUSE POSITION** retourne l'état courant de la souris."
		},
		"MOVE DOCUMENT": {
			"Syntax": "**MOVE DOCUMENT** ( *cheminSource* ; *cheminDest* )",
			"Params": [
				[
					"cheminSource",
					"Text",
					"->",
					"Chemin d'accès complet au document existant"
				],
				[
					"cheminDest",
					"Text",
					"->",
					"Chemin d'accès de destination"
				]
			],
			"Summary": "La commande **MOVE DOCUMENT** déplace ou renomme un document."
		},
		"MULTI SORT ARRAY": {
			"Syntax": "**MULTI SORT ARRAY** ( *tableau* {; *sensDuTri*}{; *tableau2* ; *sensDuTri2* ; ... ; *tableauN* ; *sensDuTriN*} ) <br/>\n**MULTI SORT ARRAY** ( *tabPointeurs* ; *tabTris* )",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau(x) à trier"
				],
				[
					"sensDuTri",
					"*",
					"->",
					"\">\" pour effectuer un tri croissant ou \"<\" pour effectuer un tri décroissant Si omis  = pas de tri"
				],
				[
					"tabPointeurs",
					"Pointer array",
					"->",
					"Tableau de pointeurs de tableaux"
				],
				[
					"tabTris",
					"Integer array",
					"->",
					"Tableau d’ordres de tri (1 = tri par ordre croissant, -1 = tri par ordre décroissant, 0 = synchronisation avec des tris précédents)"
				]
			],
			"Summary": "La commande **MULTI SORT ARRAY** vous permet d’effectuer un tri multi-critères sur un ensemble de tableaux."
		},
		"New data key": {
			"Syntax": "**New data key** ( *phraseSecrète* ) : Object",
			"Params": [
				[
					"phraseSecrète",
					"Text",
					"->",
					"Phrase secrète à utiliser pour générer la clé de chiffrement des données AES"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contenant la clé (propriété encodedKey)"
				]
			],
			"Summary": "La commande **New data key** génère une clé de chiffrement des données binaires à partir du texte passé dans le paramètre *phraseSecrète*."
		},
		"New list": {
			"Syntax": "**New list**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de liste"
				]
			],
			"Summary": "La commande **New list** crée une nouvelle liste hiérarchique vide en mémoire et retourne son numéro de référence unique."
		},
		"New object": {
			"Syntax": "**New object** {( *propriété* ; *valeur* {; *propriété2* ; *valeur2* ; ... ; *propriétéN* ; *valeurN*} )} : Object",
			"Params": [
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à créer"
				],
				[
					"valeur",
					"any",
					"->",
					"Valeur de la propriété"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvel objet structuré"
				]
			],
			"Summary": "La commande **New object** crée un objet vide ou pré-rempli et retourne sa référence."
		},
		"New process": {
			"Syntax": "**New process** ( *méthode* ; *pile* {; *nom* {; *param* {; *param2* ; ... ; *paramN*}}}{; *} ) : Integer",
			"Params": [
				[
					"méthode",
					"Text",
					"->",
					"Méthode à exécuter dans le process"
				],
				[
					"pile",
					"Integer",
					"->",
					"Taille de la pile en octets (0 = taille par défaut)"
				],
				[
					"nom",
					"Text",
					"->",
					"Nom du process créé"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) de la méthode"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Process unique"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du process nouvellement créé ou du process déjà en cours d'exécution"
				]
			],
			"Summary": "La commande **New process** lance un nouveau process (sur la même machine) et retourne le numéro de ce process."
		},
		"New shared object": {
			"Syntax": "**New shared object** {( *propriété* ; *valeur* {; *propriété2* ; *valeur2* ; ... ; *propriétéN* ; *valeurN*} )} : Object",
			"Params": [
				[
					"propriété",
					"Text",
					"->",
					"Nom de propriété à créer"
				],
				[
					"valeur",
					"Text, Date, Boolean, Pointer, Number, Object",
					"->",
					"Valeur de propriété"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvel objet partagé"
				]
			],
			"Summary": "La commande **New shared object** crée un objet partagé vide ou pré-rempli et retourne sa référence."
		},
		"NEXT RECORD": {
			"Syntax": "**NEXT RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle se placer sur l'enregistrement suivant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "La commande **NEXT RECORD** place le pointeur d'enregistrement courant sur l'enregistrement suivant dans la sélection courante de *laTable* pour le process courant."
		},
		"Next window": {
			"Syntax": "**Next window** ( *fenêtre* ) : Integer",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de fenêtre"
				]
			],
			"Summary": "La commande **Next window** retourne le numéro de référence de la fenêtre située “derrière” la fenêtre dont vous avez passé le numéro de référence dans *fenêtre* (en fonction de l'ordre des fenêtres)."
		},
		"NO DEFAULT TABLE": {
			"Syntax": "**NO DEFAULT TABLE**",
			"Params": [],
			"Summary": "La commande **NO DEFAULT TABLE** permet d’annuler l’effet de la commande DEFAULT TABLE."
		},
		"Not": {
			"Syntax": "**Not** ( *booléen* ) : Boolean",
			"Params": [
				[
					"booléen",
					"Boolean",
					"->",
					"Valeur booléenne à inverser"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Inverse de booléen"
				]
			],
			"Summary": "La fonction **Not** retourne la valeur inverse de *booléen*, changeant un True en False ou un False en True."
		},
		"NOTIFY RESOURCES FOLDER MODIFICATION": {
			"Syntax": "**NOTIFY RESOURCES FOLDER MODIFICATION**",
			"Params": [],
			"Summary": "La commande **NOTIFY RESOURCES FOLDER MODIFICATION** permet de \"forcer\" l’envoi par 4D Server d’une notification indiquant à tous les postes 4D connectés que le contenu du dossier **Resources** de la base a été modifié, afin de leur permettre de synchroniser leur dossier **Resources** local."
		},
		"Null": {
			"Syntax": "**Null**  : Null",
			"Params": [
				[
					"Résultat",
					"Null",
					"<-",
					"Valeur Null"
				]
			],
			"Summary": "**Null** retourne la valeur **null**, de type Null."
		},
		"OB Class": {
			"Syntax": "**OB Class** ( *objet* ) : any",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet dont la classe doit être retournée"
				],
				[
					"Résultat",
					"Null, Object",
					"<-",
					"Classe de l'objet"
				]
			],
			"Summary": "La commande **OB Class** retourne la classe de l'*objet* passé en paramètre."
		},
		"OB Copy": {
			"Syntax": "**OB Copy** ( *objet* {; résoudrePtrs | {; *option* {; *grouperAvec*}}} )  : Object",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"résoudrePtrs",
					"Boolean",
					"->",
					"Vrai = résoudre les pointeurs, Faux ou omis = ne pas les résoudre"
				],
				[
					"option",
					"Integer",
					"->",
					"ck shared: return a shared object,ck resolve pointers: resolve pointers before copying"
				],
				[
					"grouperAvec",
					"Collection, Object",
					"->",
					"Collection ou objet partagé(e) à grouper avec l'objet résultant"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Copie de objet"
				]
			],
			"Summary": "La commande **OB Copy** retourne un objet contenant une copie complète des propriétés, sous-objets et valeurs de *objet*."
		},
		"OB Entries": {
			"Syntax": "**OB Entries** ( *objet* ) : Collection",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet retournant le contenu"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets avec les propriétés key/value"
				]
			],
			"Summary": "La commande **OB Entries** retourne une collection d'objets dont le contenu correspond à l'*objet* comme une paire de propriétés key/value."
		},
		"OB GET ARRAY": {
			"Syntax": "**OB GET ARRAY** ( *objet* ; *propriété* ; *tableau* )",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à lire"
				],
				[
					"tableau",
					"Text array, Real array, Boolean array, Object array, Pointer array, Integer array",
					"<-",
					"Tableau valeur de la propriété"
				]
			],
			"Summary": "La commande **OB GET ARRAY** récupère dans *tableau* le tableau de valeurs stocké dans la *propriété* de l’objet de langage désigné par le paramètre *objet*."
		},
		"OB GET PROPERTY NAMES": {
			"Syntax": "**OB GET PROPERTY NAMES** ( *objet* ; *tabPropriétés* {; *tabTypes*} )",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet structuré"
				],
				[
					"tabPropriétés",
					"Text array",
					"<-",
					"Noms des propriétés"
				],
				[
					"tabTypes",
					"Integer array",
					"<-",
					"Types des propriétés"
				]
			],
			"Summary": "La commande **OB GET PROPERTY NAMES** retourne dans *tabPropriétés* les noms des propriétés contenues dans l’objet de langage désigné par le paramètre *objet*."
		},
		"OB Get type": {
			"Syntax": "**OB Get type** ( *objet* ; *propriété* ) : Integer",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type de valeur de la propriété"
				]
			],
			"Summary": "La commande **OB Get type** retourne le type de la valeur associée à la *propriété* de l'*objet*."
		},
		"OB Get": {
			"Syntax": "**OB Get** ( *objet* ; *propriété* {; *type*} ) : any",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à lire"
				],
				[
					"type",
					"Integer",
					"->",
					"Type dans lequel convertir la valeur"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur courante de la propriété"
				]
			],
			"Summary": "La commande **OB Get** retourne la valeur courante de la *propriété* de l’*objet*, convertie optionnellement dans le *type* défini."
		},
		"OB Instance of": {
			"Syntax": "**OB Instance of** ( *objet* ; *classe* ) : Boolean",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet dont la classe doit être identifiée"
				],
				[
					"classe",
					"Object",
					"->",
					"Classe dont l'appartenance est à identifier"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l'objet appartient à la classe ou classe enfant indiquée, sinon faux"
				]
			],
			"Summary": "La commande **OB Instance of** retourne vrai si *objet* appartient à *classe* ou à l'une de ses classes enfant."
		},
		"OB Is defined": {
			"Syntax": "**OB Is defined** ( *objet* {; *propriété*} ) : Boolean",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Si passé = propriété à vérifier, si omis = vérifier l’objet"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Si propriété omis : Vrai si objet est défini, sinon Faux.<br/>Si propriété passé : Vrai si propriété est définie, sinon Faux"
				]
			],
			"Summary": "La commande **OB Is defined** retourne **Vrai** si *objet* ou *propriété* est défini, et **Faux** sinon."
		},
		"OB Is empty": {
			"Syntax": "**OB Is empty** ( *objet* ) : Boolean",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si objet est vide ou indéfini, sinon Faux"
				]
			],
			"Summary": "La commande **OB Is empty** retourne **Vrai** si *objet* est indéfini ou vide, et **Faux** si *objet* est défini (initialisé) et contient au moins une propriété."
		},
		"OB Is shared": {
			"Syntax": "**OB Is shared** ( *toCheck* ) : Boolean",
			"Params": [
				[
					"toCheck",
					"Object, Collection",
					"->",
					"Object or collection or to check"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"True if the object or collection is shareable, False if it is alterable"
				]
			],
			"Summary": "La commande **OB Is shared** retourne **Vrai** si l'objet ou la collection *toCheck* est partagé , sinon **Faux** (voir *Objets partagés et collections partagées*)."
		},
		"OB Keys": {
			"Syntax": "**OB Keys** ( *objet* ) : Collection",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet dont on veut obtenir les noms des propriétés"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de noms de propriété (chaines)"
				]
			],
			"Summary": "La commande **OB Keys** retourne une collection de chaînes contenant tous les noms des propriétés énumérables de l'*objet*."
		},
		"OB REMOVE": {
			"Syntax": "**OB REMOVE** ( *objet* ; *propriété* )",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à supprimer"
				]
			],
			"Summary": "La commande **OB REMOVE** permet de supprimer la *propriété* de l’objet de langage désigné par le paramètre *objet*."
		},
		"OB SET ARRAY": {
			"Syntax": "**OB SET ARRAY** ( *objet* ; *propriété* ; *tableau* )",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à définir"
				],
				[
					"tableau",
					"Array, Variable",
					"->",
					"Tableau à stocker dans la propriété"
				]
			],
			"Summary": "La commande **OB SET ARRAY** permet de définir le *tableau* à associer à la *propriété* dans l’objet de langage désigné par le paramètre *objet*."
		},
		"OB SET NULL": {
			"Syntax": "**OB SET NULL** ( *objet* ; *propriété* )",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à laquelle appliquer la valeur null"
				]
			],
			"Summary": "La commande **OB SET NULL** permet de stocker la valeur **null** dans l’objet de langage désigné par le paramètre *objet*."
		},
		"OB SET": {
			"Syntax": "**OB SET** ( *objet* ; *propriété* ; *valeur* {; *propriété2* ; *valeur2* ; ... ; *propriétéN* ; *valeurN*} )",
			"Params": [
				[
					"objet",
					"Object, Object",
					"->",
					"Objet structuré"
				],
				[
					"propriété",
					"Text",
					"->",
					"Nom de la propriété à définir"
				],
				[
					"valeur",
					"Expression",
					"->",
					"Nouvelle valeur de la propriété"
				]
			],
			"Summary": "La commande **OB SET** permet de créer ou de modifier une ou plusieurs paires propriété/valeur dans l’objet de langage désigné par le paramètre *objet*."
		},
		"OB Values": {
			"Syntax": "**OB Values** ( *objet* ) : Collection",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet retournant les valeurs des propriétés"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de valeurs des propriétés (variant)"
				]
			],
			"Summary": "La commande **OB Values** retourne une collection de variants contenant toutes les valeurs des propriétés énumérables de l'*objet*."
		},
		"OBJECT DUPLICATE": {
			"Syntax": "**OBJECT DUPLICATE** ( {* ;} *objet* {; *nouvNom* {; *nouvVar* {; *reliéA* {; *dépH* {; *dépV* {; *redimH* {; *redimV*}}}}}}} {; *} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"nouvNom",
					"Text",
					"->",
					"Nom du nouvel objet"
				],
				[
					"nouvVar",
					"Pointer",
					"->",
					"Pointeur vers la variable du nouvel objet"
				],
				[
					"reliéA",
					"Text",
					"->",
					"Nom de l’objet saisissable (ou du bouton radio) précédent"
				],
				[
					"dépH",
					"Integer",
					"->",
					"Décalage horizontal du nouvel objet<br/>(>0 = vers la droite, <0 = vers la gauche)"
				],
				[
					"dépV",
					"Integer",
					"->",
					"Décalage vertical du nouvel objet<br/>(>0 = vers le bas, <0 = vers le haut)"
				],
				[
					"redimH",
					"Integer",
					"->",
					"Valeur de redimensionnement horizontal du nouvel objet"
				],
				[
					"redimV",
					"Integer",
					"->",
					"Valeur de redimensionnement vertical du nouvel objet"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = coordonnées absolues<br/>Si omis = coordonnées relatives"
				]
			],
			"Summary": "La commande **OBJECT DUPLICATE** permet de créer une copie de l’objet désigné par le paramètre *objet* dans le contexte du formulaire en cours d’exécution (mode Application)."
		},
		"OBJECT Get action": {
			"Syntax": "**OBJECT Get action** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne). Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom de l'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de l'action standard associée et (s'il existe) son paramètre chaîne."
				]
			],
			"Summary": "La commande **OBJECT Get action** retourne le nom et (s'il existe), le paramètre de l'action standard associée à l'objet désigné par les paramètres *objet* et *\\**."
		},
		"OBJECT Get auto spellcheck": {
			"Syntax": "**OBJECT Get auto spellcheck** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = correction automatique, <br/>Faux = pas de correction automatique"
				]
			],
			"Summary": "La commande **OBJECT Get auto spellcheck** retourne le statut de l’option **Correction orthographique** du ou des objet(s) désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT GET BEST SIZE": {
			"Syntax": "**OBJECT GET BEST SIZE** ( {* ;} *objet* ; *largeurOpti* ; *hauteurOpti* {; *largeurMaxi*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d'objet (chaîne) Si omis = objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Champ ou variable (si * est omis"
				],
				[
					"largeurOpti",
					"Integer",
					"<-",
					"Largeur optimale de l’objet"
				],
				[
					"hauteurOpti",
					"Integer",
					"<-",
					"Hauteur optimale de l’objet"
				],
				[
					"largeurMaxi",
					"Integer",
					"->",
					"Largeur maximum de l’objet"
				]
			],
			"Summary": "La commande **OBJECT GET BEST SIZE** retourne dans les paramètres *largeurOpti* et *hauteurOpti* la largeur et la hauteur “optimales” de l’objet de formulaire désigné par les paramètres *\\** et *objet*."
		},
		"OBJECT Get border style": {
			"Syntax": "**OBJECT Get border style** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Style de la ligne de bordure"
				]
			],
			"Summary": "La commande **OBJECT Get border style** retourne le style de ligne de bordure de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get context menu": {
			"Syntax": "**OBJECT Get context menu** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = menu contextuel activé, <br/>Faux = menu contextuel désactivé"
				]
			],
			"Summary": "La commande **OBJECT Get context menu** retourne le statut courant de l’option \"Menu contextuel\" de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT GET COORDINATES": {
			"Syntax": "**OBJECT GET COORDINATES** ( {* ;} *objet* ; *gauche* ; *haut* ; *droite* ; *bas* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d’objet (chaîne) Si omis = objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Champ ou variable (si * est omis)"
				],
				[
					"gauche",
					"Integer",
					"<-",
					"Coordonnée gauche de l’objet"
				],
				[
					"haut",
					"Integer",
					"<-",
					"Coordonnée supérieure de l’objet"
				],
				[
					"droite",
					"Integer",
					"<-",
					"Coordonnée droite de l’objet"
				],
				[
					"bas",
					"Integer",
					"<-",
					"Coordonnée inférieure de l’objet"
				]
			],
			"Summary": "La commande **OBJECT GET COORDINATES** retourne dans les variables ou champs *gauche*, *haut*, *droite* et *bas* les coordonnées (en points) du ou des objet(s) du formulaire courant défini(s) par les paramètres *\\** et *objet*."
		},
		"OBJECT Get corner radius": {
			"Syntax": "**OBJECT Get corner radius** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Rayon des angles arrondis (en pixels)"
				]
			],
			"Summary": "La commande **OBJECT Get corner radius** retourne la valeur courante du rayon d'angles pour l'objet désigné par le paramètre *objet*."
		},
		"OBJECT Get data source": {
			"Syntax": "**OBJECT Get data source** ( {* ;} *objet* ) : Pointer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers la source de données courante de l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get data source** retourne la source de données courante de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT GET DRAG AND DROP OPTIONS": {
			"Syntax": "**OBJECT GET DRAG AND DROP OPTIONS** ( {* ;} *objet* ; *glissable* ; *glissableAuto* ; *déposable* ; *déposableAuto* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"glissable",
					"Boolean",
					"<-",
					"Glissable = Vrai, sinon Faux"
				],
				[
					"glissableAuto",
					"Boolean",
					"<-",
					"Glisser automatique = Vrai, sinon Faux"
				],
				[
					"déposable",
					"Boolean",
					"<-",
					"Déposable = Vrai, sinon Faux"
				],
				[
					"déposableAuto",
					"Boolean",
					"<-",
					"Déposer automatique = Vrai, sinon Faux"
				]
			],
			"Summary": "La commande **OBJECT GET DRAG AND DROP OPTIONS** retourne les options de glisser-déposer pour l’objet ou les objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT Get enabled": {
			"Syntax": "**OBJECT Get enabled** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable (si * omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = objet(s) activé(s), Faux sinon"
				]
			],
			"Summary": "La commande **OBJECT Get enabled** retourne Vrai si l'objet ou le groupe d'objets désigné par *objet* est activé dans le formulaire et Faux s’il est inactivé."
		},
		"OBJECT Get enterable": {
			"Syntax": "**OBJECT Get enterable** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = objet(s) saisissable(s), Faux sinon"
				]
			],
			"Summary": "La commande **OBJECT Get enterable** retourne Vrai si l'objet ou le groupe d'objets désigné par *objet* dispose de l’attribut **saisissable** et Faux sinon."
		},
		"OBJECT GET EVENTS": {
			"Syntax": "**OBJECT GET EVENTS** ( {* ;} *objet* ; *tabEvénements* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet ou \"\" pour désigner le formulaire (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"tabEvénements",
					"Integer array",
					"<-",
					"Tableau des événements activés"
				]
			],
			"Summary": "La commande **OBJECT GET EVENTS** vous permet de d’obtenir la configuration courante des événements formulaire du formulaire, de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get filter": {
			"Syntax": "**OBJECT Get filter** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable ou champ (si * omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom du filtre de saisie"
				]
			],
			"Summary": "La commande **OBJECT Get filter** retourne le nom du filtre de saisie éventuellement associé à l'objet ou au groupe d'objets désigné par *objet*."
		},
		"OBJECT Get focus rectangle invisible": {
			"Syntax": "**OBJECT Get focus rectangle invisible** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = rectangle focus caché, Faux = rectangle focus visible"
				]
			],
			"Summary": "La commande **OBJECT Get focus rectangle invisible** retourne le statut de l’option d’invisibilité du rectangle de focus de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT Get font size": {
			"Syntax": "**OBJECT Get font size** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Taille de la police en points"
				]
			],
			"Summary": "La commande **OBJECT Get font size** retourne la taille (en points) de la police de caractères utilisée par le ou les objet(s) de formulaire désigné(s) par *objet*."
		},
		"OBJECT Get font style": {
			"Syntax": "**OBJECT Get font style** ( * ; *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Style de police"
				]
			],
			"Summary": "La commande **OBJECT Get font style** retourne le style courant de la police de caractères utilisée par le ou les objet(s) de formulaire désigné(s) par *objet*."
		},
		"OBJECT Get font": {
			"Syntax": "**OBJECT Get font** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la police"
				]
			],
			"Summary": "La commande **OBJECT Get font** retourne le nom de la police de caractères utilisée par le ou les objet(s) de formulaire désigné(s) par *objet*."
		},
		"OBJECT Get format": {
			"Syntax": "**OBJECT Get format** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * spécifié) ou Champ ou variable (si * omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Format d’affichage de l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get format** retourne le format d’affichage courant appliqué à l’objet spécifié par le paramètre *objet*."
		},
		"OBJECT Get help tip": {
			"Syntax": "**OBJECT Get help tip** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Message d’aide de l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get help tip** retourne le message d’aide associé à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\** dans le process courant."
		},
		"OBJECT Get horizontal alignment": {
			"Syntax": "**OBJECT Get horizontal alignment** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est passé) ou Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code d’alignement"
				]
			],
			"Summary": "La commande **OBJECT Get horizontal alignment** retourne un code indiquant le type d’alignement horizontal appliqué à l’objet désigné par les paramètres *objet* et *\\**."
		},
		"OBJECT Get indicator type": {
			"Syntax": "**OBJECT Get indicator type** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type d’indicateur"
				]
			],
			"Summary": "La commande **OBJECT Get indicator type** retourne le type d’indicateur courant affecté au(x) thermomètre(s) désigné(s) par le(s) paramètre(s) *objet* et *\\**."
		},
		"OBJECT Get keyboard layout": {
			"Syntax": "**OBJECT Get keyboard layout** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Code de la langue de configuration , \"\" = pas de configuration"
				]
			],
			"Summary": "La commande **OBJECT Get keyboard layout** retourne la configuration clavier courante associée à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT Get list name": {
			"Syntax": "**OBJECT Get list name** ( {* ;} *objet* {; *typeListe*} ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"typeListe",
					"Integer",
					"->",
					"Type de liste : Liste énumération, Liste obligations ou Liste exclusions"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de l’énumération (définie en mode Développement)"
				]
			],
			"Summary": "La commande **OBJECT Get list name** retourne le nom de l’énumération associée à l'objet ou au groupe d'objets désigné par *objet*."
		},
		"OBJECT Get list reference": {
			"Syntax": "**OBJECT Get list reference** ( {* ;} *objet* {; *typeListe*} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"typeListe",
					"Integer",
					"->",
					"Type de liste : Liste énumération, Liste obligations ou Liste exclusions"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de la liste"
				]
			],
			"Summary": "La commande **OBJECT Get list reference** retourne le numéro de référence (*RefListe*) de la liste hiérarchique associée à l’objet ou au groupe d'objets désigné par *objet* et *\\**."
		},
		"OBJECT GET MAXIMUM VALUE": {
			"Syntax": "**OBJECT GET MAXIMUM VALUE** ( {* ;} *objet* ; *valeurMaxi* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"valeurMaxi",
					"Date, Time, Number",
					"<-",
					"Valeur maximale actuelle de l’objet"
				]
			],
			"Summary": "La commande **OBJECT GET MAXIMUM VALUE** retourne dans la variable *valeurMaxi* la valeur maximum actuelle de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT GET MINIMUM VALUE": {
			"Syntax": "**OBJECT GET MINIMUM VALUE** ( {* ;} *objet* ; *valeurMini* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"valeurMini",
					"Date, Time, Number",
					"<-",
					"Valeur minimale actuelle de l’objet"
				]
			],
			"Summary": "La commande **OBJECT GET MINIMUM VALUE** retourne dans la variable *valeurMini* la valeur minimum courante de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get multiline": {
			"Syntax": "**OBJECT Get multiline** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Statut multiligne de l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get multiline** retourne le statut courant de l’option \"Multilignes\" de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get name": {
			"Syntax": "**OBJECT Get name** {( *sélecteur* )} : Text",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Catégorie d’objet"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get name** retourne le nom d’un objet de formulaire."
		},
		"OBJECT Get placeholder": {
			"Syntax": "**OBJECT Get placeholder** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte d’exemple associé à l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get placeholder** retourne le texte d’exemple associé à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get pointer": {
			"Syntax": "**OBJECT Get pointer** {( *sélecteur* {; *nomObjet* {; *nomSousFormulaire*}})} : Pointer",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Catégorie d’objet"
				],
				[
					"nomObjet",
					"Text",
					"->",
					"Nom d'objet"
				],
				[
					"nomSousFormulaire",
					"Text",
					"->",
					"Nom d'objet sous-formulaire"
				],
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur sur la variable de l’objet"
				]
			],
			"Summary": "La commande **OBJECT Get pointer** retourne un pointeur vers la variable d’un objet de formulaire."
		},
		"OBJECT GET PRINT VARIABLE FRAME": {
			"Syntax": "**OBJECT GET PRINT VARIABLE FRAME** ( {* ;} *objet* ; *tailleVariable* {; *fixeSousForm*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"tailleVariable",
					"Boolean",
					"<-",
					"Vrai = Impression taille variable, Faux = Impression taille fixe"
				],
				[
					"fixeSousForm",
					"Integer",
					"<-",
					"Option d’impression en taille fixe des sous-formulaires"
				]
			],
			"Summary": "La commande **OBJECT GET PRINT VARIABLE FRAME** vous permet de d’obtenir la configuration courante des options d’impression en taille variable de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT GET RESIZING OPTIONS": {
			"Syntax": "**OBJECT GET RESIZING OPTIONS** ( {* ;} *objet* ; *horizontal* ; *vertical* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"horizontal",
					"Integer",
					"<-",
					"Option de redimensionnement horizontal"
				],
				[
					"vertical",
					"Integer",
					"<-",
					"Option de redimensionnement vertical"
				]
			],
			"Summary": "La commande **OBJECT GET RESIZING OPTIONS** retourne les options de redimensionnement courantes de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT GET RGB COLORS": {
			"Syntax": "**OBJECT GET RGB COLORS** ( {* ;} *objet* ; *couleurAvantPlan* {; *couleurArrièrePlan* {; *couleurArrièrePlanAlt*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"couleurAvantPlan",
					"Text, Integer",
					"<-",
					"Valeur de la couleur RVB d'avant-plan"
				],
				[
					"couleurArrièrePlan",
					"Text, Integer",
					"<-",
					"Valeur de la couleur RVB d'arrière-plan"
				],
				[
					"couleurArrièrePlanAlt",
					"Text, Integer",
					"<-",
					"Valeur de la couleur RVB d'arrière-plan alternée"
				]
			],
			"Summary": "La commande **OBJECT GET RGB COLORS** retourne les couleurs d’avant-plan et d’arrière-plan de l'objet ou du groupe d'objets désigné(s) par *objet*."
		},
		"OBJECT GET SCROLL POSITION": {
			"Syntax": "**OBJECT GET SCROLL POSITION** ( {* ;} *objet* ; *positionLigne* {; *positionH*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"positionLigne",
					"Integer",
					"<-",
					"Numéro de la première ligne affichée ou Défilement vertical en pixels (images)"
				],
				[
					"positionH",
					"Integer",
					"<-",
					"Numéro de la première colonne affichée (list box) ou<br/>Défilement horizontal en pixels (images)"
				]
			],
			"Summary": "La commande **OBJECT GET SCROLL POSITION** retourne dans les paramètres *positionLigne* et *positionH* des informations relatives à la position des barres de défilement de l’objet de formulaire désigné par les paramètres *\\** et *objet*."
		},
		"OBJECT GET SCROLLBAR": {
			"Syntax": "**OBJECT GET SCROLLBAR** ( {* ;} *objet* ; *horizontale* ; *verticale* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable ou champ (si * omis)"
				],
				[
					"horizontale",
					"Boolean, Integer",
					"<-",
					"Visibilité de la barre horizontale"
				],
				[
					"verticale",
					"Boolean, Integer",
					"<-",
					"Visibilité de la barre verticale"
				]
			],
			"Summary": "La commande **OBJECT GET SCROLLBAR** permet de connaître le statut affiché/masqué des barres de défilement horizontale et verticale de l'objet ou du groupe d'objets désigné par *objet*."
		},
		"OBJECT GET SHORTCUT": {
			"Syntax": "**OBJECT GET SHORTCUT** ( {* ;} *objet* ; *touche* ; *modifiers* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"touche",
					"Text",
					"<-",
					"Touche associée à l’objet"
				],
				[
					"modifiers",
					"Integer",
					"<-",
					"Masque ou combinaison de masques de touche(s) de modification"
				]
			],
			"Summary": "La commande **OBJECT GET SHORTCUT** retourne l’équivalent clavier associé à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get style sheet": {
			"Syntax": "**OBJECT Get style sheet** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la feuille de style"
				]
			],
			"Summary": "La commande **OBJECT Get style sheet** retourne le nom de la feuille de style associée à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT GET SUBFORM CONTAINER SIZE": {
			"Syntax": "**OBJECT GET SUBFORM CONTAINER SIZE** ( *largeur* ; *hauteur* )",
			"Params": [
				[
					"largeur",
					"Integer",
					"<-",
					"Largeur de l’objet sous-formulaire"
				],
				[
					"hauteur",
					"Integer",
					"<-",
					"Hauteur de l’objet sous-formulaire"
				]
			],
			"Summary": "La commande **OBJECT GET SUBFORM CONTAINER SIZE** retourne la *largeur* et la *hauteur* (en pixels) d’un objet sous-formulaire \"courant\", affiché dans le formulaire parent."
		},
		"OBJECT Get subform container value": {
			"Syntax": "**OBJECT Get subform container value**  : any",
			"Params": [
				[
					"Résultat",
					"any",
					"<-",
					"Current value of the subform container data source"
				]
			]
		},
		"OBJECT GET SUBFORM": {
			"Syntax": "**OBJECT GET SUBFORM** ( {* ;} *objet* ; *ptrTable* ; *sousFormDetail* {; *sousFormListe*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"ptrTable",
					"Table",
					"<-",
					"Pointeur vers la table du formulaire"
				],
				[
					"sousFormDetail",
					"Text",
					"<-",
					"Nom du formulaire détail du sous-formulaire"
				],
				[
					"sousFormListe",
					"Text",
					"<-",
					"Nom du formulaire liste du sous-formulaire (formulaire table)"
				]
			],
			"Summary": "La commande **OBJECT GET SUBFORM** vous permet d’obtenir les noms du ou des formulaire(s) associé(s) à l’objet sous-formulaire désigné par les paramètres *objet* et *\\**."
		},
		"OBJECT Get text orientation": {
			"Syntax": "**OBJECT Get text orientation** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Angle de rotation du texte"
				]
			],
			"Summary": "La commande **OBJECT Get text orientation** retourne la valeur d’orientation courante appliquée au texte de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get three states checkbox": {
			"Syntax": "**OBJECT Get three states checkbox** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = case à cocher à trois états, Faux = case à cocher standard"
				]
			],
			"Summary": "La commande **OBJECT Get three states checkbox** retourne l’état courant de la propriété \"Trois états\" de la ou des case(s) à cocher désignée(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT Get title": {
			"Syntax": "**OBJECT Get title** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Libellé de l'objet"
				]
			],
			"Summary": "La commande **OBJECT Get title** retourne le titre (libellé) du ou des objet(s) de formulaire désigné(s) par *objet*."
		},
		"OBJECT Get type": {
			"Syntax": "**OBJECT Get type** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type d’objet"
				]
			],
			"Summary": "La commande **OBJECT Get type** retourne le type de l’objet désigné par le(s) paramètre(s) *objet* et *\\** dans le formulaire courant."
		},
		"OBJECT Get value": {
			"Syntax": "**OBJECT Get value** ( *nomObjet* ) : any",
			"Params": [
				[
					"nomObjet",
					"Text",
					"->",
					"Nom de l'objet"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur courante des sources de données de l'objet de formulaire"
				]
			],
			"Summary": "La commande **OBJECT Get value** retourne la valeur courante des sources de données des objets formulaire désignés par le paramètre nomObjet."
		},
		"OBJECT Get vertical alignment": {
			"Syntax": "**OBJECT Get vertical alignment** ( {* ;} *objet* ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type d’alignement"
				]
			],
			"Summary": "La commande **OBJECT Get vertical alignment** retourne une valeur indiquant le type d’alignement vertical appliqué à l’objet désigné par les paramètres *objet* et *\\**."
		},
		"OBJECT Get visible": {
			"Syntax": "**OBJECT Get visible** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = objet(s) visible(s), Faux sinon"
				]
			],
			"Summary": "La commande **OBJECT Get visible** retourne Vrai si l'objet ou le groupe d'objets désigné(s) par *objet* dispose de l’attribut visible et Faux sinon."
		},
		"OBJECT Is styled text": {
			"Syntax": "**OBJECT Is styled text** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si l’objet est un texte en multistyle, Faux sinon"
				]
			],
			"Summary": "La commande **OBJECT Is styled text** retourne **Vrai** si l’option \"Multistyle\" est cochée pour l’objet ou les objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT MOVE": {
			"Syntax": "**OBJECT MOVE** ( {* ;} *objet* ; *dépH* ; *dépV* {; *redimH* {; *redimV* {; *}}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d’objet (chaîne) Si omis = objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Champ ou variable (si * est omis)"
				],
				[
					"dépH",
					"Integer",
					"->",
					"Valeur de déplacement horizontal de l’objet (>0 = vers la droite, <0 = vers la gauche)"
				],
				[
					"dépV",
					"Integer",
					"->",
					"Valeur de déplacement vertical de l’objet (>0 = vers le bas, <0 = vers le haut)"
				],
				[
					"redimH",
					"Integer",
					"->",
					"Valeur de redimensionnement horizontal de l’objet"
				],
				[
					"redimV",
					"Integer",
					"->",
					"Valeur de redimensionnement vertical de l’objet"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = coordonnées absolues Si omis = coordonnées relatives"
				]
			],
			"Summary": "La commande **OBJECT MOVE** permet de déplacer le ou les objet(s) du formulaire courant, défini(s) par les paramètres *\\** et *objet*, de *dépH* pixels horizontalement et de *dépV* pixels verticalement."
		},
		"OBJECT SET ACTION": {
			"Syntax": "**OBJECT SET ACTION** ( {* ;} *objet* ; *action* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"action",
					"Text",
					"->",
					"Nom d'action à associer (avec paramètre si nécessaire)"
				]
			],
			"Summary": "La commande **OBJECT SET ACTION** vous permet de modifier l’action standard associée à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET AUTO SPELLCHECK": {
			"Syntax": "**OBJECT SET AUTO SPELLCHECK** ( {* ;} *objet* ; *correctionAuto* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"correctionAuto",
					"Boolean",
					"->",
					"Vrai = correction automatique, Faux = pas de correction automatique"
				]
			],
			"Summary": "La commande **OBJECT SET AUTO SPELLCHECK** permet de définir ou de modifier dynamiquement le statut de l’option **Correction orthographique** du ou des objet(s) désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET BORDER STYLE": {
			"Syntax": "**OBJECT SET BORDER STYLE** ( {* ;} *objet* ; *styleBordure* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"styleBordure",
					"Integer",
					"->",
					"Style de la ligne de bordure"
				]
			],
			"Summary": "La commande **OBJECT SET BORDER STYLE** vous permet de modifier le style de la ligne de bordure de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET CONTEXT MENU": {
			"Syntax": "**OBJECT SET CONTEXT MENU** ( {* ;} *objet* ; *menuContext* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"menuContext",
					"Boolean",
					"->",
					"Vrai = activer menu contextuel, Faux = désactiver menu contextuel"
				]
			],
			"Summary": "La commande **OBJECT SET CONTEXT MENU** vous permet d’activer ou de désactiver, pour le process courant, l’association d’un menu contextuel par défaut à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET COORDINATES": {
			"Syntax": "**OBJECT SET COORDINATES** ( {* ;} *objet* ; *gauche* ; *haut* {; *droite* ; *bas*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"Integer",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"gauche",
					"Integer",
					"->",
					"Coordonnée gauche de l’objet en pixels"
				],
				[
					"haut",
					"Integer",
					"->",
					"Coordonnée supérieure de l’objet en pixels"
				],
				[
					"droite",
					"Integer",
					"->",
					"Coordonnée droite de l’objet en pixels"
				],
				[
					"bas",
					"Integer",
					"->",
					"Coordonnée inférieure de l’objet en pixels"
				]
			],
			"Summary": "La commande **OBJECT SET COORDINATES** permet de modifier l’emplacement et, optionnellement, la taille de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET CORNER RADIUS": {
			"Syntax": "**OBJECT SET CORNER RADIUS** ( {* ;} *objet* ; *rayon* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Champ ou variable (si * est omis)"
				],
				[
					"rayon",
					"Integer",
					"->",
					"Nouveau rayon des angles arrondis (en pixels)"
				]
			],
			"Summary": "La commande **OBJECT SET CORNER RADIUS** vous permet de modifier le rayon des angles du ou des objet(s) que vous avez passés dans le paramètre *objet*."
		},
		"OBJECT SET DATA SOURCE": {
			"Syntax": "**OBJECT SET DATA SOURCE** ( {* ;} *objet* ; *sourceDonnées* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"sourceDonnées",
					"Pointer",
					"->",
					"Pointeur vers la nouvelle source de données de l’objet"
				]
			],
			"Summary": "La commande **OBJECT SET DATA SOURCE** vous permet de modifier la source de données de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET DRAG AND DROP OPTIONS": {
			"Syntax": "**OBJECT SET DRAG AND DROP OPTIONS** ( {* ;} *objet* ; *glissable* ; *glissableAuto* ; *déposable* ; *déposableAuto* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"glissable",
					"Boolean",
					"->",
					"Glissable = Vrai, sinon Faux"
				],
				[
					"glissableAuto",
					"Boolean",
					"->",
					"Glisser automatique = Vrai, sinon Faux"
				],
				[
					"déposable",
					"Boolean",
					"->",
					"Déposable = Vrai, sinon Faux"
				],
				[
					"déposableAuto",
					"Boolean",
					"->",
					"Déposer automatique = Vrai, sinon Faux"
				]
			],
			"Summary": "La commande **OBJECT SET DRAG AND DROP OPTIONS** permet de définir ou de modifier dynamiquement les options de glisser-déposer pour l’objet ou les objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET ENABLED": {
			"Syntax": "**OBJECT SET ENABLED** ( {* ;} *objet* ; *actif* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"actif",
					"Boolean",
					"->",
					"Vrai = objet(s) activé(s), Faux sinon"
				]
			],
			"Summary": "La commande **OBJECT SET ENABLED** permet d’activer ou d’inactiver l’objet ou le groupe d’objets désigné par *objet* dans le formulaire courant."
		},
		"OBJECT SET ENTERABLE": {
			"Syntax": "**OBJECT SET ENTERABLE** ( {* ;} *objet* ; *saisissable* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une table, un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Table ou Champ ou Variable (si * omis)"
				],
				[
					"saisissable",
					"Boolean, Integer",
					"->",
					"Booléen : Vrai=saisissable, Faux=non saisissable<br/>Entier long : 0=non saisissable, 1=saisissable, 2=non saisissable non focusable"
				]
			],
			"Summary": "**OBJECT SET ENTERABLE** rend saisissable ou non saisissable le ou les objet(s) de formulaire désigné(s) par *objet* et peut fixer l'attribut saisissable."
		},
		"OBJECT SET EVENTS": {
			"Syntax": "**OBJECT SET EVENTS** ( {* ;} *objet* ; *tabEvénements* ; *mode* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet ou \"\" pour désigner le formulaire (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"tabEvénements",
					"Integer array",
					"->",
					"Tableau d’événements à définir"
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode d’activation des événements définis dans tabEvénements"
				]
			],
			"Summary": "La commande **OBJECT SET EVENTS** vous permet de modifier, pour le process courant, la configuration des événements formulaire du formulaire, de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET FILTER": {
			"Syntax": "**OBJECT SET FILTER** ( {* ;} *objet* ; *filtreSaisie* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d'objet (chaîne) Si omis = objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Champ ou Variable (si * omis)"
				],
				[
					"filtreSaisie",
					"Text",
					"->",
					"Nouveau filtre de saisie pour la zone saisissable"
				]
			],
			"Summary": "**OBJECT SET FILTER** remplace le filtre de saisie pour *objet* par *filtreSaisie* dans le formulaire courant affiché à l'écran."
		},
		"OBJECT SET FOCUS RECTANGLE INVISIBLE": {
			"Syntax": "**OBJECT SET FOCUS RECTANGLE INVISIBLE** ( {* ;} *objet* ; *invisible* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"invisible",
					"Boolean",
					"->",
					"Vrai = rectangle focus caché, Faux = rectangle focus visible"
				]
			],
			"Summary": "La commande **OBJECT SET FOCUS RECTANGLE INVISIBLE** permet de définir ou de modifier dynamiquement l’option d’invisibilité du rectangle de focus de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET FONT SIZE": {
			"Syntax": "**OBJECT SET FONT SIZE** ( {* ;} *objet* ; *taille* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d'objet (chaîne) Si omis = objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Champ ou variable (si * est omis)"
				],
				[
					"taille",
					"Integer",
					"->",
					"Taille de police en points"
				]
			],
			"Summary": "**OBJECT SET FONT SIZE** définit la taille de la police du ou des objet(s) de formulaire spécifié(s) par *objet*."
		},
		"OBJECT SET FONT STYLE": {
			"Syntax": "**OBJECT SET FONT STYLE** ( {* ;} *objet* ; *style* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d'objet (chaîne) Si omis = objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Champ ou variable (si * est omis)"
				],
				[
					"style",
					"Integer",
					"->",
					"Style de police"
				]
			],
			"Summary": "**OBJECT SET FONT STYLE** assigne le style de police *style* à ou aux objet(s) de formulaire désigné(s) par *objet*."
		},
		"OBJECT SET FONT": {
			"Syntax": "**OBJECT SET FONT** ( {* ;} *objet* ; *police* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = objet est un nom d'objet (chaîne) Si omis = objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Champ ou Variable (si * omis)"
				],
				[
					"police",
					"Text",
					"->",
					"Nom de police de caractères"
				]
			],
			"Summary": "**OBJECT SET FONT** affiche *objet* avec la police définie dans le paramètre *police*."
		},
		"OBJECT SET FORMAT": {
			"Syntax": "**OBJECT SET FORMAT** ( {* ;} *objet* ; *formatAffich* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Champ ou Variable (si * omis)"
				],
				[
					"formatAffich",
					"Text",
					"->",
					"Nouveau format d'affichage de l'objet"
				]
			],
			"Summary": "**OBJECT SET FORMAT** remplace le format d'affichage du ou des objet(s) spécifié(s) par *objet* avec le format que vous avez passé dans *formatAffich*."
		},
		"OBJECT SET HELP TIP": {
			"Syntax": "**OBJECT SET HELP TIP** ( {* ;} *objet* ; *messageAide* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"messageAide",
					"Text",
					"->",
					"Contenu du message d’aide"
				]
			],
			"Summary": "La commande **OBJECT SET HELP TIP** permet de définir ou de modifier dynamiquement le message d’aide associé à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET HORIZONTAL ALIGNMENT": {
			"Syntax": "**OBJECT SET HORIZONTAL ALIGNMENT** ( {* ;} *objet* ; *alignement* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est passé) ou Champ ou variable (si * est omis)"
				],
				[
					"alignement",
					"Integer",
					"->",
					"Code d’alignement"
				]
			],
			"Summary": "La commande **OBJECT SET HORIZONTAL ALIGNMENT** vous permet de fixer le type d’alignement horizontal appliqué à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET INDICATOR TYPE": {
			"Syntax": "**OBJECT SET INDICATOR TYPE** ( {* ;} *objet* ; *indicateur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"indicateur",
					"Integer",
					"->",
					"Type d’indicateur"
				]
			],
			"Summary": "La commande **OBJECT SET INDICATOR TYPE** vous permet de modifier le type d’indicateur de progression du ou des thermomètre(s) désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET KEYBOARD LAYOUT": {
			"Syntax": "**OBJECT SET KEYBOARD LAYOUT** ( {* ;} *objet* ; *codeLangue* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable ou champ (si * est omis)"
				],
				[
					"codeLangue",
					"Text",
					"->",
					"Code de langue RFC3066 ISO639 et ISO3166, \"\" = pas de changement"
				]
			],
			"Summary": "La commande **OBJECT SET KEYBOARD LAYOUT** vous permet de définir ou de modifier dynamiquement la configuration clavier associée à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET LIST BY NAME": {
			"Syntax": "**OBJECT SET LIST BY NAME** ( {* ;} *objet* {; *typeListe*}; énumération )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Champ ou Variable (si * omis)"
				],
				[
					"typeListe",
					"Integer",
					"->",
					"Type de liste : Liste énumération, Liste obligations ou Liste exclusions"
				],
				[
					"énumération",
					"Text",
					"->",
					"Nom de l'énumération (définie en mode Développement) ou \"\" pour dissocier l’énumération"
				]
			],
			"Summary": "La commande **OBJECT SET LIST BY NAME** définit, remplace ou dissocie l'*énumération* associée à l'objet ou au groupe d'objets désigné(s) par *objet*."
		},
		"OBJECT SET LIST BY REFERENCE": {
			"Syntax": "**OBJECT SET LIST BY REFERENCE** ( {* ;} *objet* {; *typeListe*}; *liste* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"typeListe",
					"Integer",
					"->",
					"Type de liste : Liste énumération, Liste obligations ou Liste exclusions"
				],
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de liste"
				]
			],
			"Summary": "La commande **OBJECT SET LIST BY REFERENCE** définit ou remplace l’énumération associée à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**, avec la liste hiérarchique référencée dans le paramètre *liste*."
		},
		"OBJECT SET MAXIMUM VALUE": {
			"Syntax": "**OBJECT SET MAXIMUM VALUE** ( {* ;} *objet* ; *valeurMaxi* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"valeurMaxi",
					"Date, Time, Number",
					"->",
					"Valeur maximale pour l’objet"
				]
			],
			"Summary": "La commande **OBJECT SET MAXIMUM VALUE** permet de modifier la valeur maximum de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET MINIMUM VALUE": {
			"Syntax": "**OBJECT SET MINIMUM VALUE** ( {* ;} *objet* ; *valeurMini* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"valeurMini",
					"Date, Time, Number",
					"->",
					"Valeur minimale pour l’objet"
				]
			],
			"Summary": "La commande **OBJECT SET MINIMUM VALUE** permet de modifier la valeur minimum de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET MULTILINE": {
			"Syntax": "**OBJECT SET MULTILINE** ( {* ;} *objet* ; *multiLigne* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"multiLigne",
					"Integer",
					"->",
					"Statut de la propriété multiligne"
				]
			],
			"Summary": "La commande **OBJECT SET MULTILINE** vous permet de modifier la propriété \"Multilignes\" de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET PLACEHOLDER": {
			"Syntax": "**OBJECT SET PLACEHOLDER** ( {* ;} *objet* ; *texteExemple* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"texteExemple",
					"Text",
					"->",
					"Texte d’exemple associé à l’objet"
				]
			],
			"Summary": "La commande **OBJECT SET PLACEHOLDER** vous permet d’associer un texte d’exemple à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET PRINT VARIABLE FRAME": {
			"Syntax": "**OBJECT SET PRINT VARIABLE FRAME** ( {* ;} *objet* ; *tailleVariable* {; *fixeSousForm*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"tailleVariable",
					"Boolean",
					"->",
					"Vrai = Impression taille variable, Faux = Impression taille fixe"
				],
				[
					"fixeSousForm",
					"Integer",
					"->",
					"Options d’impression en taille fixe des sous-formulaires"
				]
			],
			"Summary": "La commande **OBJECT SET PRINT VARIABLE FRAME** vous permet de modifier la propriété d’impression en taille variable de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET RESIZING OPTIONS": {
			"Syntax": "**OBJECT SET RESIZING OPTIONS** ( {* ;} *objet* ; *horizontal* ; *vertical* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"horizontal",
					"Integer",
					"->",
					"Option de redimensionnement horizontal"
				],
				[
					"vertical",
					"Integer",
					"->",
					"Option de redimensionnement vertical"
				]
			],
			"Summary": "La commande **OBJECT SET RESIZING OPTIONS** permet de définir ou de modifier dynamiquement les options de redimensionnement de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET RGB COLORS": {
			"Syntax": "**OBJECT SET RGB COLORS** ( {* ;} *objet* ; *couleurAvantPlan* {; *couleurArrièrePlan* {; *couleurArrièrePlanAlt*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Champ ou Variable (si * est omis)"
				],
				[
					"couleurAvantPlan",
					"Text, Integer",
					"->",
					"Valeur de la couleur RVB d'avant-plan"
				],
				[
					"couleurArrièrePlan",
					"Text, Integer",
					"->",
					"Valeur de la couleur RVB d'arrière-plan"
				],
				[
					"couleurArrièrePlanAlt",
					"Text, Integer",
					"->",
					"Valeur de la couleur RVB d'arrière-plan alternée"
				]
			],
			"Summary": "La commande **OBJECT SET RGB COLORS** modifie les couleurs d'avant-plan et d'arrière-plan du ou des objet(s) défini(s) par le paramètre *objet* et le paramètre optionnel *\\**."
		},
		"OBJECT SET SCROLL POSITION": {
			"Syntax": "**OBJECT SET SCROLL POSITION** ( * ; *objet* {; *positionLigne* {; *positionH*}}{; *} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne)Si omis, objet est une table, un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Table, champ ou variable (si * est omis)"
				],
				[
					"positionLigne",
					"Integer",
					"->",
					"Numéro de ligne à afficher ou Défilement vertical en pixels (images)"
				],
				[
					"positionH",
					"Integer",
					"->",
					"Numéro de colonne à afficher (list box) ou<br/>Défilement horizontal en pixels (images)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Afficher la ligne (et la colonne si le paramètre positionH est passé) en première position après défilement (listes)Appliquer un défilement relatif (images)"
				]
			],
			"Summary": "La commande **OBJECT SET SCROLL POSITION** permet de faire défiler le contenu de plusieurs types d'objets : lignes d’un sous-formulaire, d’un formulaire liste affiché via la commande MODIFY SELECTION ou DISPLAY SELECTION, ou d'une liste hiérarchique, lignes et colonnes d'une List box ou encore pixels d'une image."
		},
		"OBJECT SET SCROLLBAR": {
			"Syntax": "**OBJECT SET SCROLLBAR** ( {* ;} *objet* ; *horizontal* ; *vertical* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d’objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d’objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"horizontal",
					"Boolean, Integer",
					"->",
					"Visibilité de la barre horizontale"
				],
				[
					"vertical",
					"Boolean, Integer",
					"->",
					"Visibilité de la barre verticale"
				]
			],
			"Summary": "La commande **OBJECT SET SCROLLBAR** permet d’afficher ou de masquer les barres de défilement horizontale et/ou verticale dans l’objet désigné par les paramètres *objet* et *\\**."
		},
		"OBJECT SET SHORTCUT": {
			"Syntax": "**OBJECT SET SHORTCUT** ( {* ;} *objet* ; *touche* {; *modifiers*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"touche",
					"Text",
					"->",
					"Touche à associer à l’objet"
				],
				[
					"modifiers",
					"Integer",
					"->",
					"Masque ou combinaison de masques de touche(s) de modification"
				]
			],
			"Summary": "La commande **OBJECT SET SHORTCUT** permet de définir ou de modifier dynamiquement l’équivalent clavier associé à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET STYLE SHEET": {
			"Syntax": "**OBJECT SET STYLE SHEET** ( {* ;} *objet* ; *nomFeuilleStyle* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"nomFeuilleStyle",
					"Text",
					"->",
					"Nom de la feuille de style"
				]
			],
			"Summary": "La commande **OBJECT SET STYLE SHEET** vous permet de modifier, pour le process courant, la feuille de style associée à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET SUBFORM CONTAINER VALUE": {
			"Syntax": "**OBJECT SET SUBFORM CONTAINER VALUE** ( *value* )",
			"Params": [
				[
					"value",
					"any",
					"->",
					"New value for the data source"
				]
			]
		},
		"OBJECT SET SUBFORM": {
			"Syntax": "**OBJECT SET SUBFORM** ( {* ;} *objet* {; *laTable*}; *sousFormDetail* {; *sousFormListe*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"laTable",
					"Table",
					"->",
					"Table du formulaire (si formulaire table)"
				],
				[
					"sousFormDetail",
					"Text, Object",
					"->",
					"Nom (chaîne) du formulaire détail du sous-formulaire, ouChemin POSIX (chaîne) d'un fichier .json décrivant le formulaire détail, ouObjet décrivant le formulaire détail"
				],
				[
					"sousFormListe",
					"Text, Object",
					"->",
					"Nom (chaîne) du formulaire liste du sous-formulaire, ouChemin POSIX (chaîne) d'un fichier .json décrivant le formulaire liste, ouObjet décrivant le formulaire liste (formulaire table)"
				]
			],
			"Summary": "La commande **OBJECT SET SUBFORM** vous permet de modifier dynamiquement le formulaire détaillé ainsi que, optionnellement, le formulaire liste écran associé à l’objet sous-formulaire désigné par les paramètres *objet* et *\\**."
		},
		"OBJECT SET TEXT ORIENTATION": {
			"Syntax": "**OBJECT SET TEXT ORIENTATION** ( {* ;} *objet* ; *orientation* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"orientation",
					"Integer",
					"->",
					"Valeur d’orientation de l’objet"
				]
			],
			"Summary": "La commande **OBJECT SET TEXT ORIENTATION** vous permet de modifier l’orientation du contenu de l’objet ou des objets désigné(s) par les paramètres *objet* et *\\** pour le process courant."
		},
		"OBJECT SET THREE STATES CHECKBOX": {
			"Syntax": "**OBJECT SET THREE STATES CHECKBOX** ( {* ;} *objet* ; *troisEtats* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"troisEtats",
					"Boolean",
					"->",
					"Vrai = case à cocher à trois états, Faux = case à cocher standard"
				]
			],
			"Summary": "La commande **OBJECT SET THREE STATES CHECKBOX** vous permet de modifier, pour le process courant, la propriété \"Trois états\" de la ou des case(s) à cocher désignée(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET TITLE": {
			"Syntax": "**OBJECT SET TITLE** ( {* ;} *objet* ; *libellé* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"libellé",
					"Text",
					"->",
					"Nouveau libellé de l'objet"
				]
			],
			"Summary": "La commande **OBJECT SET TITLE** change le libellé du ou des objets(s) spécifié(s) dans le paramètre *objet* et le remplace par la valeur définie dans le paramètre *libellé* *."
		},
		"OBJECT SET VALUE": {
			"Syntax": "**OBJECT SET VALUE** ( *nomObjet* ; *valeur* )",
			"Params": [
				[
					"nomObjet",
					"Text",
					"->",
					"Nom de l'objet"
				],
				[
					"valeur",
					"any",
					"->",
					"Nouvelle valeur des sources de données de l'objet de formulaire"
				]
			],
			"Summary": "**OBJECT SET VALUE** fixe la *valeur* des sources de données courantes pour les objets formulaires désignés par le paramètre *nomObjet*."
		},
		"OBJECT SET VERTICAL ALIGNMENT": {
			"Syntax": "**OBJECT SET VERTICAL ALIGNMENT** ( {* ;} *objet* ; *alignement* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable (si * est omis)"
				],
				[
					"alignement",
					"Integer",
					"->",
					"Code d’alignement"
				]
			],
			"Summary": "La commande **OBJECT SET VERTICAL ALIGNMENT** vous permet de modifier par programmation le type d’alignement vertical appliqué à l’objet ou aux objets désigné(s) par les paramètres *objet* et *\\**."
		},
		"OBJECT SET VISIBLE": {
			"Syntax": "**OBJECT SET VISIBLE** ( {* ;} *objet* ; *visible* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est passé) ou Champ ou Variable (si * est omis)"
				],
				[
					"visible",
					"Boolean",
					"->",
					"Vrai = visible, Faux = invisible"
				]
			],
			"Summary": "La commande **OBJECT SET VISIBLE** affiche ou masque le ou les objet(s) défini(s) par les paramètres *objet* et *\\**."
		},
		"Object to path": {
			"Syntax": "**Object to path** ( *objetChemin* ) : Text",
			"Params": [
				[
					"objetChemin",
					"Object",
					"->",
					"Objet décrivant un contenu de chemin"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin de fichier ou de dossier"
				]
			],
			"Summary": "La commande **Object to path** retourne un chemin (chaîne) basé sur les informations passées dans le paramètre *objetChemin*."
		},
		"OLD RELATED MANY": {
			"Syntax": "**OLD RELATED MANY** ( *leChamp* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ recevant un lien"
				]
			],
			"Summary": "**OLD RELATED MANY** fonctionne comme la commande RELATE MANY, à la différence près que **OLD RELATED MANY** utilise l'ancienne valeur du champ pour activer le lien."
		},
		"OLD RELATED ONE": {
			"Syntax": "**OLD RELATED ONE** ( *leChamp* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ N"
				]
			],
			"Summary": "**OLD RELATED ONE** fonctionne de la même manière que RELATE ONE, à la différence près que **OLD RELATED ONE** utilise la valeur précédente de *leChamp* pour établir la relation."
		},
		"Old": {
			"Syntax": "**Old** ( *leChamp* ) : any",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ dont vous voulez obtenir l'ancienne valeur"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur originale de champ"
				]
			],
			"Summary": "La commande **Old** retourne la valeur qui était stockée dans *leChamp* avant qu'il n'ait été modifié par programmation ou pendant la saisie de données."
		},
		"On Backup Shutdown database method": {
			"Syntax": "On Backup Shutdown ($status)",
			"Params": [
				[
					"$status",
					"Integer",
					"<-",
					"0 = sauvegarde terminée normalement, autre valeur = erreur, interruption utilisateur ou code retourné par Sur démarrage sauvegarde"
				]
			],
			"Summary": "La **On Backup Shutdown database method** est appelée à chaque fois qu’une sauvegarde de la base vient de se terminer."
		},
		"On Backup Startup database method": {
			"Syntax": "**On Backup Startup database method**  -> $0",
			"Params": [
				[
					"$0",
					"Integer",
					"<-",
					"0 = sauvegarde autorisée, valeur autre que 0 = sauvegarde non autorisée"
				]
			],
			"Summary": "La **On Backup Startup database method**  est appelée à chaque fois qu’une sauvegarde de la base est sur le point d’avoir lieu (sauvegarde manuelle, sauvegarde automatique périodique ou via la commande BACKUP)."
		},
		"On Drop database method": {
			"Syntax": "**On Drop database method**",
			"Params": [],
			"Summary": "La **On Drop database method** est disponible dans les applications 4D en mode local ou distant."
		},
		"ON ERR CALL": {
			"Syntax": "**ON ERR CALL** ( *méthodErreur* {; *portée*} )",
			"Params": [
				[
					"méthodErreur",
					"Text",
					"->",
					"Méthode de gestion d'erreur à appeler ou Chaîne vide pour désinstaller la méthode"
				],
				[
					"portée",
					"Integer",
					"->",
					"Portée de la méthode de gestion d'erreur"
				]
			],
			"Summary": "**ON ERR CALL** installe la méthode projet dont le nom est passé dans *méthodErreur* comme méthode d'interception des erreurs pour le contexte d'exécution défini dans le projet courant."
		},
		"ON EVENT CALL": {
			"Syntax": "**ON EVENT CALL** ( *méthodeEvén* {; *nomProcess*} )",
			"Params": [
				[
					"méthodeEvén",
					"Text",
					"->",
					"Méthode d'événement à appeler ou Chaîne vide pour arrêter l'interception des événements"
				],
				[
					"nomProcess",
					"Text",
					"->",
					"Nom de process"
				]
			],
			"Summary": "**ON EVENT CALL** installe la méthode dont le nom est passé dans *méthodeEvén* comme méthode de gestion des événements."
		},
		"On Exit database method": {
			"Syntax": "**On Exit database method**",
			"Params": [],
			"Summary": "La méthode base **On Exit** est appelée une fois lorsque vous quittez la base."
		},
		"On Host Database Event database method": {
			"Syntax": "On Host Database Event (*$event* : Integer)",
			"Params": [
				[
					"$event",
					"Integer",
					"<-",
					"Code d'événement"
				]
			],
			"Summary": "La **On Host Database Event database method** permet aux composants 4D d’exécuter du code lors de l’ouverture et de la fermeture de la base hôte."
		},
		"On Mobile App Action database method": {
			"Syntax": "**mobileInfo** -> On Mobile App Action database method : Object",
			"Params": [
				[
					"mobileInfo",
					"Object",
					"->",
					"Information passée par l'application mobile"
				],
				[
					"status",
					"Object",
					"<-",
					"Statut de l'action & synchronisation des données"
				]
			],
			"Summary": "**Documentation déplacée**"
		},
		"On Mobile App Authentication database method": {
			"Syntax": "**On Mobile App Authentication database method** ( *mobileInfo* ; *status* )",
			"Params": [
				[
					"mobileInfo",
					"Object",
					"->",
					"Information passée par l'application mobile"
				],
				[
					"status",
					"Object",
					"<-",
					"Statut de l'authentification"
				]
			],
			"Summary": "**Documentation déplacée**\n\nLa documentation de cette méthode base a été mise à jour et déplacée vers [developer."
		},
		"On REST Authentication database method": {
			"Syntax": "$1, $2, $3, $4 -> On REST Authentication database method -> $0",
			"Params": [
				[
					"$1",
					"Texte",
					"<-",
					"Nom d’utilisateur"
				],
				[
					"$2",
					"Texte",
					"<-",
					"Mot de passe"
				],
				[
					"$3",
					"Booléen",
					"<-",
					"Vrai = mode Digest, Faux = mode Basic"
				],
				[
					"$4",
					"Texte",
					"<-",
					"Ip address of the caller"
				],
				[
					"$0",
					"Booléen",
					"<-",
					"Vrai = requête acceptée, Faux = requête rejetée"
				]
			],
			"Summary": "La **On REST Authentication database method** est obsolète dans les projets à partir de 4D 20 R6."
		},
		"On Server Close Connection database method": {
			"Syntax": "On Server Close Connection ($user : Integer ; $id : Integer ; $toIgnore : Integer)",
			"Params": [
				[
					"$user",
					"Integer",
					"<-",
					"Numéro d'utilisateur utilisé en interne par 4D Server pour identifier les utilisateurs"
				],
				[
					"$id",
					"Integer",
					"<-",
					"Numéro de connexion utilisé en interne par 4D Server pour identifier une connexion"
				],
				[
					"$toIgnore",
					"Integer",
					"<-",
					"Obsolète : Retourne toujours 0 mais doit être déclaré"
				]
			],
			"Summary": "La **On Server Close Connection database method** est exécutée sur le poste serveur à chaque fois qu'un process 4D Client est refermé."
		},
		"On Server Open Connection database method": {
			"Syntax": "On Server Open Connection($user : Integer ; $id : Integer ; $toIgnore : Integer) -> $status : Boolean",
			"Params": [
				[
					"$user",
					"Integer",
					"<-",
					"Numéro d'utilisateur utilisé en interne par 4D Server pour identifier les utilisateurs"
				],
				[
					"$id",
					"Integer",
					"<-",
					"Numéro de connexion utilisé en interne par 4D Server pour identifier une connexion"
				],
				[
					"$toIgnore",
					"Integer",
					"<-",
					"Obsolète : Retourne toujours 0 (mais doit être déclaré)"
				],
				[
					"$status",
					"Integer",
					"<-",
					"0 ou omis = connexion acceptée, autre valeur = connexion refusée"
				]
			],
			"Summary": "La **On Server Open Connection database method** est appelée une fois sur la machine serveur chaque fois qu’un poste 4D distant démarre un process de connexion."
		},
		"On Server Shutdown database method": {
			"Syntax": "**On Server Shutdown database method**",
			"Params": [],
			"Summary": "La **On Server Shutdown database method** est appelée une fois sur le poste serveur lorsque la base courante est refermée sur 4D Server."
		},
		"On Server Startup database method": {
			"Syntax": "**On Server Startup database method**",
			"Params": [],
			"Summary": "La méthode base Sur démarrage serveur est appelée une fois sur le poste serveur lorsque vous ouvrez une base avec 4D Server."
		},
		"On SQL Authentication database method": {
			"Syntax": "On SQL Authentication($user : Text ; $pw : Text ; $ip : Text) -> $result : Boolean",
			"Params": [
				[
					"$user",
					"Texte",
					"<-",
					"Nom d’utilisateur"
				],
				[
					"$pw",
					"Texte",
					"<-",
					"Mot de passe"
				],
				[
					"$ip",
					"Texte",
					"<-",
					"(Facultatif) Adresse IP du client à l’origine de la requête"
				],
				[
					"$result",
					"Booléen",
					"<-",
					"Vrai = requête acceptée, Faux = requête rejetée"
				]
			],
			"Summary": "La **On SQL Authentication database method** permet de filtrer les requêtes adressées au serveur SQL intégré de 4D."
		},
		"On Startup database method": {
			"Syntax": "**On Startup database method**",
			"Params": [],
			"Summary": "La **On Startup database method** est exécutée une seule fois, au moment de l'ouverture de la base."
		},
		"On System Event database method": {
			"Syntax": "On System Event($event : Integer)",
			"Params": [
				[
					"$event",
					"Integer",
					"<-",
					"Code d'événement"
				]
			],
			"Summary": "La **On System Event database method** est appelée à chaque fois qu’un événement système se produit."
		},
		"On Web Authentication database method": {
			"Syntax": "On Web Authentication($url : Text ; $http : Text ; $ipBrowser : Text ; $ipServer : Text ; $user : Text ; $pw : Text) -> $result : Boolean",
			"Params": [
				[
					"$url",
					"Texte",
					"<-",
					"URL"
				],
				[
					"$http",
					"Texte",
					"<-",
					"En-tête + Corps HTTP"
				],
				[
					"$ipBrowser",
					"Texte",
					"<-",
					"Adresse IP du navigateur"
				],
				[
					"$ipServer",
					"Texte",
					"<-",
					"Adresse IP appelée du serveur"
				],
				[
					"$user",
					"Texte",
					"<-",
					"Nom d’utilisateur"
				],
				[
					"$pw",
					"Texte",
					"<-",
					"Mot de passe"
				],
				[
					"$result",
					"Booléen",
					"<-",
					"Vrai = requête acceptée, Faux = requête rejetée"
				]
			],
			"Summary": "La **On Web Authentication database method** est chargée de gérer les accès au moteur de serveur Web."
		},
		"On Web Connection database method": {
			"Syntax": "On Web Connection($url : Text ; $http : Text ; $ipBrowser : Text ; $ipServer : Text ; $user : Text ; $pw : Text) -> $result : Boolean",
			"Params": [
				[
					"$url",
					"Texte",
					"<-",
					"URL"
				],
				[
					"$http",
					"Texte",
					"<-",
					"En-tête + corps HTTP"
				],
				[
					"$ipBrowser",
					"Texte",
					"<-",
					"Adresse IP du navigateur"
				],
				[
					"$ipServer",
					"Texte",
					"<-",
					"Adresse IP appelée du serveur"
				],
				[
					"$user",
					"Texte",
					"<-",
					"Nom d’utilisateur"
				],
				[
					"$pw",
					"Texte",
					"<-",
					"Mot de passe"
				]
			],
			"Summary": "La **On Web Connection database method** peut être appelée dans les cas suivants :\n\n* le serveur Web reçoit une requête débutant par l'URL *4DCGI*."
		},
		"On Web Legacy Close Session database method": {
			"Syntax": "**On Web Legacy Close Session database method**",
			"Params": [],
			"Summary": "Cette méthode base peut être utilisée uniquement avec d'**anciennes sessions Web**, disponibles dans les bases de données converties à partir de versions antérieures à 4D v18 R6\\."
		},
		"ONE RECORD SELECT": {
			"Syntax": "**ONE RECORD SELECT** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle réduire la sélection à un enregistrement"
				]
			],
			"Summary": "La commande **ONE RECORD SELECT** réduit la sélection courante de *laTable* à l'enregistrement courant."
		},
		"OPEN ADMINISTRATION WINDOW": {
			"Syntax": "**OPEN ADMINISTRATION WINDOW**",
			"Params": [],
			"Summary": "La commande **OPEN ADMINISTRATION WINDOW** affiche la fenêtre d’administration du serveur sur le poste qui l’exécute."
		},
		"OPEN COLOR PICKER": {
			"Syntax": "**OPEN COLOR PICKER** {( *texteOuFond* )}",
			"Params": [
				[
					"texteOuFond",
					"Integer",
					"->",
					"0 ou omis = couleur du texte, 1 = couleur du fond du texte"
				]
			],
			"Summary": "La commande **OPEN COLOR PICKER** affiche la boîte de dialogue de sélection de couleur du système."
		},
		"OPEN DATA FILE": {
			"Syntax": "**OPEN DATA FILE** ( *cheminAccès* )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Nom ou chemin d’accès complet du fichier de données à ouvrir"
				]
			],
			"Summary": "La commande **OPEN DATA FILE** permet de changer à la volée le fichier de données ouvert par l’application 4D."
		},
		"OPEN DATABASE": {
			"Syntax": "**OPEN DATABASE** ( *cheminFichier* )",
			"Params": [
				[
					"cheminFichier",
					"Text",
					"->",
					"Nom ou chemin d'accès complet du fichier de base de données à ouvrir (.4db, .4dc, .4dbase ou .4dlink)"
				]
			],
			"Summary": "La commande **OPEN DATABASE** referme la base de données 4D courante et ouvre à la volée la base désignée par le paramètre *cheminFichier*."
		},
		"Open document": {
			"Syntax": "**Open document** ( *nomFichier* {; *typeFichier*}{; *mode*} ) : Time",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du document ou Chemin d'accès complet au document ou Chaîne vide pour afficher la boîte de dialogue"
				],
				[
					"typeFichier",
					"Text",
					"->",
					"Liste des types de documents à filtrer, ou \"*\" pour ne pas filtrer les documents"
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode d’ouverture du document"
				],
				[
					"Résultat",
					"Time",
					"<-",
					"Numéro de référence du document"
				]
			],
			"Summary": "La commande **Open document** ouvre le document dont vous avez passé le nom dans *nomFichier*."
		},
		"OPEN FONT PICKER": {
			"Syntax": "**OPEN FONT PICKER**",
			"Params": [],
			"Summary": "La commande **OPEN FONT PICKER** affiche la boîte de dialogue de sélection de police du système."
		},
		"Open form window": {
			"Syntax": "**Open form window** ( {*laTable* ;} *nomForm* {; *type* {; *posH* {; *posV* {; *}}}} ) : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table du formulaire ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomForm",
					"Text, Object",
					"->",
					"Nom du formulaire table ou projet (chaîne), ouChemin POSIX (chaîne) d'un fichier .json décrivant le formulaire, ouObjet décrivant le formulaire"
				],
				[
					"type",
					"Integer",
					"->",
					"Type de la fenêtre"
				],
				[
					"posH",
					"Integer",
					"->",
					"Position horizontale de la fenêtre"
				],
				[
					"posV",
					"Integer",
					"->",
					"Position verticale de la fenêtre"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Conserver la position et la taille précédentes de la fenêtre"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de la fenêtre"
				]
			],
			"Summary": "La commande **Open form window** crée une nouvelle fenêtre utilisant les propriétés de taille et de redimensionnement du formulaire *nomForm*, passé en paramètre."
		},
		"OPEN PRINTING JOB": {
			"Syntax": "**OPEN PRINTING JOB**",
			"Params": [],
			"Summary": "La commande **OPEN PRINTING JOB** ouvre une tâche d’impression (print job) et y empile tous les ordres d’impression exécutés par la suite, tant que la commande CLOSE PRINTING JOB n’est pas appelée."
		},
		"Open resource file": {
			"Syntax": "**Open resource file** ( *resNomFichier* {; *typeFichier*} ) : Time",
			"Params": [
				[
					"resNomFichier",
					"Text",
					"->",
					"Nom ou chemin d'accès complet du fichier de ressources ou chaîne vide pour afficher la boîte de dialogue standard d'ouverture de fichiers"
				],
				[
					"typeFichier",
					"Text",
					"->",
					"Type de fichier Mac OS (chaîne de 4 caractères), ou extension de fichier Windows (chaîne de 1 à 3 caractères), ou fichier de ressources (\"res \" / .RES) si omis"
				],
				[
					"Résultat",
					"Time",
					"<-",
					"Numéro de référence du fichier de ressources"
				]
			],
			"Summary": "La commande **Open resource file** ouvre le fichier de ressources dont vous avez passé le nom ou le chemin d'accès complet dans le paramètre *resNomFichier*."
		},
		"OPEN RUNTIME EXPLORER": {
			"Syntax": "**OPEN RUNTIME EXPLORER**",
			"Params": [],
			"Summary": "La commande OPEN RUNTIME EXPLORER affiche l'Explorateur d'exécution dans une fenêtre flottante."
		},
		"OPEN SECURITY CENTER": {
			"Syntax": "**OPEN SECURITY CENTER**",
			"Params": [],
			"Summary": "La commande **OPEN SECURITY CENTER** provoque l’affichage de la fenêtre du Centre de sécurité et de maintenance (CSM)."
		},
		"OPEN SETTINGS WINDOW": {
			"Syntax": "**OPEN SETTINGS WINDOW** ( *sélecteur* {; *accès* {; *typePropriétés*}} )",
			"Params": [
				[
					"sélecteur",
					"Text",
					"->",
					"Clé désignant un thème ou une page de la boîte de dialogue des Préférences ou des Propriétés de la base"
				],
				[
					"accès",
					"Boolean",
					"->",
					"Vrai=Verrouiller les autres pages de la boîte de dialogue, Faux ou omis=Laisser actives les autres pages de la boîte de dialogue"
				],
				[
					"typePropriétés",
					"Integer",
					"->",
					"0 ou omis = Propriétés structure (mode standard), 1 = Propriétés utilisateur, 2 = Propriétés utilisateur pour données"
				]
			],
			"Summary": "La commande **OPEN SETTINGS WINDOW** provoque l’ouverture de la boîte de dialogue des Préférences 4D ou des Propriétés de la base courante et l’affichage des paramètres ou de la page correspondant à la clé passée dans le paramètre *sélecteur*."
		},
		"OPEN URL": {
			"Syntax": "**OPEN URL** ( *chemin* {; *nomApp*}{; *} )",
			"Params": [
				[
					"chemin",
					"Text",
					"->",
					"Chemin du document ou URL à ouvrir"
				],
				[
					"nomApp",
					"Text",
					"->",
					"Nom de l'application à utiliser"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = l’URL n’est pas traduit, Si omis = l’URL est traduit"
				]
			],
			"Summary": "La commande **OPEN URL** ouvre le fichier ou l'URL passé dans le paramètre *chemin* avec l'application éventuellement désignée par *nomApp*."
		},
		"Open window": {
			"Syntax": "**Open window** ( *gauche* ; *haut* ; *droite* ; *bas* {; *type* {; *titre* {; *caseFermeture*}}} ) : Integer",
			"Params": [
				[
					"gauche",
					"Integer",
					"->",
					"Coordonnée gauche de l'intérieur de la fenêtre"
				],
				[
					"haut",
					"Integer",
					"->",
					"Coordonnée supérieure de l'intérieur de la fenêtre"
				],
				[
					"droite",
					"Integer",
					"->",
					"Coordonnée droite de l'intérieur de la fenêtre"
				],
				[
					"bas",
					"Integer",
					"->",
					"Coordonnée inférieure de l'intérieur de la fenêtre"
				],
				[
					"type",
					"Integer",
					"->",
					"Type de la fenêtre"
				],
				[
					"titre",
					"Text",
					"->",
					"Titre de la fenêtre"
				],
				[
					"caseFermeture",
					"Text",
					"->",
					"Méthode à appeler en cas de double-clic sur la case du menu Système ou de clic sur la case de fermeture"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de la fenêtre"
				]
			],
			"Summary": "**Open window** ouvre une nouvelle fenêtre dont les dimensions sont définies par les quatre premiers paramètres"
		},
		"ORDER BY ATTRIBUTE": {
			"Syntax": "**ORDER BY ATTRIBUTE** ( {*laTable* ;} *champObjet* ; *cheminAttribut* ; > ou < {; *champObjet2* ; *cheminAttribut2* ; > ou <2 ; ... ; *champObjetN* ; *cheminAttributN* ; > ou <N} {; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle la sélection est triée ou Table par défaut si ce paramètre est omis"
				],
				[
					"champObjet",
					"Object",
					"->",
					"Champ objet dont les attributs sont à utiliser pour le tri"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Nom ou chemin d'attribut pour chaque niveau que l'on veut trier"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"Sens de tri pour chaque niveau : > pour trier par ordre ascendant, ou < pour trier par ordre descendant."
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d'exécution du tri"
				]
			],
			"Summary": "La commande **ORDER BY ATTRIBUTE** trie (réorganise) les enregistrements de la sélection courante de *laTable* pour le process courant, basé sur les contenus des *cheminAttribut* des *champObjet*."
		},
		"ORDER BY FORMULA": {
			"Syntax": "**ORDER BY FORMULA** ( *laTable* ; *formule* {; > ou <}{; *formule2* ; > ou <2 ; ... ; *formuleN* ; > ou <N} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle trier la sélection d'enregistrements"
				],
				[
					"formule",
					"Expression",
					"->",
					"Formule de tri des enregistrements (peut être de type Alphanumérique, Réel, Entier, Entier long, Date, Heure ou Booléen)"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"Ordre de tri pour chaque niveau : > ordre croissant ou < ordre décroissant"
				]
			],
			"Summary": "**ORDER BY FORMULA** trie (réordonne) les enregistrements de la sélection courante de *laTable* pour le process courant sur le critère de tri défini par *formule*."
		},
		"ORDER BY": {
			"Syntax": "**ORDER BY** ( {*laTable* ;}{ *leChamp* }{; > ou < }{; *leChamp2* ; > ou <2 ; ... ; *leChampN* ; > ou <N}{; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle réordonner la sélection courante ou Table par défaut si ce paramètre est omis"
				],
				[
					"leField",
					"Field",
					"->",
					"Champ sur lequel effectuer le tri pour chaque niveau"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"Sens du tri pour chaque niveau : > demander un tri croissant ou < demander un tri décroissant"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d'exécution du tri"
				]
			],
			"Summary": "**ORDER BY** trie (réordonne) les enregistrements de la sélection courante de *laTable* pour le process courant."
		},
		"Outside call": {
			"Syntax": "**Outside call**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le cycle d'exécution est appel extérieur"
				]
			],
			"Summary": "**Outside call** retourne Vrai pour le cycle d'exécution Appel extérieur."
		},
		"PAGE BREAK": {
			"Syntax": "**PAGE BREAK** {( * )}<br/>**PAGE BREAK** {( > )}",
			"Params": [
				[
					"* &#124; >",
					"Operator",
					"->",
					"* Annule l'impression lancée par Imprimer ligne ou > Rend l'impression prioritaire"
				]
			],
			"Summary": "La commande **PAGE BREAK** déclenche l'impression des données envoyées à l'imprimante et provoque un saut de page."
		},
		"Parse formula": {
			"Syntax": "**Parse formula** ( *formule* {; *options*}{; *messageErr*} ) : Text",
			"Params": [
				[
					"formule",
					"Text",
					"->",
					"Texte brut de la formule"
				],
				[
					"options",
					"Integer",
					"->",
					"Instructions d'entrée / sortie"
				],
				[
					"messageErr",
					"Text",
					"<-",
					"Message d'erreur (chaîne vide si pas d'erreur)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Formule avec transformation (texte brut)"
				]
			],
			"Summary": "La commande **Parse formula** inspecte le contenu de la *formule* 4D, vérifie sa syntaxe, et la retourne sous une forme normalisée."
		},
		"Pasteboard data size": {
			"Syntax": "**Pasteboard data size** ( *typeDonnées* ) : Integer",
			"Params": [
				[
					"typeDonnées",
					"Text",
					"->",
					"Type de données"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Taille (en octets) des données présentes dans le conteneur ou code d'erreur"
				]
			],
			"Summary": "**Pasteboard data size** vous permet de savoir s'il y a des données du type *typeDonnées* dans le conteneur de données."
		},
		"Path to object": {
			"Syntax": "**Path to object** ( *chemin* {; *typeChemin*} ) : Object",
			"Params": [
				[
					"chemin",
					"Text",
					"->",
					"Chemin"
				],
				[
					"typeChemin",
					"Integer",
					"->",
					"Type de syntaxe du chemin : Système (par défaut) ou  Posix"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet décrivant le contenu du chemin"
				]
			],
			"Summary": "La commande **Path to object** retourne un objet contenant les propriétés spécifiques du *chemin* passé en paramètre."
		},
		"PAUSE INDEXES": {
			"Syntax": "**PAUSE INDEXES** ( *laTable* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle suspendre les index"
				]
			],
			"Summary": "La commande **PAUSE INDEXES** désactive temporairement tous les index de *laTable*, hormis l’index de la clé primaire."
		},
		"PAUSE PROCESS": {
			"Syntax": "**PAUSE PROCESS** ( *process* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "**PAUSE PROCESS** suspend l'exécution de *process* jusqu'à ce qu'il soit remis en action par la comande RESUME PROCESS."
		},
		"PHP Execute": {
			"deprecated": true,
			"Syntax": "**PHP Execute** ( *cheminScript* {; *nomFonction* {; *résultatPHP* {; *param*} {; *param2* ; ... ; *paramN*}}} ) : Boolean",
			"Params": [
				[
					"cheminScript",
					"Text",
					"->",
					"Chemin d’accès au script PHP ou \"\" pour exécuter une fonction PHP"
				],
				[
					"nomFonction",
					"Text",
					"->",
					"Fonction PHP à exécuter"
				],
				[
					"résultatPHP",
					"*, Variable, Field",
					"<-",
					"Résultat d’exécution de la fonction PHP ou * pour ne pas recevoir de résultat"
				],
				[
					"param",
					"Text, Boolean, Real, Integer, Date, Time",
					"->",
					"Paramètre(s) de la fonction PHP"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = exécution correcte, Faux = erreur d’exécution"
				]
			],
			"Summary": "La commande **PHP Execute** permet d’exécuter un script ou une fonction PHP."
		},
		"PHP GET FULL RESPONSE": {
			"deprecated": true,
			"Syntax": "**PHP GET FULL RESPONSE** ( *stdOut* {; *libellésErr* ; *valeursErr*} {; *chpsEnteteHttp* {; *valeursEnteteHttp*}} )",
			"Params": [
				[
					"stdOut",
					"Text, Blob",
					"<-",
					"Contenu du buffer stdOut"
				],
				[
					"libellésErr",
					"Text array",
					"<-",
					"Libellés des erreurs"
				],
				[
					"valeursErr",
					"Text array",
					"<-",
					"Valeurs des erreurs"
				],
				[
					"chpsEnteteHttp",
					"Text array",
					"<-",
					"Noms des en-têtes HTTP"
				],
				[
					"valeursEnteteHttp",
					"Text array",
					"<-",
					"Valeurs des en-têtes HTTP"
				]
			],
			"Summary": "La commande **PHP GET FULL RESPONSE** vous permet d’obtenir des informations supplémentaires sur la réponse retournée par l’interpréteur PHP."
		},
		"PHP GET OPTION": {
			"deprecated": true,
			"Syntax": "**PHP GET OPTION** ( *option* ; *valeur* )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Option à lire"
				],
				[
					"valeur",
					"Boolean",
					"<-",
					"Valeur courante de l’option"
				]
			],
			"Summary": "La commande **PHP GET OPTION** permet de connaître la valeur courante d’une option relative à l’éxécution de scripts PHP."
		},
		"PHP SET OPTION": {
			"deprecated": true,
			"Syntax": "**PHP SET OPTION** ( *option* ; *valeur* {; *} )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Numéro d’option à définir"
				],
				[
					"valeur",
					"Boolean",
					"->",
					"Nouvelle valeur de l’option"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : la modification ne s’applique qu’à l’appel suivant"
				]
			],
			"Summary": "La commande **PHP SET OPTION** permet de définir des options spécifiques avant un appel à la commande PHP Execute."
		},
		"PICTURE CODEC LIST": {
			"Syntax": "**PICTURE CODEC LIST** ( *tabCodecs* {; *tabNoms*}{; *} )",
			"Params": [
				[
					"tabCodecs",
					"Text array",
					"<-",
					"Identifiants des codecs d’images disponibles"
				],
				[
					"tabNoms",
					"Text array",
					"<-",
					"Noms des codecs d’images"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Retourner la liste des codecs de lecture"
				]
			],
			"Summary": "La commande **PICTURE CODEC LIST** remplit le tableau *tabCodecs* avec la liste des identifiants des codecs d’images disponibles sur la machine où elle est exécutée."
		},
		"PICTURE LIBRARY LIST": {
			"Syntax": "**PICTURE LIBRARY LIST** ( *refsImages* ; *nomsImages* )",
			"Params": [
				[
					"refsImages",
					"Integer array",
					"<-",
					"Numéros de référence des images stockées dans la bibliothèque d'images"
				],
				[
					"nomsImages",
					"Text array",
					"<-",
					"Noms des images stockées dans la bibliothèque d'images"
				]
			],
			"Summary": "La commande **PICTURE LIBRARY LIST** retourne les numéros de référence et le nom des images stockées dans la bibliothèque d’images de la base de données."
		},
		"PICTURE PROPERTIES": {
			"Syntax": "**PICTURE PROPERTIES** ( *image* ; *largeur* ; *hauteur* {; *hOffset* {; *vOffset* {; *mode*}}} )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image sur laquelle obtenir les informations"
				],
				[
					"largeur",
					"Real",
					"<-",
					"Largeur de l'image exprimée en pixels"
				],
				[
					"hauteur",
					"Real",
					"<-",
					"Hauteur de l'image exprimée en pixels"
				],
				[
					"hOffset",
					"Integer",
					"<-",
					"Offset horizontal lorsque l'image est affichée en arrière-plan"
				],
				[
					"vOffset",
					"Integer",
					"<-",
					"Offset vertical lorsque l'image est affichée en arrière-plan"
				],
				[
					"mode",
					"Integer",
					"<-",
					"Mode de transfert lorsque l'image est affichée en arrière-plan"
				]
			],
			"Summary": "La commande **PICTURE PROPERTIES** retourne des informations sur l'image que vous avez passée dans le paramètre *image*."
		},
		"Picture size": {
			"Syntax": "**Picture size** ( *image* ) : Integer",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image pour laquelle vous voulez connaître la taille en octets"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Taille en octets de l'image"
				]
			],
			"Summary": "**Picture size** retourne la taille de l'image *image* en octets."
		},
		"PICTURE TO BLOB": {
			"Syntax": "**PICTURE TO BLOB** ( *image* ; *blobImage* ; *codec* )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Champ ou variable image"
				],
				[
					"blobImage",
					"Blob",
					"<-",
					"BLOB devant contenir l’image convertie"
				],
				[
					"codec",
					"Text",
					"->",
					"Identifiant de codec d'image"
				]
			],
			"Summary": "La commande **PICTURE TO BLOB** convertit une image stockée dans une variable ou un champ 4D dans un autre format, et place l’image résultante dans un BLOB."
		},
		"PLAY": {
			"Syntax": "**PLAY** ( *nomObjet* {; *asynchrone*} )",
			"Params": [
				[
					"nomObjet",
					"Text",
					"->",
					"Nom ou chemin de fichier son ou son systèmeChaîne vide pour stopper un son asynchrone"
				],
				[
					"asynchrone",
					"Integer",
					"->",
					"(Windows) Si passé : exécution asynchrone, si omis : exécution synchrone"
				]
			],
			"Summary": "La commande **PLAY** vous permet de jouer des fichiers de son ou multimedia."
		},
		"PLUGIN LIST": {
			"Syntax": "**PLUGIN LIST** ( *tabNuméros* ; *tabNoms* )",
			"Params": [
				[
					"tabNuméros",
					"Integer array",
					"<-",
					"Numéros des plug-ins"
				],
				[
					"tabNoms",
					"Text array",
					"<-",
					"Noms des plug-ins"
				]
			],
			"Summary": "La commande **PLUGIN LIST** remplit les tableaux *tabNuméros* et *tabNoms* avec les numéros et les noms des plug-ins chargés par l'application 4D et utilisables."
		},
		"POP RECORD": {
			"Syntax": "**POP RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle dépiler l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**POP RECORD** charge le premier enregistrement de la pile d'enregistrements de *laTable*, et en fait l'enregistrement courant."
		},
		"Pop up menu": {
			"Syntax": "**Pop up menu** ( *contenu* {; *parDéfaut* {; *coordX* ; *coordY*}} )  : Integer",
			"Params": [
				[
					"contenu",
					"Text",
					"->",
					"Définition du texte du menu"
				],
				[
					"parDéfaut",
					"Integer",
					"->",
					"Numéro de l'élément sélectionné par défaut"
				],
				[
					"coordX",
					"Integer",
					"->",
					"Coordonnée X du coin supérieur gauche"
				],
				[
					"coordY",
					"Integer",
					"->",
					"Coordonnée Y du coin supérieur gauche"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de l'élément de menu sélectionné"
				]
			],
			"Summary": "La commande **Pop up menu** fait apparaître un pop up à l'emplacement courant du curseur de la souris ou à l'emplacement défini par les paramètres facultatifs *coordX* et *coordY*."
		},
		"Position": {
			"Syntax": "**Position** ( àChercher ; *laChaîne* {; *début* {; *longTrouvée*}}{; *} ) -> Résultat <br/>\n**Position** ( àChercher ; *laChaîne* ; *début* ; *longTrouvée* ; *options* ) -> Résultat",
			"Params": [
				[
					"àChercher",
					"Text",
					"->",
					"Chaîne à rechercher"
				],
				[
					"laText",
					"Text",
					"->",
					"Chaîne dans laquelle effectuer la recherche"
				],
				[
					"début",
					"Integer",
					"->",
					"Position dans laChaîne où débuter la recherche"
				],
				[
					"longTrouvée",
					"Integer",
					"<-",
					"Longueur de la chaîne trouvée"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : évaluation basée sur les codes de caractères"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Position de la première occurrence de àChercher"
				],
				[
					"Position ( àChercher ; laChaîne ; début ; longTrouvée ; options ) -> Résultat"
				],
				[
					"Paramètre",
					"Type",
					"Description"
				],
				[
					"àChercher",
					"Text",
					"->",
					"Chaîne à rechercher"
				],
				[
					"laText",
					"Text",
					"->",
					"Chaîne dans laquelle effectuer la recherche"
				],
				[
					"début",
					"Integer",
					"->",
					"Position dans laChaîne où débuter la recherche"
				],
				[
					"longTrouvée",
					"Integer",
					"->",
					"Longueur de la chaîne trouvée"
				],
				[
					"options",
					"Integer",
					"->",
					"Critère(s) de recherche"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Position de la première occurrence de àChercher"
				]
			],
			"Summary": "**Position** retourne la position de la première occurrence de *àChercher* dans *laChaîne*."
		},
		"POST CLICK": {
			"Syntax": "**POST CLICK** ( *sourisX* ; *sourisY* {; *process*} {; *} )",
			"Params": [
				[
					"sourisX",
					"Integer",
					"->",
					"Coordonnée horizontale"
				],
				[
					"sourisY",
					"Integer",
					"->",
					"Coordonnée verticale"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process de destination ou File d'attente des événements de l'application si ce paramètre est omis ou si vous passez 0"
				],
				[
					"*",
					"Operator",
					"->",
					"Si spécifié, utiliser le système de coordonnées globales Si omis, utiliser le système de coordonnées locales"
				]
			],
			"Summary": "La commande **POST CLICK** simule un clic souris."
		},
		"POST EVENT": {
			"Syntax": "**POST EVENT** ( *quoi* ; *message* ; *quand* ; *sourisX* ; *sourisY* ; *modifiers* {; *process*} )",
			"Params": [
				[
					"quoi",
					"Integer",
					"->",
					"Type d'événement"
				],
				[
					"message",
					"Integer",
					"->",
					"Message de l'événement"
				],
				[
					"quand",
					"Integer",
					"->",
					"Moment de l'événement exprimé en ticks"
				],
				[
					"sourisX",
					"Integer",
					"->",
					"Coordonnée horizontale de la souris"
				],
				[
					"sourisY",
					"Integer",
					"->",
					"Coordonnée verticale de la souris"
				],
				[
					"modifiers",
					"Integer",
					"->",
					"Etat des touches Modifier"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process de destination ou File d'attente des événements de l'application si ce paramètre est omis ou si vous passez 0"
				]
			],
			"Summary": "La commande **POST EVENT** simule un événement (clavier ou souris)."
		},
		"POST KEY": {
			"Syntax": "**POST KEY** ( *code* {; *modifiers* {; *process*}} )",
			"Params": [
				[
					"code",
					"Integer",
					"->",
					"Code d'un caractère ou code de touche de fonction"
				],
				[
					"modifiers",
					"Integer",
					"->",
					"Etat des touches Modifier"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process de destination ou File d'attente des événements de l'application si paramètre omis ou égal à 0"
				]
			],
			"Summary": "La commande **POST KEY** simule la frappe d'une touche sur le clavier."
		},
		"POST OUTSIDE CALL": {
			"Syntax": "**POST OUTSIDE CALL** ( *process* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro du process"
				]
			],
			"Summary": "Cette commande était nommée **CALL PROCESS** dans les versions précédentes de 4D."
		},
		"PREVIOUS RECORD": {
			"Syntax": "**PREVIOUS RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle se placer sur l'enregistrement précédent de la sélection courante ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**PREVIOUS RECORD** place le pointeur d'enregistrement courant sur l'enregistrement précédent dans la sélection courante de *laTable* pour le process courant."
		},
		"PRINT LABEL": {
			"Syntax": "**PRINT LABEL** ( {*laTable* }{;}{ *nomFichier* {; * | >}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à imprimer ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Nom de fichier d'étiquettes sur disque"
				],
				[
					"* &#124; >",
					"Operator",
					"->",
					"* pour supprimer les boîtes de dialogue d'impression ou > pour ne pas réinitialiser les paramètres d'impression"
				]
			],
			"Summary": "**PRINT LABEL** vous permet d'imprimer des étiquettes à partir des données de la sélection de *laTable*."
		},
		"Print object": {
			"Syntax": "**Print object** ( {* ;} *objet* {; *posX* {; *posY* {; *largeur* {; *hauteur*}}}} ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * spécifié) ou Variable (si * omis)"
				],
				[
					"posX",
					"Integer",
					"->",
					"Emplacement horizontal de l'objet"
				],
				[
					"posY",
					"Integer",
					"->",
					"Emplacement vertical de l'objet"
				],
				[
					"largeur",
					"Integer",
					"->",
					"Largeur de l'objet (pixels)"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de l'objet (pixels)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = objet entièrement imprimé, Faux sinon"
				]
			],
			"Summary": "La commande **Print object** vous permet d’imprimer le ou les objet(s) de formulaire désigné(s) par les paramètres *objet* et *\\**, à l’emplacement défini par les paramètres *posX* et *posY*."
		},
		"PRINT OPTION VALUES": {
			"Syntax": "**PRINT OPTION VALUES** ( *option* ; *tabNoms* {; *tabInfo1* {; *tabInfo2*}} )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Numéro d’option"
				],
				[
					"tabNoms",
					"Text array",
					"<-",
					"Noms des valeurs"
				],
				[
					"tabInfo1",
					"Integer array",
					"<-",
					"Valeurs 1 de l’option"
				],
				[
					"tabInfo2",
					"Integer array",
					"<-",
					"Valeurs 2 de l’option"
				]
			],
			"Summary": "La commande **PRINT OPTION VALUES** retourne dans le tableau *tabNoms* la liste des noms de valeurs disponibles pour l’*option* d’impression définie."
		},
		"PRINT RECORD": {
			"Syntax": "**PRINT RECORD** ( {*laTable*}{;}{* | >} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle imprimer l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				],
				[
					"* &#124; >",
					"Opérateur",
					"->",
					"* pour supprimer les boîtes de dialogue d'impression ou > pour ne pas réinitialiser les paramètres d'impression"
				]
			],
			"Summary": "Cette commande provoque l'impression de l'enregistrement courant de *laTable*, sans modifier la sélection courante."
		},
		"PRINT SELECTION": {
			"Syntax": "**PRINT SELECTION** ( {*laTable*}{;}{* | >} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à laquelle appartient la sélection à imprimer ou Table par défaut si ce paramètre est omis"
				],
				[
					"* &#124; >",
					"Opérateur",
					"->",
					"* pour supprimer les boîtes de dialogue d'impression ou > pour ne pas réinitialiser les paramètres d'impression"
				]
			],
			"Summary": "La commande **PRINT SELECTION** imprime la sélection courante de *laTable*."
		},
		"Print settings to BLOB": {
			"Syntax": "**Print settings to BLOB** ( *paramImpression* ) : Integer",
			"Params": [
				[
					"paramImpression",
					"Blob",
					"<-",
					"Paramètres courants d'impression"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Code d'état : 1=Opération réussie, 0=Pas d'imprimante courante"
				]
			],
			"Summary": "La commande **Print settings to BLOB** sauvegarde les paramètres d'impression courants de 4D dans le BLOB *paramImpression*."
		},
		"PRINT SETTINGS": {
			"Syntax": "**PRINT SETTINGS** {( *typeDial* )}",
			"Params": [
				[
					"typeDial",
					"Integer",
					"->",
					"Boîte(s) de dialogue à afficher"
				]
			],
			"Summary": "La commande **PRINT SETTINGS** provoque l'affichage d'une boîte de dialogue d'impression."
		},
		"PRINTERS LIST": {
			"Syntax": "**PRINTERS LIST** ( *tabNoms* {; *tabNomsAlt* {; *tabModèles*}} )",
			"Params": [
				[
					"tabNoms",
					"Text array",
					"<-",
					"Noms des imprimantes"
				],
				[
					"tabNomsAlt",
					"Text array",
					"<-",
					"Windows : Emplacements des imprimantes, macOS : Noms personnalisés des imprimantes"
				],
				[
					"tabModèles",
					"Text array",
					"<-",
					"Modèles des imprimantes"
				]
			],
			"Summary": "La commande **PRINTERS LIST** remplit le ou les tableau(x) passé(s) en paramètre(s) avec les noms ainsi que, facultativement, les emplacements ou les noms personnalisés et les modèles des imprimantes disponibles pour le poste."
		},
		"Printing page": {
			"Syntax": "**Printing page**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de la page en cours d'impression"
				]
			],
			"Summary": "**Printing page** retourne le numéro de la page en cours d'impression."
		},
		"PROCESS 4D TAGS": {
			"Syntax": "**PROCESS 4D TAGS** ( *templateEntrée* ; *résultatSortie* {; *param*}{; *param2* ; ... ; *paramN*} )",
			"Params": [
				[
					"templateEntrée",
					"Text",
					"->",
					"Données contenant des balises à traiter"
				],
				[
					"résultatSortie",
					"Text",
					"<-",
					"Résultat de l'exécution du template"
				],
				[
					"param",
					"Expression",
					"->",
					"Paramètre(s) à passer au template en exécution"
				]
			],
			"Summary": "La commande **PROCESS 4D TAGS** provoque le traitement des balises de transformation 4D contenues dans le paramètre *templateEntrée* en leur injectant optionnellement des valeurs via le(s) paramètre(s) *param* et retourne le résultat dans *résultatSortie*."
		},
		"Process aborted": {
			"Syntax": "**Process aborted**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = le process est sur le point d’être interrompu, Faux = le process n’est pas sur le point d’être interrompu"
				]
			],
			"Summary": "La commande **Process aborted** retourne **Vrai** si le process dans lequel elle est appelée est sur le point d’être interrompu de manière inopinée — c’est-à-dire sans être parvenu au terme “normal” de son exécution."
		},
		"Process state": {
			"Syntax": "**Process state** ( *process* ) : Integer",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro du process"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Statut du process"
				]
			],
			"Summary": "La commande **Process state** retourne le statut du process dont le numéro est passé dans *process*."
		},
		"PUSH RECORD": {
			"Syntax": "**PUSH RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle empiler l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**PUSH RECORD** \"empile\" une copie de l'enregistrement courant de *laTable* dans la pile d'enregistrements de la table."
		},
		"QR BLOB TO REPORT": {
			"Syntax": "**QR BLOB TO REPORT** ( *zone* ; *blob* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB contenant l'état"
				]
			],
			"Summary": "La commande **QR BLOB TO REPORT** place l’état contenu dans le paramètre *blob* dans la zone d'état rapide désignée par le paramètre *zone*."
		},
		"QR Count columns": {
			"Syntax": "**QR Count columns** ( *zone* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de colonnes dans la zone"
				]
			],
			"Summary": "La commande **QR Count columns** retourne le nombre de colonnes présentes dans l'état rapide désigné par le paramètre *zone*."
		},
		"QR DELETE COLUMN": {
			"Syntax": "**QR DELETE COLUMN** ( *zone* ; *numColonne* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				]
			],
			"Summary": "La commande **QR DELETE COLUMN** supprime de la *zone* la colonne dont le numéro a été passé dans *numColonne*."
		},
		"QR DELETE OFFSCREEN AREA": {
			"Syntax": "**QR DELETE OFFSCREEN AREA** ( *zone* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				]
			],
			"Summary": "La commande **QR DELETE OFFSCREEN AREA** efface de la mémoire la zone hors écran dont la référence a été passée dans le paramètre *zone*."
		},
		"QR EXECUTE COMMAND": {
			"Syntax": "**QR EXECUTE COMMAND** ( *zone* ; *numCommande* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numCommande",
					"Integer",
					"->",
					"Commande de menu à exécuter"
				]
			],
			"Summary": "La commande **QR EXECUTE COMMAND** exécute la commande de bouton de la barre d'outils dont la référence est passée dans le paramètre *numCommande*."
		},
		"QR Find column": {
			"Syntax": "**QR Find column** ( *zone* ; *expression* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"expression",
					"Text, Pointer",
					"->",
					"Objet de colonne"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de colonne"
				]
			],
			"Summary": "La commande **QR Find column** retourne le numéro de la première colonne de la *zone* dont le contenu correspond à l'*expression* passée en paramètre."
		},
		"QR Get area property": {
			"Syntax": "**QR Get area property** ( *zone* ; *propriété* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"propriété",
					"Integer",
					"->",
					"Elément d'interface"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"1 = affiché, 0 = caché"
				]
			],
			"Summary": "La commande **QR Get area property** retourne 0 si l'élément d'interface dont la référence est passée dans le paramètre *propriété* est masqué dans la *zone*, sinon elle retourne 1\\."
		},
		"QR GET BORDERS": {
			"Syntax": "**QR GET BORDERS** ( *zone* ; *colonne* ; *ligne* ; *encadrement* ; *ligne* {; *couleur*} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"colonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"encadrement",
					"Integer",
					"->",
					"Valeur d'encadrement"
				],
				[
					"ligne",
					"Integer",
					"<-",
					"Epaisseur de trait"
				],
				[
					"couleur",
					"Integer",
					"<-",
					"Couleur de l'encadrement"
				]
			],
			"Summary": "La commande **QR GET BORDERS** retourne les attributs d'encadrement d'une cellule spécifique de *zone*."
		},
		"QR Get command status": {
			"Syntax": "**QR Get command status** ( *zone* ; *numCommande* {; *valeur*} ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numCommande",
					"Integer",
					"->",
					"Numéro de commande"
				],
				[
					"valeur",
					"Integer, Text",
					"<-",
					"Valeur du sous-élément sélectionné"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Statut de la commande"
				]
			],
			"Summary": "La commande **QR Get command status** retourne 0 si la commande désignée par le paramètre *numCommande* est inactivée et 1 si elle est activée."
		},
		"QR GET DESTINATION": {
			"Syntax": "**QR GET DESTINATION** ( *zone* ; *type* {; *spécificités*} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"type",
					"Integer",
					"<-",
					"Type d'état"
				],
				[
					"spécificités",
					"Text, Variable",
					"<-",
					"Spécificités de la destination"
				]
			],
			"Summary": "La commande **QR GET DESTINATION** retourne le *type* de destination de l'état rapide contenu dans la *zone*."
		},
		"QR Get document property": {
			"Syntax": "**QR Get document property** ( *zone* ; *propriété* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"propriété",
					"Integer",
					"->",
					"1=Dialogue d'impression, 2=Unité du document"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Valeur de la propriété"
				]
			],
			"Summary": "La commande **QR Get document property** vous permet de connaître la valeur courante de la *propriété* d'affichage de la boîte de dialogue d'impression ou de l'unité du document présent dans la *zone*."
		},
		"QR Get drop column": {
			"Syntax": "**QR Get drop column** ( *zone* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Emplacement du \"déposer\""
				]
			],
			"Summary": "La commande **QR Get drop column** retourne une valeur indiquant l'emplacement auquel un “déposer” a été effectué dans *zone*"
		},
		"QR GET HEADER AND FOOTER": {
			"Syntax": "**QR GET HEADER AND FOOTER** ( *zone* ; *sélecteur* ; *titreGauche* ; *titreCentre* ; *titreDroit* ; *hauteur* {; *image* {; *alignementImage*}} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"1 = En-tête, 2 = Pied de page"
				],
				[
					"titreGauche",
					"Text",
					"<-",
					"Texte affiché sur le côté gauche"
				],
				[
					"titreCentre",
					"Text",
					"<-",
					"Texte affiché au centre"
				],
				[
					"titreDroit",
					"Text",
					"<-",
					"Texte affiché sur le côté droit"
				],
				[
					"hauteur",
					"Integer",
					"<-",
					"Hauteur de l'en-tête ou du pied de page"
				],
				[
					"image",
					"Picture",
					"<-",
					"Image à afficher"
				],
				[
					"alignementImage",
					"Integer",
					"<-",
					"Alignement de l'image"
				]
			],
			"Summary": "La commande **QR GET HEADER AND FOOTER** vous permet de récupérer le contenu et la taille de l'en-tête et du pied de page de la *zone*."
		},
		"QR Get HTML template": {
			"Syntax": "**QR Get HTML template** ( *zone* ) : Text",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Code HTML utilisé comme modèle"
				]
			],
			"Summary": "La commande **QR Get HTML template** retourne le modèle HTML utilisé pour la zone d'état rapide référencée par *zone*."
		},
		"QR GET INFO COLUMN": {
			"Syntax": "**QR GET INFO COLUMN** ( *zone* ; *numColonne* ; *titre* ; *objet* ; *cachée* ; *taille* ; *valeursRépétées* ; *format* {; *varRésultat*} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"titre",
					"Text",
					"<-",
					"Titre de la colonne"
				],
				[
					"objet",
					"Text",
					"<-",
					"Nom du champ ou contenu de la formule affecté(e) à la colonne"
				],
				[
					"cachée",
					"Integer",
					"<-",
					"0 = visible, 1 = invisible"
				],
				[
					"taille",
					"Integer",
					"<-",
					"Largeur de la colonne"
				],
				[
					"valeursRépétées",
					"Integer",
					"<-",
					"0 = non répétées, 1 = répétées"
				],
				[
					"format",
					"Text",
					"<-",
					"Format d'affichage des données"
				],
				[
					"varRésultat",
					"Text",
					"<-",
					"Nom de la variable de formule"
				]
			],
			"Summary": "### Etats en liste \n\nLa commande **QR GET INFO COLUMN** vous permet de récupérer les paramètres d'une colonne existante de l'état présent dans la *zone*."
		},
		"QR Get info row": {
			"Syntax": "**QR Get info row** ( *zone* ; *ligne* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Ligne"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"0 = Visible, 1 = Cachée"
				]
			],
			"Summary": "La commande **QR Get info row** indique si la ligne désignée par le paramètre *ligne* est affichée ou masquée dans la *zone*."
		},
		"QR Get report kind": {
			"Syntax": "**QR Get report kind** ( *zone* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type d'état"
				]
			],
			"Summary": "La commande **QR Get report kind** retourne le *type* d'état présent dans la *zone*."
		},
		"QR Get report table": {
			"Syntax": "**QR Get report table** ( *zone* ) : Integer",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de table"
				]
			],
			"Summary": "La commande **QR Get report table** retourne le numéro de la table courante de l'état désigné par le paramètre *zone*."
		},
		"QR GET SELECTION": {
			"Syntax": "**QR GET SELECTION** ( *zone* ; *gauche* ; *haut* {; *droite* {; *bas*}} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"gauche",
					"Integer",
					"<-",
					"Limite gauche"
				],
				[
					"haut",
					"Integer",
					"<-",
					"Limite supérieure"
				],
				[
					"droite",
					"Integer",
					"<-",
					"Limite droite"
				],
				[
					"bas",
					"Integer",
					"<-",
					"Limite inférieure"
				]
			],
			"Summary": "La commande **QR GET SELECTION** retourne les coordonnées de la sélection courante de la *zone*."
		},
		"QR GET SORTS": {
			"Syntax": "**QR GET SORTS** ( *zone* ; *tabColonnes* ; *tabTris* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"tabColonnes",
					"Real array",
					"<-",
					"Colonnes triées"
				],
				[
					"tabTris",
					"Real array",
					"<-",
					"Ordres de tris"
				]
			],
			"Summary": "La commande **QR GET SORTS** remplit deux tableaux réels"
		},
		"QR Get text property": {
			"Syntax": "**QR Get text property** ( *zone* ; *numColonne* ; *numLigne* ; *propriété* ) : any",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"numLigne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"propriété",
					"Integer",
					"->",
					"Numéro de propriété"
				],
				[
					"Résultat",
					"Text, Integer",
					"<-",
					"Valeur de la propriété"
				]
			],
			"Summary": "La commande **QR Get text property** retourne la valeur courante de la *propriété* de texte dans la cellule de *zone* désignée par *numColonne* et *numLigne*."
		},
		"QR GET TOTALS DATA": {
			"Syntax": "**QR GET TOTALS DATA** ( *zone* ; *numColonne* ; *numRupture* ; *opérateur* ; *texte* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"numRupture",
					"Integer",
					"->",
					"Numéro de rupture"
				],
				[
					"opérateur",
					"Integer",
					"<-",
					"Opérateur de la cellule"
				],
				[
					"texte",
					"Text",
					"<-",
					"Contenu de la cellule"
				]
			],
			"Summary": "### Etat en liste \n\nLa commande **QR GET TOTALS DATA** permet de récupérer le contenu d'une ligne de rupture spécifique (sous-total ou total général)."
		},
		"QR GET TOTALS SPACING": {
			"Syntax": "**QR GET TOTALS SPACING** ( *zone* ; *sousTotal* ; *valeur* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"sousTotal",
					"Integer",
					"->",
					"Numéro de sous-total"
				],
				[
					"valeur",
					"Integer",
					"<-",
					"0=pas d'espace, 32000=insère une saut de page, >0=espace ajouté sous le niveau de rupture, <0=augmentation proportionnelle"
				]
			],
			"Summary": "La commande **QR GET TOTALS SPACING** permet de récupérer la valeur de l'espacement ajouté au-dessous d'une ligne de sous-total."
		},
		"QR INSERT COLUMN": {
			"Syntax": "**QR INSERT COLUMN** ( *zone* ; *numColonne* ; *objet* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"objet",
					"Field, Variable, Pointer",
					"->",
					"Objet à insérer dans la colonne"
				]
			],
			"Summary": "La commande **QR INSERT COLUMN** insère ou crée dans *zone* une colonne à un emplacement spécifique."
		},
		"QR MOVE COLUMN": {
			"Syntax": "**QR MOVE COLUMN** ( *zone* ; *numColonne* ; *nouvPosition* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de la colonne"
				],
				[
					"nouvPosition",
					"Integer",
					"->",
					"Nouvelle position de la colonne"
				]
			],
			"Summary": "La commande **QR MOVE COLUMN** déplace la colonne *numColonne* de sa position courante à la position *nouvPosition*."
		},
		"QR NEW AREA": {
			"Syntax": "**QR NEW AREA** ( *ptr* )",
			"Params": [
				[
					"ptr",
					"Pointer",
					"->",
					"Pointeur vers une variable entier long"
				]
			],
			"Summary": "La commande **QR NEW AREA** crée une nouvelle zone d'état rapide et stocke son numéro de référence dans la variable de type Entier long référencée par le pointeur *ptr*."
		},
		"QR New offscreen area": {
			"Syntax": "**QR New offscreen area**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Référence de la zone créée"
				]
			],
			"Summary": "La commande **QR New offscreen area** crée une zone d'Etat rapide hors écran et retourne son numéro de référence."
		},
		"QR ON COMMAND": {
			"Syntax": "**QR ON COMMAND** ( *zone* ; *nomMéthode* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de la méthode à appeler"
				]
			],
			"Summary": "La commande **QR ON COMMAND** exécute la méthode projet 4D dont le nom est passé dans le paramètre *nomMéthode* lorsqu'une commande de l'éditeur d'états rapides est appelée via la sélection d'un menu ou le clic sur un bouton."
		},
		"QR REPORT TO BLOB": {
			"Syntax": "**QR REPORT TO BLOB** ( *zone* ; *blob* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"blob",
					"Blob",
					"<-",
					"BLOB devant recevoir l'état rapide"
				]
			],
			"Summary": "La commande **QR REPORT TO BLOB** place dans le BLOB *blob* (variable ou champ) l’état dont la référence a été passée dans le paramètre *zone*."
		},
		"QR REPORT": {
			"Syntax": "**QR REPORT** ( {*laTable* ;} *nomFichier* {; *nomMéthode*}{; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à utiliser ou Table par défaut si ce paramètre est omis"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Document d'état rapide à charger"
				],
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de la méthode à appeler"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Suppression des boîtes de dialogue d'impression"
				]
			],
			"Summary": "La commande **QR REPORT** imprime un état pour *laTable*, à l'aide de l'Editeur d'états rapides de 4D."
		},
		"QR RUN": {
			"Syntax": "**QR RUN** ( *zone* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone à exécuter"
				]
			],
			"Summary": "La commande **QR RUN** provoque l'exécution de l'état rapide désigné par le paramètre *zone*."
		},
		"QR SET AREA PROPERTY": {
			"Syntax": "**QR SET AREA PROPERTY** ( *zone* ; *propriété* ; *valeur* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"propriété",
					"Integer",
					"->",
					"Elément d'interface"
				],
				[
					"valeur",
					"Integer",
					"->",
					"1 = affiché, 0 = caché"
				]
			],
			"Summary": "La commande **QR SET AREA PROPERTY** vous permet d'afficher ou de masquer l'élément d'interface dont la référence est passée dans le paramètre *propriété*."
		},
		"QR SET BORDERS": {
			"Syntax": "**QR SET BORDERS** ( *zone* ; *colonne* ; *ligne* ; *encadrement* ; *ligne* {; *couleur*} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"colonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"encadrement",
					"Integer",
					"->",
					"Valeur d'encadrements composée"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Epaisseur de ligne"
				],
				[
					"couleur",
					"Integer",
					"->",
					"Couleur de ligne"
				]
			],
			"Summary": "La commande **QR SET BORDERS** permet de définir le style d'encadrement d'une cellule spécifique."
		},
		"QR SET DESTINATION": {
			"Syntax": "**QR SET DESTINATION** ( *zone* ; *type* {; *spécificités*} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"type",
					"Integer",
					"->",
					"Type d'état"
				],
				[
					"spécificités",
					"Text, Variable",
					"->",
					"Spécificités du type de destination"
				]
			],
			"Summary": "La commande **QR SET DESTINATION** permet de définir le *type* de destination de sortie de l'état rapide contenu dans la *zone*."
		},
		"QR SET DOCUMENT PROPERTY": {
			"Syntax": "**QR SET DOCUMENT PROPERTY** ( *zone* ; *propriété* ; *valeur* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"propriété",
					"Integer",
					"->",
					"1 = Dialogue d'impression, 2 = Unité du document"
				],
				[
					"valeur",
					"Integer",
					"->",
					"Valeur de la propriété"
				]
			],
			"Summary": "La commande **QR SET DOCUMENT PROPERTY** permet d'afficher la boîte de dialogue d'impression ou de définir l'unité du document présent dans la *zone*."
		},
		"QR SET HEADER AND FOOTER": {
			"Syntax": "**QR SET HEADER AND FOOTER** ( *zone* ; *sélecteur* ; *titreGauche* ; *titreCentre* ; *titreDroit* ; *hauteur* {; *image* {; *alignementImage*}} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"1 = En-tête, 2 = Pied de page"
				],
				[
					"titreGauche",
					"Text",
					"->",
					"Texte affiché sur le côté gauche"
				],
				[
					"titreCentre",
					"Text",
					"->",
					"Texte affiché au centre"
				],
				[
					"titreDroit",
					"Text",
					"->",
					"Texte affiché sur le côté droit"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur de l'en-tête ou du pied de page"
				],
				[
					"image",
					"Picture",
					"->",
					"Image à afficher"
				],
				[
					"alignementImage",
					"Integer",
					"->",
					"Alignement de l'image"
				]
			],
			"Summary": "La commande **QR SET HEADER AND FOOTER** vous permet de définir le contenu et la taille de l'en-tête et du pied de page de la *zone*."
		},
		"QR SET HTML TEMPLATE": {
			"Syntax": "**QR SET HTML TEMPLATE** ( *zone* ; *modèle* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"modèle",
					"Text",
					"->",
					"Code du modèle HTML"
				]
			],
			"Summary": "La commande **QR SET HTML TEMPLATE** permet de définir le *modèle* HTML à utiliser pour la zone d'état rapide référencée par *zone*."
		},
		"QR SET INFO COLUMN": {
			"Syntax": "**QR SET INFO COLUMN** ( *zone* ; *numColonne* ; *titre* ; *objet* ; *cachée* ; *taille* ; *valeursRépétées* ; *formatAffich* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"titre",
					"Text",
					"->",
					"Titre de la colonne"
				],
				[
					"objet",
					"Field, Variable",
					"->",
					"Objet affecté à la colonne"
				],
				[
					"cachée",
					"Integer",
					"->",
					"0 = visible, 1 = invisible"
				],
				[
					"taille",
					"Integer",
					"->",
					"Largeur de la colonne"
				],
				[
					"valeursRépétées",
					"Integer",
					"->",
					"0 = Non répétées, 1 = Répétées"
				],
				[
					"formatAffich",
					"Text",
					"->",
					"Format d'affichage"
				]
			],
			"Summary": "La commande **QR SET INFO COLUMN** vous permet de définir les paramètres d'une colonne existante de l'état présent dans la *zone*."
		},
		"QR SET INFO ROW": {
			"Syntax": "**QR SET INFO ROW** ( *zone* ; *ligne* ; *cachée* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"ligne",
					"Integer",
					"->",
					"Ligne"
				],
				[
					"cachée",
					"Integer",
					"->",
					"0 = Visible, 1 = Cachée"
				]
			],
			"Summary": "La commande **QR SET INFO ROW** permet d'afficher ou de masquer la ligne dont la référence est passée dans le paramètre *ligne*."
		},
		"QR SET REPORT KIND": {
			"Syntax": "**QR SET REPORT KIND** ( *zone* ; *type* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"type",
					"Integer",
					"->",
					"Type d'état"
				]
			],
			"Summary": "La commande **QR SET REPORT KIND** permet de définir le *type* de l'état rapide présent dans la *zone*."
		},
		"QR SET REPORT TABLE": {
			"Syntax": "**QR SET REPORT TABLE** ( *zone* ; *numTable* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numTable",
					"Integer",
					"->",
					"Numéro de table"
				]
			],
			"Summary": "La commande **QR SET REPORT TABLE** désigne via le paramètre *numTable* le numéro de la table courante de l'état rapide dont la référence est passée dans le paramètre *zone*."
		},
		"QR SET SELECTION": {
			"Syntax": "**QR SET SELECTION** ( *zone* ; *gauche* ; *haut* {; *droite* {; *bas*}} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"gauche",
					"Integer",
					"->",
					"Limite gauche"
				],
				[
					"haut",
					"Integer",
					"->",
					"Limite supérieure"
				],
				[
					"droite",
					"Integer",
					"->",
					"Limite droite"
				],
				[
					"bas",
					"Integer",
					"->",
					"Limite inférieure"
				]
			],
			"Summary": "La commande **QR SET SELECTION** permet de sélectionner une cellule, une ligne, une colonne ou encore la totalité de la *zone*, comme vous le feriez à l'aide de la souris."
		},
		"QR SET SORTS": {
			"Syntax": "**QR SET SORTS** ( *zone* ; *tabColonnes* {; *tabTris*} )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"tabColonnes",
					"Real array",
					"->",
					"Colonnes"
				],
				[
					"tabTris",
					"Real array",
					"->",
					"Ordres de tris"
				]
			],
			"Summary": "La commande **QR SET SORTS** vous permet de définir l'ordre de tri de chaque colonne de l'état rapide dont la référence est passée dans *zone*."
		},
		"QR SET TEXT PROPERTY": {
			"Syntax": "**QR SET TEXT PROPERTY** ( *zone* ; *numColonne* ; *numLigne* ; *propriété* ; *valeur* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"numLigne",
					"Integer",
					"->",
					"Numéro de ligne"
				],
				[
					"propriété",
					"Integer",
					"->",
					"Numéro de propriété"
				],
				[
					"valeur",
					"Integer, Text",
					"->",
					"Valeur de la propriété définie"
				]
			],
			"Summary": "La commande **QR SET TEXT PROPERTY** permet de définir les propriétés de texte de la cellule désignée par les paramètres *numColonne* et *numLigne*."
		},
		"QR SET TOTALS DATA": {
			"Syntax": "**QR SET TOTALS DATA** ( *zone* ; *numColonne* ; *numRupture* ; opérateur | valeur )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"numColonne",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"numRupture",
					"Integer",
					"->",
					"Numéro de rupture"
				],
				[
					"opérateur &#124; valeur",
					"Entier long, Chaîne",
					"->",
					"Opérateur pour la cellule ou Contenu de la cellule"
				]
			],
			"Summary": "**Note :** Cette commande ne crée pas de sous-total."
		},
		"QR SET TOTALS SPACING": {
			"Syntax": "**QR SET TOTALS SPACING** ( *zone* ; *sousTotal* ; *valeur* )",
			"Params": [
				[
					"zone",
					"Integer",
					"->",
					"Référence de la zone"
				],
				[
					"sousTotal",
					"Integer",
					"->",
					"Numéro de sous-total"
				],
				[
					"valeur",
					"Integer",
					"->",
					"0=pas d'espace, 32000=insère un saut de page, >0=espace ajouté sous le niveau de rupture, <0=augmentation proportionnelle"
				]
			],
			"Summary": "La commande **QR SET TOTALS SPACING** permet de définir l'espacement ajouté au-dessous d'une ligne de sous-total."
		},
		"QUERY BY ATTRIBUTE": {
			"Syntax": "**QUERY BY ATTRIBUTE** ( {*laTable*}{;}{*opConj* ;} *champObjet* ; *cheminAttribut* ; *opRech* ; *valeur* {; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle la sélection est créée ou Table par défaut si ce paramètre est omis"
				],
				[
					"opConj",
					"*",
					"->",
					"Opérateur à utiliser pour combiner plusieurs requêtes (le cas échéant)"
				],
				[
					"champObjet",
					"Field",
					"->",
					"Champ objet dont les attributs sont à utiliser pour la recherche"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Nom ou chemin d'attribut"
				],
				[
					"opRech",
					"Text, *",
					"->",
					"Opérateur de recherche (comparateur)"
				],
				[
					"valeur",
					"Text, Number, Date, Time",
					"->",
					"Valeur à comparer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d'exécution de la recherche"
				]
			],
			"Summary": "La commande **QUERY BY ATTRIBUTE** recherche les enregistrements répondant au(x) critère(s) de recherche spécifié(s) à l'aide des paramètres *champObjet*, *cheminAttribut*, *opRech* et *valeur* et retourne une sélection d'enregistrements de *laTable*."
		},
		"QUERY BY EXAMPLE": {
			"Syntax": "**QUERY BY EXAMPLE** ( {*laTable*}{;}{*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle une sélection d'enregistrements doit être retournée ou Table par défaut si ce paramètre est omis"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Masquer les barres de défilement"
				]
			],
			"Summary": "La commande **QUERY BY EXAMPLE** effectue la même action que la commande de menu **Recherche par formulaire**."
		},
		"QUERY BY FORMULA": {
			"Syntax": "**QUERY BY FORMULA** ( *laTable* {; *formule*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle effectuer la recherche"
				],
				[
					"formule",
					"Boolean",
					"->",
					"Formule de recherche"
				]
			],
			"Summary": "**QUERY BY FORMULA** effectue une recherche d'enregistrements dans *laTable*."
		},
		"QUERY BY SQL": {
			"Syntax": "**QUERY BY SQL** ( {*laTable* ;} *formuleSQL* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle retourner une sélection d’enregistrements ou Table par défaut si ce paramètre est omis"
				],
				[
					"formuleSQL",
					"Text",
					"->",
					"Formule de recherche SQL valide représentant la clause WHERE de la requête SELECT"
				]
			],
			"Summary": "La commande **QUERY BY SQL** permet de tirer directement parti du moteur SQL intégré de 4D."
		},
		"QUERY SELECTION BY ATTRIBUTE": {
			"Syntax": "**QUERY SELECTION BY ATTRIBUTE** ( {*laTable*}{;}{*opConj* ;} *champObjet* ; *cheminAttribut* ; *opRecherche* ; *valeur* {; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle la sélection est créée ou Table par défaut si ce paramètre est omis"
				],
				[
					"opConj",
					"*",
					"->",
					"Opérateur à utiliser pour combiner plusieurs requêtes (le cas échéant)"
				],
				[
					"champObjet",
					"Field",
					"->",
					"Champ objet dont les attributs sont à utiliser pour la recherche"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Nom ou chemin d'attribut"
				],
				[
					"opRecherche",
					"*, Text",
					"->",
					"Opérateur de recherche (comparateur)"
				],
				[
					"valeur",
					"Text, Number, Date, Time",
					"->",
					"Valeur à comparer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d'exécution de la recherche"
				]
			],
			"Summary": "**QUERY SELECTION BY ATTRIBUTE** fonctionne de la même façon et exécute les mêmes actions que la commande QUERY BY ATTRIBUTE."
		},
		"QUERY SELECTION BY FORMULA": {
			"Syntax": "**QUERY SELECTION BY FORMULA** ( *laTable* {; *formule*} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle effectuer la recherche parmi la sélection courante"
				],
				[
					"formule",
					"Boolean",
					"->",
					"Formule de recherche"
				]
			],
			"Summary": "La commande **QUERY SELECTION BY FORMULA** vous permet de rechercher des enregistrements dans *laTable*."
		},
		"QUERY SELECTION WITH ARRAY": {
			"Syntax": "**QUERY SELECTION WITH ARRAY** ( *champCible* ; *tableau* )",
			"Params": [
				[
					"champCible",
					"Field",
					"->",
					"Champ duquel comparer les valeurs"
				],
				[
					"tableau",
					"Array",
					"->",
					"Tableau des valeurs recherchées"
				]
			],
			"Summary": "La commande **QUERY SELECTION WITH ARRAY** recherche dans la sélection courante de la table du champ passé en premier paramètre les enregistrements pour lesquels la valeur de *champCible* est égale à au moins une des valeurs des éléments du *tableau*."
		},
		"QUERY SELECTION": {
			"Syntax": "**QUERY SELECTION** ( {*laTable* }{;}{ *critère* {; *}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle effectuer la recherche ou ou Table par défaut si ce paramètre est omis"
				],
				[
					"critère",
					"Expression",
					"->",
					"Lignes de recherche"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d'exécution de la recherche"
				]
			],
			"Summary": "**QUERY SELECTION** recherche des enregistrements dans *laTable*."
		},
		"QUERY WITH ARRAY": {
			"Syntax": "**QUERY WITH ARRAY** ( *champCible* ; *tableau* )",
			"Params": [
				[
					"champCible",
					"Field",
					"->",
					"Champ duquel comparer les valeurs"
				],
				[
					"tableau",
					"Array",
					"->",
					"Tableau des valeurs recherchées"
				]
			],
			"Summary": "La commande **QUERY WITH ARRAY** recherche dans la table du champ passé en premier paramètre tous les enregistrements pour lesquels la valeur de *champCible* est égale à au moins une des valeurs des éléments du tableau *tableau*."
		},
		"QUERY": {
			"Syntax": "**QUERY** ( {*laTable* }{;}{ *critère* {; *}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle la sélection est créée ou Table par défaut si ce paramètre est omis"
				],
				[
					"critère",
					"Expression",
					"->",
					"Critère de recherche"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d'exécution de la recherche"
				]
			],
			"Summary": "La commande **QUERY** recherche les enregistrements répondant au(x) critère(s) de recherche spécifié(s) dans *critère* et retourne une sélection d'enregistrements de *laTable*."
		},
		"QUIT 4D": {
			"Syntax": "**QUIT 4D** {( *délai* )}",
			"Params": [
				[
					"délai",
					"Integer",
					"->",
					"Délai (secondes) avant que le serveur ne quitte"
				]
			],
			"Summary": "La commande **QUIT 4D**  vous permet de quitter l'application 4D courante et de retourner sur le Bureau du système d'exploitation."
		},
		"Random": {
			"Syntax": "**Random**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre aléatoire"
				]
			],
			"Summary": "**Random** retourne une valeur entière aléatoire comprise entre 0 et 32 767 (inclus)."
		},
		"Read only state": {
			"Syntax": "**Read only state** {( *laTable* )} : Boolean",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle il faut tester l'état ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Accès à la table est lecture seulement (Vrai) ou Accès à la table est lecture-écriture (Faux)"
				]
			],
			"Summary": "La fonction **Read only state** est utilisé pour tester si *laTable* est en mode lecture seulement dans le process où la fonction est appelée."
		},
		"READ ONLY": {
			"Syntax": "**READ ONLY** {( laTable | * )}",
			"Params": [
				[
					"laTable &#124; *",
					"Table, Opérateur",
					"->",
					"Table à définir en mode lecture seulement ou * pour toutes les tables ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**READ ONLY** place *laTable* en mode lecture seulement pour le process dans lequel la commande a été appelée."
		},
		"READ PICTURE FILE": {
			"Syntax": "**READ PICTURE FILE** ( *nomFichier* ; *image* {; *} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom ou chemin d’accès complet du fichier à lire, ou chaîne vide"
				],
				[
					"image",
					"Picture",
					"<-",
					"Champ ou variable recevant l’image"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = accepter tout type de fichier"
				]
			],
			"Summary": "La commande **READ PICTURE FILE** vous permet d’ouvrir l’image stockée dans le fichier disque désigné par *nomFichier* et de la placer dans le champ ou la variable 4D *image*."
		},
		"READ WRITE": {
			"Syntax": "**READ WRITE** {( laTable | * )}",
			"Params": [
				[
					"laTable &#124; *",
					"Table, Opérateur",
					"->",
					"Table à définir en mode lecture/écriture ou * pour toutes les tables ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**READ WRITE** place *laTable* en mode lecture/écriture pour le process dans lequel la commande a été appelée."
		},
		"REAL TO BLOB": {
			"Syntax": "**REAL TO BLOB** ( *réel* ; *blob* ; *formatRéel* {; offset | *} )",
			"Params": [
				[
					"réel",
					"Real",
					"->",
					"Valeur de type Réel à écrire dans le BLOB"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB devant recevoir la valeur Réel"
				],
				[
					"formatRéel",
					"Integer",
					"->",
					"0=Format réel natif, 1=Format réel étendu, 2=Format réel double Macintosh, 3=Format réel double Windows"
				],
				[
					"offset &#124; *",
					"Variable, Opérateur",
					"<->",
					"Offset (en octets) dans le BLOB ou  * pour ajouter la valeur à la fin du BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après l'écriture si * omis"
				]
			],
			"Summary": "La commande **REAL TO BLOB** écrit la valeur de type Réel *réel* dans le BLOB *blob*."
		},
		"RECEIVE BUFFER": {
			"Syntax": "**RECEIVE BUFFER** ( *varRéception* )",
			"Params": [
				[
					"varRéception",
					"Text",
					"<-",
					"Variable devant recevoir les données"
				]
			],
			"Summary": "La commande **RECEIVE BUFFER** lit les données du port série préalablement ouvert par la commande SET CHANNEL."
		},
		"RECEIVE PACKET": {
			"Syntax": "**RECEIVE PACKET** ( {*docRef* ;} *réceptVar* ; stopCar | nbOctets )",
			"Params": [
				[
					"docRef",
					"Time",
					"->",
					"Numéro de référence de document ou canal courant (port série ou document)"
				],
				[
					"réceptVar",
					"Text, Blob",
					"<-",
					"Variable devant recevoir les données"
				],
				[
					"stopCar &#124; nbOctets",
					"Chaîne, Entier long",
					"->",
					"Caractère(s) au(x)quel(s) stopper la réception des données ou Nombre d'octets à recevoir"
				]
			],
			"Summary": "La commande **RECEIVE PACKET** lit des caractères depuis un port série ou un document."
		},
		"RECEIVE RECORD": {
			"Syntax": "**RECEIVE RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dans laquelle recevoir l'enregistrement, ou Table par défaut si omis"
				]
			],
			"Summary": "**RECEIVE RECORD** ajoute dans *laTable* un enregistrement reçu par l'intermédiaire du port série ou d'un document ouvert par la commande SET CHANNEL."
		},
		"RECEIVE VARIABLE": {
			"Syntax": "**RECEIVE VARIABLE** ( *variable* )",
			"Params": [
				[
					"variable",
					"Variable",
					"<-",
					"Variable dans laquelle recevoir une variable"
				]
			],
			"Summary": "La commande **RECEIVE VARIABLE** reçoit *variable*, une variable envoyée par la commande SEND VARIABLE, depuis un document ou un port série préalablement ouvert par la commande SET CHANNEL."
		},
		"Record number": {
			"Syntax": "**Record number** {( *laTable* )} : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle vous souhaitez obtenir le numéro de l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro d'enregistrement courant"
				]
			],
			"Summary": "**Record number** retourne le numéro de l'enregistrement courant de *laTable*."
		},
		"Records in selection": {
			"Syntax": "**Records in selection** {( *laTable* )} : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous souhaitez connaître le nombre d'enregistrements de la sélection courante ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'enregistrements dans la sélection courante de table"
				]
			],
			"Summary": "**Records in selection** retourne le nombre d'enregistrements constituant la sélection courante de *laTable* (par opposition, Records in table retourne le nombre total d'enregistrements d'une table)."
		},
		"Records in set": {
			"Syntax": "**Records in set** ( *ensemble* ) : Integer",
			"Params": [
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble à tester"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'enregistrements dans l'ensemble"
				]
			],
			"Summary": "**Records in set** retourne le nombre d'enregistrements présents dans *ensemble*."
		},
		"Records in table": {
			"Syntax": "**Records in table** {( *laTable* )} : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle retourner le nombre total d'enregistrements ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre total d'enregistrements dans table"
				]
			],
			"Summary": "**Records in table** retourne le nombre total d'enregistrements que contient *laTable*."
		},
		"REDRAW WINDOW": {
			"Syntax": "**REDRAW WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process courant si omis"
				]
			],
			"Summary": "La commande **REDRAW WINDOW** provoque une mise à jour du contenu de la fenêtre dont le numéro de référence est passé dans *fenêtre*."
		},
		"REDRAW": {
			"Syntax": "**REDRAW** ( *objet* )",
			"Params": [
				[
					"objet",
					"any",
					"->",
					"Table de laquelle redessiner le sous-formulaire ou Champ duquel redessiner la zone ou Variable de laquelle redessiner la zone ou List box à mettre à jour"
				]
			],
			"Summary": "Lorsque vous modifiez par programmation le contenu d'un champ affiché dans un sous-formulaire, vous devez exécuter la commande **REDRAW** pour vous assurer que le formulaire est correctement mis à jour."
		},
		"REDUCE RESTORE WINDOW": {
			"Syntax": "**REDUCE RESTORE WINDOW** ( *window* )",
			"Params": [
				[
					"window",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre"
				]
			],
			"Summary": "La commande **REDUCE RESTORE WINDOW** réduit/agrandit la fenêtre dont le numéro de référence a été transmis dans la fenêtre vers/depuis la barre des tâches sous Windows ou le dock sous macOS."
		},
		"REDUCE SELECTION": {
			"Syntax": "**REDUCE SELECTION** ( {*laTable* ;} *nombre* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle réduire la sélection ou Table par défaut si ce paramètre est omis"
				],
				[
					"nombre",
					"Integer",
					"->",
					"Nombre d'enregistrements à conserver"
				]
			],
			"Summary": "La commande **REDUCE SELECTION** crée une nouvelle sélection d'enregistrements pour *laTable*."
		},
		"Refresh license": {
			"Syntax": "**Refresh license** : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Objet statut"
				]
			],
			"Summary": "La commande **Refresh license** met à jour la licence 4D Server courante."
		},
		"REGENERATE MISSING TABLE": {
			"Syntax": "**REGENERATE MISSING TABLE** ( *nomTable* )",
			"Params": [
				[
					"nomTable",
					"Text",
					"->",
					"Nom de table manquante à regénérer"
				]
			],
			"Summary": "La commande **REGENERATE MISSING TABLE** reconstruit la table manquante dont vous avez passé le nom dans le paramètre *nomTable*."
		},
		"REGISTER CLIENT": {
			"Syntax": "**REGISTER CLIENT** ( *nomClient* {; *période*}{; *} )",
			"Params": [
				[
					"nomClient",
					"Text",
					"->",
					"Nom de la session cliente 4D"
				],
				[
					"période",
					"Integer",
					"->",
					"*** Ignoré depuis la version 11.3 ***"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Process local"
				]
			],
			"Summary": "La commande **REGISTER CLIENT** “inscrit” un poste client 4D sous le nom *nomClient* auprès de 4D Server, afin de permettre que d’autres clients ou éventuellement 4D Server (par l’intermédiaire de procédures stockées) puissent y exécuter des méthodes à l’aide de la commande EXECUTE ON CLIENT."
		},
		"Register data key": {
			"Syntax": "**Register data key** ( phraseSecrèteCour | cléDonnéesCour ) : Boolean",
			"Params": [
				[
					"phraseSecrèteCour &#124; cléDonnéesCour",
					"Texte, Objet",
					"->",
					"Phrase secrète courante (texte) ou clé de chiffrement des données courante (objet)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si la clé de chiffrement des données a été ajoutée avec succès au trousseau 4D. Faux si elle était déjà dans le trousseau 4D."
				]
			],
			"Summary": "La commande **Register data key** ajoute au trousseau 4D la clé de chiffrement de données qui a été passée dans le paramètre."
		},
		"REJECT NEW REMOTE CONNECTIONS": {
			"Syntax": "**REJECT NEW REMOTE CONNECTIONS** ( *statutRejet* )",
			"Params": [
				[
					"statutRejet",
					"Boolean",
					"->",
					"Vrai si rejet des nouvelles connexions, sinon Faux."
				]
			],
			"Summary": "La commande **REJECT NEW REMOTE CONNECTIONS** permet d'indiquer si le serveur d'application accepte ou non de nouvelles connexions depuis des 4D distants."
		},
		"REJECT": {
			"Syntax": "**REJECT** {( *leChamp* )}",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ dont la saisie doit être refusée"
				]
			],
			"Summary": "**REJECT** accepte deux syntaxes."
		},
		"RELATE MANY SELECTION": {
			"Syntax": "**RELATE MANY SELECTION** ( *leChamp* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ de la table N (d'où part le lien)"
				]
			],
			"Summary": "La commande **RELATE MANY SELECTION** crée une sélection d'enregistrements dans la table N basée sur la sélection courante de la table 1, et charge le premier enregistrement de la table N comme enregistrement courant."
		},
		"RELATE MANY": {
			"Syntax": "**RELATE MANY** ( table1 | champ1 )",
			"Params": [
				[
					"table1 &#124; champ1",
					"Table, Champ",
					"->",
					"Table pour laquelle établir tous les liens de 1 vers N ou champ 1"
				]
			],
			"Summary": "**RELATE MANY** a deux syntaxes."
		},
		"RELATE ONE SELECTION": {
			"Syntax": "**RELATE ONE SELECTION** ( *tableN* ; *table1* )",
			"Params": [
				[
					"tableN",
					"Table",
					"->",
					"Nom de la table N (d'où part le lien)"
				],
				[
					"table1",
					"Table",
					"->",
					"Nom de la table 1 (où arrive le lien)"
				]
			],
			"Summary": "La commande **RELATE ONE SELECTION** crée une nouvelle sélection d'enregistrements dans *table1* à partir de la sélection d'enregistrements de la *tableN* qui lui est liée et charge le premier enregistrement de la nouvelle sélection en tant qu'enregistrement courant."
		},
		"RELATE ONE": {
			"Syntax": "**RELATE ONE** ( tableN | champN {; *discriminant*} )",
			"Params": [
				[
					"tableN &#124; champN",
					"Table, Champ",
					"->",
					"Table pour laquelle définir tous les liens automatiques ou Champ avec lien manuel partant vers la table 1"
				],
				[
					"discriminant",
					"Field",
					"->",
					"Champ discriminant de la table 1"
				]
			],
			"Summary": "**RELATE ONE** accepte deux syntaxes."
		},
		"RELEASE MENU": {
			"Syntax": "**RELEASE MENU** ( *menu* )",
			"Params": [
				[
					"menu",
					"Text",
					"->",
					"Référence de menu"
				]
			],
			"Summary": "La commande **RELEASE MENU** efface de la mémoire le menu dont vous avez passé l’identifiant dans *menu*."
		},
		"RELOAD EXTERNAL DATA": {
			"Syntax": "**RELOAD EXTERNAL DATA** ( *leChamp* )",
			"Params": [
				[
					"leChamp",
					"Text, Blob, Picture, Object",
					"->",
					"Champ pour lequel recharger les données"
				]
			],
			"Summary": "La commande **RELOAD EXTERNAL DATA** vous permet de recharger en mémoire le contenu d’un fichier de stockage externe associé à un champ de type Blob, Image ou Texte."
		},
		"RELOAD PROJECT": {
			"Syntax": "**RELOAD PROJECT**",
			"Params": [],
			"Summary": "La commande **RELOAD PROJECT** recharge les définitions du fichier source (méthodes, formulaires, etc.) à partir du disque, pour exécuter le projet dans l'environnement 4D courant."
		},
		"REMOVE FROM SET": {
			"Syntax": "**REMOVE FROM SET** ( {*laTable* ;} *ensemble* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				],
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble duquel supprimer l'enregistrement courant"
				]
			],
			"Summary": "**REMOVE FROM SET** supprime l'enregistrement courant de *laTable* de l'ensemble *ensemble*."
		},
		"REMOVE PICTURE FROM LIBRARY": {
			"Syntax": "**REMOVE PICTURE FROM LIBRARY** ( *refImage* )<br/>**REMOVE PICTURE FROM LIBRARY** ( *nomImage* )",
			"Params": [
				[
					"refImage &#124; nomImage",
					"Entier long, Chaîne",
					"->",
					"Numéro de référence ou Nom d'une image de la bibliothèque d'images"
				]
			],
			"Summary": "La commande **REMOVE PICTURE FROM LIBRARY** supprime de la bibliothèque d’images l’image dont vous avez passé le numéro de référence dans *refImage* ou le nom dans *nomImage*."
		},
		"Replace string": {
			"Syntax": "**Replace string** ( *source* ; *obsolète* ; *nouveau* {; *combien*}{; *} ) : Text",
			"Params": [
				[
					"source",
					"Text",
					"->",
					"Chaîne de départ"
				],
				[
					"obsolète",
					"Text",
					"->",
					"Caractère(s) à remplacer"
				],
				[
					"nouveau",
					"Text",
					"->",
					"Chaîne de remplacement (si chaîne vide, toutes les occurrences sont effacées)"
				],
				[
					"combien",
					"Integer",
					"->",
					"Nombre de remplacements à effectuer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : évaluation basée sur les codes de caractères"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne résultante"
				]
			],
			"Summary": "**Replace string** retourne une chaîne de caractères résultant du remplacement dans *source* de *obsolète* par *nouveau*."
		},
		"Request": {
			"Syntax": "**Request** ( *message* {; *réponseDéfaut* {; *titreBoutonOK* {; *titreBoutonAnn*}}} )  : Text",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message à afficher dans la boîte de dialogue"
				],
				[
					"réponseDéfaut",
					"Text",
					"->",
					"Valeur par défaut dans la zone de saisie de texte"
				],
				[
					"titreBoutonOK",
					"Text",
					"->",
					"Libellé du bouton OK"
				],
				[
					"titreBoutonAnn",
					"Text",
					"->",
					"Libellé du bouton Annuler"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Valeur saisie par l'utilisateur"
				]
			],
			"Summary": "La fonction **Request** affiche une boîte de dialogue de demande d'informations composée d'un message, d'une zone de saisie de texte, d'un bouton **OK** et d'un bouton **Annuler**."
		},
		"RESIZE FORM WINDOW": {
			"Syntax": "**RESIZE FORM WINDOW** ( *largeur* ; *hauteur* )",
			"Params": [
				[
					"largeur",
					"Integer",
					"->",
					"Pixels à ajouter ou soustraire à la largeur courante de la fenêtre formulaire"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Pixels à ajouter ou soustraire à la hauteur courante de la fenêtre formulaire"
				]
			],
			"Summary": "La commande **RESIZE FORM WINDOW** permet de modifier la taille de la fenêtre du formulaire courant."
		},
		"RESOLVE ALIAS": {
			"Syntax": "**RESOLVE ALIAS** ( *cheminAlias* ; *cheminCible* )",
			"Params": [
				[
					"cheminAlias",
					"Text",
					"->",
					"Nom ou chemin d’accès complet de l’alias/ du raccourci"
				],
				[
					"cheminCible",
					"Text",
					"<-",
					"Nom ou chemin d’accès complet de la cible de l’alias/du raccourci"
				]
			],
			"Summary": "La commande **RESOLVE ALIAS** retourne le chemin d’accès complet du fichier ou dossier cible d’un alias (appelé “raccourci” sous Windows)."
		},
		"RESOLVE POINTER": {
			"Syntax": "**RESOLVE POINTER** ( *pointeur* ; *nomVar* ; *numTable* ; *numChamp* )",
			"Params": [
				[
					"pointeur",
					"Pointer",
					"->",
					"Pointeur duquel récupérer l'objet référencé"
				],
				[
					"nomVar",
					"Text",
					"<-",
					"Nom de la variable référencée ou chaîne vide"
				],
				[
					"numTable",
					"Integer",
					"<-",
					"Numéro de la table ou de l'élément de tableau référencé(e) ou 0 ou -1"
				],
				[
					"numChamp",
					"Integer",
					"<-",
					"Numéro du champ ou de l'élément de tableau 2D référencé ou 0 ou -1"
				]
			],
			"Summary": "**RESOLVE POINTER** récupère l'information de l'objet référencé par *pointeur* et la retourne dans les paramètres *nomVar*, *numTable* et *numChamp*."
		},
		"RESOURCE LIST": {
			"Syntax": "**RESOURCE LIST** ( *resType* ; *resNums* ; *resNoms* {; *resFichier*} )",
			"Params": [
				[
					"resType",
					"Text",
					"->",
					"Type de ressource (4 caractères)"
				],
				[
					"resNums",
					"Integer array",
					"<-",
					"Numéros des ressources de ce type"
				],
				[
					"resNoms",
					"Text array",
					"<-",
					"Noms des ressources de ce type"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources ou tous les fichiers de ressources ouverts si ce paramètre est omis"
				]
			],
			"Summary": "La commande **RESOURCE LIST** remplit les tableaux *resNums* et *resNoms* avec les numéros et les noms des ressources dont vous avez passé le type dans *resType*."
		},
		"RESOURCE TYPE LIST": {
			"Syntax": "**RESOURCE TYPE LIST** ( *resTypes* {; *resFichier*} )",
			"Params": [
				[
					"resTypes",
					"Text array",
					"<-",
					"Liste des types de ressources disponibles"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources ou tous les fichiers de ressources ouverts (si ce paramètre est omis)"
				]
			],
			"Summary": "La commande **RESOURCE TYPE LIST** remplit le tableau *resTypes* avec les types des ressources présentes dans le(s) fichier(s) de resources ouvert(s)."
		},
		"RESTART 4D": {
			"Syntax": "**RESTART 4D** {( *délai* {; *message*} )}",
			"Params": [
				[
					"délai",
					"Integer",
					"->",
					"Délai (secondes) avant que 4D ne redémarre"
				],
				[
					"message",
					"Text",
					"->",
					"Texte à afficher sur les postes clients"
				]
			],
			"Summary": "La commande **RESTART 4D** provoque le redémarrage de l’application 4D courante."
		},
		"RESTORE INFO": {
			"Syntax": "**RESTORE INFO** ( *sélecteur* ; *info1* ; *info2* )",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Type d’information à récupérer"
				],
				[
					"info1",
					"Integer, Date",
					"<-",
					"Valeur 1 du sélecteur"
				],
				[
					"info2",
					"Text, Time",
					"<-",
					"Valeur 2 du sélecteur"
				]
			],
			"Summary": "La commande **RESTORE INFO** permet de récupérer des informations relatives à la dernière restitution automatique de la base."
		},
		"RESTORE": {
			"Syntax": "**RESTORE** {( *cheminArchive* {; *cheminDossierDest*} )}",
			"Params": [
				[
					"cheminArchive",
					"Text",
					"->",
					"Chemin d’accès de l’archive à restituer"
				],
				[
					"cheminDossierDest",
					"Text",
					"->",
					"Chemin d’accès du dossier de destination"
				]
			],
			"Summary": "La commande **RESTORE** permet restituer le ou les fichier(s) inclus dans une archive 4D."
		},
		"RESUME INDEXES": {
			"Syntax": "**RESUME INDEXES** ( *laTable* {; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle réactiver les index"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = indexation asynchrone"
				]
			],
			"Summary": "La commande **RESUME INDEXES** réactive tous les index de *laTable* s’ils ont été préabalement suspendus via la commande PAUSE INDEXES."
		},
		"RESUME PROCESS": {
			"Syntax": "**RESUME PROCESS** ( *process* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "**RESUME PROCESS** réactive un process suspendu ou endormi."
		},
		"RESUME TRANSACTION": {
			"Syntax": "**RESUME TRANSACTION**",
			"Params": [],
			"Summary": "La commande **RESUME TRANSACTION** réactive la transaction qui a été suspendue à l'aide de la commande SUSPEND TRANSACTION au niveau correspondant dans le process courant."
		},
		"Right click": {
			"Syntax": "**Right click**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si un clic droit a été détecté, sinon Faux"
				]
			],
			"Summary": "La commande **Right click** retourne Vrai si un clic effectué avec le bouton droit de la souris a été effectué."
		},
		"Round": {
			"Syntax": "**Round** ( *arrondi* ; *nbDécimales* ) : Real",
			"Params": [
				[
					"arrondi",
					"Real",
					"->",
					"Nombre à arrondir"
				],
				[
					"nbDécimales",
					"Integer",
					"->",
					"Nombre de décimales de l'arrondi"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Valeur de nombre arrondie avec une précision égale à nbDécimales"
				]
			],
			"Summary": "**Round** retourne la valeur arrondie de *nombre* avec une précision égale à *nbDécimales*."
		},
		"SAVE LIST": {
			"Syntax": "**SAVE LIST** ( *liste* ; *nomListe* )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de liste"
				],
				[
					"nomListe",
					"Text",
					"->",
					"Nom de la liste tel qu'il doit apparaître dans l'éditeur d'énumérations en mode Développement"
				]
			],
			"Summary": "La commande **SAVE LIST** sauvegarde la liste dont vous avez passé le numéro de référence dans *liste*, sous le nom que vous avez passé dans *nomListe*."
		},
		"SAVE RECORD": {
			"Syntax": "**SAVE RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de l'enregistrement à stocker ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**SAVE RECORD** sauvegarde l'enregistrement courant de *laTable* pour le process courant."
		},
		"SAVE RELATED ONE": {
			"Syntax": "**SAVE RELATED ONE** ( *leChamp* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ N"
				]
			],
			"Summary": "**SAVE RELATED ONE** sauvegarde l'enregistrement lié à *leChamp*."
		},
		"SAVE SET": {
			"Syntax": "**SAVE SET** ( *ensemble* ; *nomFichier* )",
			"Params": [
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble à stocker"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du fichier dans lequel stocker l'ensemble"
				]
			],
			"Summary": "**SAVE SET** sauvegarde *ensemble* dans le fichier disque *document*."
		},
		"SAVE VARIABLES": {
			"Syntax": "**SAVE VARIABLES** ( *nomFichier* ; *variable* {; *variable2* ; ... ; *variableN*} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du document dans lequel sauvegarder la ou les variable(s)"
				],
				[
					"variable",
					"Variable",
					"->",
					"Variable(s) à sauvegarder"
				]
			],
			"Summary": "La commande **SAVE VARIABLES** sauvegarde une ou plusieurs variable(s) dans un document disque dont le nom est passé dans le paramètre *document*."
		},
		"SAX ADD PROCESSING INSTRUCTION": {
			"Syntax": "**SAX ADD PROCESSING INSTRUCTION** ( *document* ; *instruction* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"instruction",
					"Text",
					"->",
					"Instruction à insérer dans le document"
				]
			],
			"Summary": "La commande **SAX ADD PROCESSING INSTRUCTION** ajoute dans le document XML référencé par *document* une *instruction* de traitement XML."
		},
		"SAX ADD XML CDATA": {
			"Syntax": "**SAX ADD XML CDATA** ( *document* ; *données* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"données",
					"Blob, Text",
					"->",
					"Texte ou BLOB à insérer dans le document entre balises CData"
				]
			],
			"Summary": "La commande **SAX ADD XML CDATA** ajoute dans le document XML référencé par *document* des *données* de type texte ou BLOB."
		},
		"SAX ADD XML COMMENT": {
			"Syntax": "**SAX ADD XML COMMENT** ( *document* ; *commentaire* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"commentaire",
					"Text",
					"->",
					"Commentaire à ajouter"
				]
			],
			"Summary": "La commande **SAX ADD XML COMMENT** ajoute un *commentaire* dans le document XML référencé par *document*."
		},
		"SAX ADD XML DOCTYPE": {
			"Syntax": "**SAX ADD XML DOCTYPE** ( *document* ; *docType* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"docType",
					"Text",
					"->",
					"DocType à ajouter"
				]
			],
			"Summary": "La commande **SAX ADD XML DOCTYPE** ajoute l'instruction DocType définie par le paramètre *docType* dans le document XML référencé par *document*."
		},
		"SAX ADD XML ELEMENT VALUE": {
			"Syntax": "**SAX ADD XML ELEMENT VALUE** ( *document* ; *données* {; *} )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"données",
					"Text, Variable",
					"->",
					"Texte ou variable à insérer dans le document"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = Encoder les caractères spéciaux en mode 'XML Données brutes'"
				]
			],
			"Summary": "La commande **SAX ADD XML ELEMENT VALUE** ajoute directement dans le document XML référencé par *document* des *données* sans les convertir."
		},
		"SAX CLOSE XML ELEMENT": {
			"Syntax": "**SAX CLOSE XML ELEMENT** ( *document* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				]
			],
			"Summary": "La commande **SAX CLOSE XML ELEMENT** inscrit dans le document XML référencé par *document* les instructions nécessaires à la fermeture du dernier élément ouvert via la commande SAX OPEN XML ELEMENT."
		},
		"SAX GET XML CDATA": {
			"Syntax": "**SAX GET XML CDATA** ( *document* ; *valeur* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"valeur",
					"Text, Blob",
					"<-",
					"Valeur de l’élément"
				]
			],
			"Summary": "La commande **SAX GET XML CDATA** permet de récupérer la *valeur* CDATA d’un élément XML existant dans le document XML référencé par *document*."
		},
		"SAX GET XML COMMENT": {
			"Syntax": "**SAX GET XML COMMENT** ( *document* ; *commentaire* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"commentaire",
					"Text",
					"<-",
					"Commentaire XML"
				]
			],
			"Summary": "La commande **SAX GET XML COMMENT** retourne un *commentaire* si un événement SAX de type XML comment est généré dans le document XML référencé par *document*."
		},
		"SAX GET XML DOCUMENT VALUES": {
			"Syntax": "**SAX GET XML DOCUMENT VALUES** ( *document* ; *encodage* ; *version* ; *autonome* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"encodage",
					"Text",
					"<-",
					"Jeu de caractères du document XML"
				],
				[
					"version",
					"Text",
					"<-",
					"Version du XML"
				],
				[
					"autonome",
					"Boolean",
					"<-",
					"Vrai=le document est autonome, sinon Faux"
				]
			],
			"Summary": "La commande **SAX GET XML DOCUMENT VALUES** extrait des informations élémentaires de l’en-tête XML du document XML référencé par *document*."
		},
		"SAX GET XML ELEMENT VALUE": {
			"Syntax": "**SAX GET XML ELEMENT VALUE** ( *document* ; *valeur* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"valeur",
					"Text, Blob",
					"<-",
					"Valeur de l’élément"
				]
			],
			"Summary": "La commande **SAX GET XML ELEMENT VALUE** permet de récupérer la *valeur* d’un élément XML existant dans le document XML référencé par *document*."
		},
		"SAX GET XML ELEMENT": {
			"Syntax": "**SAX GET XML ELEMENT** ( *document* ; *nom* ; *préfixe* ; *nomsAttributs* ; *valeursAttributs* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"nom",
					"Text",
					"<-",
					"Nom de l’élément"
				],
				[
					"préfixe",
					"Text",
					"<-",
					"Espace de nommage"
				],
				[
					"nomsAttributs",
					"Text array",
					"<-",
					"Noms des attributs"
				],
				[
					"valeursAttributs",
					"Text array",
					"<-",
					"Valeurs des attributs"
				]
			],
			"Summary": "La commande **SAX GET XML ELEMENT** retourne diverses informations relatives à l’élément *nom* présent dans le document XML référencé par *document*."
		},
		"SAX GET XML ENTITY": {
			"Syntax": "**SAX GET XML ENTITY** ( *document* ; *nom* ; *valeur* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"nom",
					"Text",
					"<-",
					"Nom de l’entité"
				],
				[
					"valeur",
					"Text",
					"<-",
					"Valeur de l’entité"
				]
			],
			"Summary": "La commande **SAX GET XML ENTITY** permet de récupérer le *nom* et la *valeur* d’une entité XML présente dans le document XML référencé par *document*."
		},
		"SAX Get XML node": {
			"Syntax": "**SAX Get XML node** ( *document* ) : Integer",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Evénement retourné par la fonction"
				]
			],
			"Summary": "La commande **SAX Get XML node** retourne un entier long indiquant le type d’événement SAX retourné durant l’analyse du document XML référencé par *document*."
		},
		"SAX GET XML PROCESSING INSTRUCTION": {
			"Syntax": "**SAX GET XML PROCESSING INSTRUCTION** ( *document* ; *nom* ; *valeur* )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"nom",
					"Text",
					"<-",
					"Nom de l’instruction"
				],
				[
					"valeur",
					"Text",
					"<-",
					"Valeur de l’instruction"
				]
			],
			"Summary": "La commande **SAX GET XML PROCESSING INSTRUCTION** retourne le *nom* et la *valeur* de l’instruction de traitement XML analysée dans le document XML référencé par *document*."
		},
		"SAX OPEN XML ELEMENT ARRAYS": {
			"Syntax": "**SAX OPEN XML ELEMENT ARRAYS** ( *document* ; *balise* {; *tabNomsAttributs* ; *tabValeursAttributs*} {; *tabNomsAttributs2* ; *tabValeursAttributs2* ; ... ; *tabNomsAttributsN* ; *tabValeursAttributsN*} )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"balise",
					"Text",
					"->",
					"Nom de l’élément à ouvrir"
				],
				[
					"tabNomsAttributs",
					"Text array",
					"->",
					"Tableau de noms d’attributs"
				],
				[
					"tabValeursAttributs",
					"Text array, Integer array, Date array, Real array, Picture array, Boolean array",
					"->",
					"Tableau de valeurs d’attributs"
				]
			],
			"Summary": "La commande **SAX OPEN XML ELEMENT ARRAYS** permet d’ajouter un nouvel élément dans le document XML référencé par *document* ainsi que, facultativement, des attributs et leurs valeurs sous forme de tableaux."
		},
		"SAX OPEN XML ELEMENT": {
			"Syntax": "**SAX OPEN XML ELEMENT** ( *document* ; *balise* {; *nomAttribut* ; *valeurAttribut*} {; *nomAttribut2* ; *valeurAttribut2* ; ... ; *nomAttributN* ; *valeurAttributN*} )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"balise",
					"Text",
					"->",
					"Nom de l’élément à ouvrir"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Nom d’attribut"
				],
				[
					"valeurAttribut",
					"Text",
					"->",
					"Valeur d’attribut"
				]
			],
			"Summary": "La commande **SAX OPEN XML ELEMENT** permet d’ajouter un nouvel élément dans le document XML référencé par *document* ainsi que, facultativement, des attributs et leurs valeurs."
		},
		"SAX SET XML DECLARATION": {
			"Syntax": "**SAX SET XML DECLARATION** ( *document* ; *encodage* {; *autonome*} )",
			"Params": [
				[
					"document",
					"Time",
					"->",
					"Référence du document ouvert"
				],
				[
					"encodage",
					"Text",
					"->",
					"Jeu de caractères du document XML"
				],
				[
					"autonome",
					"Boolean",
					"->",
					"Vrai=le document est autonome, Faux (défaut)=le document n’est pas autonome"
				]
			],
			"Summary": "La commande **SAX SET XML DECLARATION** initialise le document XML référencé par *document* à l’aide de l'encodage défini."
		},
		"SCAN INDEX": {
			"Syntax": "**SCAN INDEX** ( *leChamp* ; *nombre* {; > ou <} )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ indexé avec lequel \"scanner\" les enregistrements"
				],
				[
					"nombre",
					"Integer",
					"->",
					"Nombre d'enregistrements à retourner"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"> à partir du début de l'index < à partir de la fin de l'index"
				]
			],
			"Summary": "La commande **SCAN INDEX** retourne une sélection de *nombre* enregistrements de la table du champ *leChamp*."
		},
		"SCREEN COORDINATES": {
			"Syntax": "**SCREEN COORDINATES** ( *gauche* ; *haut* ; *droite* ; *bas* {; *idEcran* {; *zoneEcran*}} )",
			"Params": [
				[
					"gauche",
					"Integer",
					"<-",
					"Coordonnée gauche de la zone de l'écran"
				],
				[
					"haut",
					"Integer",
					"<-",
					"Coordonnée supérieure de la zone de l'écran"
				],
				[
					"droite",
					"Integer",
					"<-",
					"Coordonnée droite de la zone de l'écran"
				],
				[
					"bas",
					"Integer",
					"<-",
					"Coordonnée inférieure de la zone de l'écran"
				],
				[
					"idEcran",
					"Integer",
					"->",
					"Numéro de l'écran ou écran principal si omis"
				],
				[
					"zoneEcran",
					"Integer",
					"->",
					"Ecran entier (par défaut) ou zone de travail"
				]
			],
			"Summary": "La commande **SCREEN COORDINATES** retourne dans les paramètres *gauche*, *haut*, *droite* et *bas* les coordonnées de l'écran spécifié dans le paramètre *idEcran*."
		},
		"SCREEN DEPTH": {
			"Syntax": "**SCREEN DEPTH** ( *profondeur* ; *couleur* {; écran} )",
			"Params": [
				[
					"profondeur",
					"Integer",
					"<-",
					"Profondeur de l'écran (nombre de couleurs = 2 ^ profondeur)"
				],
				[
					"couleur",
					"Integer",
					"<-",
					"1 = écran couleur 0 = écran noir et blanc ou niveaux de gris"
				],
				[
					"écran",
					"Integer",
					"->",
					"Numéro de l'écran ou écran principal si omis"
				]
			],
			"Summary": "La commande **SCREEN DEPTH** retourne dans les paramètres *profondeur* et *couleur* les caractéristiques du moniteur utilisé."
		},
		"Screen height": {
			"Syntax": "**Screen height** {( * )} : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Windows : hauteur de la fenêtre de l'application ou hauteur de l'écran si * est spécifiéMacintosh : hauteur de l'écran principal"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur exprimée en pixels"
				]
			],
			"Summary": "Sous Windows, **Screen height** retourne la hauteur de la fenêtre d'application 4D (fenêtre MDI)."
		},
		"Screen width": {
			"Syntax": "**Screen width** {( * )} : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Windows : largeur de la fenêtre de l'application ou largeur de l'écran si * est spécifiéMacintosh : largeur de l'écran principal"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Largeur exprimée en pixels"
				]
			],
			"Summary": "Sous Windows, **Screen width** retourne la largeur de la fenêtre d'application 4D (fenêtre MDI)."
		},
		"Select document": {
			"Syntax": "**Select document** ( *répertoire* ; *typesFichiers* ; *titre* ; *options* {; *sélectionnés*} ) : Text",
			"Params": [
				[
					"répertoire",
					"Text, Integer",
					"->",
					"• Chemin d’accès du répertoire à afficher par défaut dans la boîte de dialogue de sélection, ou• Chaîne vide pour afficher le dossier d’utilisateur par défaut (“Mes documents” sous Windows, “Documents” sous Mac OS), ou• Numéro de chemin d’accès mémorisé"
				],
				[
					"typesFichiers",
					"Text",
					"->",
					"Liste des types de documents à filtrer, ou \"*\" pour ne pas filtrer les documents"
				],
				[
					"titre",
					"Text",
					"->",
					"Titre de la boîte de dialogue de sélection"
				],
				[
					"options",
					"Integer",
					"->",
					"Option(s) de sélection"
				],
				[
					"sélectionnés",
					"Text array",
					"<-",
					"Tableau contenant la liste des chemins d’accès + les noms des fichiers sélectionnés"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom du fichier sélectionné (premier fichier de la liste en cas de sélection multiple)"
				]
			],
			"Summary": "La commande **Select document** affiche une boîte de dialogue standard d’ouverture de documents, permettant à l’utilisateur de désigner un ou plusieurs fichier(s), et retourne le nom et/ou le chemin d’accès complet du ou des fichier(s) sélectionné(s)."
		},
		"Select folder": {
			"Syntax": "**Select folder** ( {*message* }{;}{ *répertoire* {; *options*}} ) : Text",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Titre de la fenêtre de sélection"
				],
				[
					"répertoire",
					"Text, Integer",
					"->",
					"Chemin d’accès du répertoire par défautou Chaîne vide pour afficher le dossier d’utilisateur par défaut (“Mes documents” sous Windows, “Documents” sous Mac OS),ou Numéro de chemin d’accès mémorisé"
				],
				[
					"options",
					"Integer",
					"->",
					"Option(s) de sélection sous Mac OS"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès au dossier sélectionné"
				]
			],
			"Summary": "La commande **Select folder** affiche une boîte de dialogue permettant de désigner manuellement un dossier, et de récupérer en retour de fonction le chemin d’accès complet au dossier sélectionné."
		},
		"SELECT LIST ITEMS BY POSITION": {
			"Syntax": "**SELECT LIST ITEMS BY POSITION** ( {* ;} *liste* ; *positionElém* {; *tabPositions*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"positionElém",
					"Integer",
					"->",
					"Position de l'élément dans la ou les liste(s) déployée(s)/contractée(s)"
				],
				[
					"tabPositions",
					"Integer array",
					"->",
					"Tableau de positions dans la ou les liste(s) déployée(s)/contractée(s)"
				]
			],
			"Summary": "La commande **SELECT LIST ITEMS BY POSITION** sélectionne le ou les élément(s) dont vous avez passé la position dans *positionElém* et, facultativement, dans *tabPositions*, à l'intérieur de la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"SELECT LIST ITEMS BY REFERENCE": {
			"Syntax": "**SELECT LIST ITEMS BY REFERENCE** ( *liste* ; *réfElément* {; *tabRéfs*} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de liste"
				],
				[
					"réfElément",
					"Integer",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste"
				],
				[
					"tabRéfs",
					"Integer array",
					"->",
					"Tableau de numéros de référence d’éléments"
				]
			],
			"Summary": "La commande **SELECT LIST ITEMS BY REFERENCE** sélectionne le ou les élément(s) dont vous avez passé le numéro de référence dans *réfElément* et, facultativement, dans *tabRéfs*, parmi la liste dont vous avez passé la référence dans *liste*."
		},
		"Select RGB color": {
			"Syntax": "**Select RGB color** {( *coulDefaut* {; *message*} )} : Integer",
			"Params": [
				[
					"coulDefaut",
					"Integer",
					"->",
					"Couleur RVB présélectionnée"
				],
				[
					"message",
					"Text",
					"->",
					"Titre de la fenêtre de sélection"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Couleur RVB"
				]
			],
			"Summary": "La commande **Select RGB color** affiche la fenêtre système de sélection de couleur et retourne la valeur RVB de la couleur sélectionnée par l’utilisateur."
		},
		"Selected list items": {
			"Syntax": "**Selected list items** ( {* ;} *liste* {; *tabEléments* {; *}} )  : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"tabEléments",
					"Integer array",
					"<-",
					"Si 2e * omis : Tableau des positions des éléments sélectionnés dans la ou les liste(s) Si 2e * passé : Tableau des références des éléments sélectionnés dans la ou les liste(s)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si omis : Position(s) d’élément(s) Si passé : Référence(s) d’élément(s)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Si 2e * omis : Position de l'élément sélectionné parmi la ou les liste(s) déployée(s)/contractée(s) Si 2e * passé : Référence de l'élément sélectionné"
				]
			],
			"Summary": "La fonction **Selected list items** retourne la **position** ou la **référence** de l'élément sélectionné dans la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"Selected record number": {
			"Syntax": "**Selected record number** {( *laTable* )} : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle retourner le numéro de l'enregistrement courant dans la sélection"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro dans la sélection"
				]
			],
			"Summary": "**Selected record number** retourne la position de l'enregistrement courant dans la sélection courante de *laTable*."
		},
		"SELECTION RANGE TO ARRAY": {
			"Syntax": "**SELECTION RANGE TO ARRAY** ( *début* ; *fin* {; leChamp | laTable ; *tableau*} {; leChamp | laTable2 ; *tableau2* ; ... ; leChamp | laTableN ; *tableauN*} )",
			"Params": [
				[
					"début",
					"Integer",
					"->",
					"Numéro de l'enregistrement sous-sélectionné à partir duquel commencer la copie des données"
				],
				[
					"fin",
					"Integer",
					"->",
					"Numéro de l'enregistrement sous-sélectionné auquel arrêter la copie des données"
				],
				[
					"leChamp &#124; laTable",
					"Champ, Table",
					"->",
					"Champ à utiliser pour récupérer les données ou Table à utiliser pour récupérer les numéros d'enregistrements"
				],
				[
					"tableau",
					"Array",
					"<-",
					"Tableau recevant les données ou les numéros d'enregistrements"
				]
			],
			"Summary": "**SELECTION RANGE TO ARRAY** crée un ou plusieurs tableau(x) et y copie des données en provenance des champs de la sélection courante ou les numéros des enregistrements de la sélection courante."
		},
		"SELECTION TO ARRAY": {
			"Syntax": "**SELECTION TO ARRAY** {( *leChamp* ; *tableau* {; *leChamp2* ; *tableau2* ; ... ; *leChampN* ; *tableauN*}{; *})<br/>**SELECTION TO ARRAY** {( *laTable* ; *tableau* {; *leChamp* ; *tableau* {; *leChamp2* ; *tableau2* ; ... ; *leChampN* ; *tableauN*}}{; *})}",
			"Params": [
				[
					"leChamp &#124; laTable",
					"Champ, Table",
					"->",
					"Champ à récupérer dans le tableau ou Table dont les numéros d'enregistrements sont à récupérer dans le tableau"
				],
				[
					"tableau",
					"Array",
					"<-",
					"Tableau recevant les valeurs des champs ou les numéros d'enregistrements"
				],
				[
					"leField",
					"Field",
					"->",
					"Champ à récupérer dans le tableau"
				],
				[
					"tableau",
					"Array",
					"<-",
					"Tableau recevant les valeurs du champ"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Attente d’exécution"
				]
			],
			"Summary": "La commande **SELECTION TO ARRAY** crée un ou plusieurs tableau(x) et y copie les valeurs des champ(s) ou les numéros d'enregistrement(s) de la sélection courante."
		},
		"Selection to JSON": {
			"Syntax": "**Selection to JSON** ( *laTable* {; *leChamp*}{; *leChamp2* ; ... ; *leChampN*}{; *template*})  : Text",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à sérialiser"
				],
				[
					"leField",
					"Field",
					"->",
					"Champ(s) dont le contenu doit être sérialisé"
				],
				[
					"template",
					"Object",
					"->",
					"Objet pour la sélection de libellés et de champs"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chaîne contenant le tableau JSON sérialisé"
				]
			],
			"Summary": "La commande **Selection to JSON** retourne une chaîne qui contient un tableau JSON avec autant d'éléments qu'il y a d'enregistrements dans la sélection courante de *laTable*."
		},
		"Self": {
			"Syntax": "**Self**  : Pointer",
			"Params": [
				[
					"Résultat",
					"Pointer",
					"<-",
					"Pointeur vers l'objet du formulaire dont la méthode est en cours d'exécution (le cas échéant) Sinon Nil (->[]) si hors contexte"
				]
			],
			"Summary": "Cette commande est conservée pour des raisons de compatibilité uniquement."
		},
		"Semaphore": {
			"Syntax": "**Semaphore** ( *sémaphore* {; *nbTicks*} ) : Boolean",
			"Params": [
				[
					"sémaphore",
					"Text",
					"->",
					"Sémaphore à tester et à positionner"
				],
				[
					"nbTicks",
					"Integer",
					"->",
					"Temps d’attente maximum"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"sémaphore a été correctement créé (Faux) ou sémaphore était déjà créé (Vrai)"
				]
			],
			"Summary": "Un sémaphore est un drapeau visible par chaque poste client ou chaque process sur un même poste."
		},
		"SEND MESSAGE TO REMOTE USER": {
			"Syntax": "**SEND MESSAGE TO REMOTE USER** ( *message* {; *sessionUtilisateur*} )",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Texte envoyé à l'utilisateur"
				],
				[
					"sessionUtilisateur",
					"Text",
					"->",
					"ID de la session de l'utilisateur"
				]
			],
			"Summary": "La commande **SEND MESSAGE TO REMOTE USER** permet d'envoyer un message à tous les utilisateurs distants ou à un utilisateur distant spécifique."
		},
		"SEND PACKET": {
			"Syntax": "**SEND PACKET** ( {*docRef* ;} *paquet* )",
			"Params": [
				[
					"docRef",
					"Time",
					"->",
					"Référence de document ou canal courant (port série ou document)"
				],
				[
					"paquet",
					"Text, Blob",
					"->",
					"Chaîne ou BLOB à envoyer"
				]
			],
			"Summary": "La commande **SEND PACKET** envoie *paquet* vers un port série ou un document."
		},
		"SEND RECORD": {
			"Syntax": "**SEND RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle envoyer l'enregistrement courant ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**SEND RECORD** envoie l'enregistrement courant de *laTable* vers le port série ou vers un document ouvert par la commande SET CHANNEL."
		},
		"SEND VARIABLE": {
			"Syntax": "**SEND VARIABLE** ( *variable* )",
			"Params": [
				[
					"variable",
					"Variable",
					"->",
					"Variable à envoyer"
				]
			],
			"Summary": "**SEND VARIABLE** envoie *variable* vers le document ou le port série préalablement ouvert par la commande SET CHANNEL."
		},
		"Sequence number": {
			"Syntax": "**Sequence number** {( *laTable* )} : Integer",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à numéroter automatiquement ou Table par défaut si ce paramètre est omis"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro automatique"
				]
			],
			"Summary": "**Sequence number** retourne le prochain numéro automatique de *laTable*."
		},
		"SET ABOUT": {
			"Syntax": "**SET ABOUT** ( *libelléElément* ; *méthode* )",
			"Params": [
				[
					"libelléElément",
					"Text",
					"->",
					"Nouvelle ligne de menu A propos..."
				],
				[
					"méthode",
					"Text",
					"->",
					"Nom de la méthode à exécuter lorsque la ligne est choisie"
				]
			],
			"Summary": "La commande **SET ABOUT** remplace la ligne de menu **A propos de 4D."
		},
		"SET APPLICATION COLOR SCHEME": {
			"Syntax": "**SET APPLICATION COLOR SCHEME** ( *schemaCouleur* )",
			"Params": [
				[
					"schemaCouleur",
					"Text",
					"->",
					"\"light\", \"dark\", ou \"inherited\""
				]
			],
			"Summary": "La commande **SET APPLICATION COLOR SCHEME** définit le schéma de couleurs à utiliser au niveau de l'application pour la session courante."
		},
		"SET ASSERT ENABLED": {
			"Syntax": "**SET ASSERT ENABLED** ( *asserts* {; *} )",
			"Params": [
				[
					"asserts",
					"Boolean",
					"->",
					"Vrai = activer les assertions, <br/>Faux = désactiver les assertions"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si omis = la commande s’applique à l’ensemble des process, <br/>Si passé = la commande s’applique au process courant uniquement"
				]
			],
			"Summary": "La commande **SET ASSERT ENABLED** permet de désactiver ou de réactiver les assertions éventuellement insérées dans le code 4D de l’application."
		},
		"SET AUTOMATIC RELATIONS": {
			"Syntax": "**SET AUTOMATIC RELATIONS** ( *aller* {; *retour*} )",
			"Params": [
				[
					"aller",
					"Boolean",
					"->",
					"Statut de tous les liens de N vers 1"
				],
				[
					"retour",
					"Boolean",
					"->",
					"Statut de tous les liens de 1 vers N"
				]
			],
			"Summary": "La commande **SET AUTOMATIC RELATIONS** transforme tous les liens manuels en liens automatiques pour toute la base dans le process courant."
		},
		"SET BLOB SIZE": {
			"Syntax": "**SET BLOB SIZE** ( *blob* ; *taille* {; *remplisseur*} )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"Champ ou variable de type BLOB"
				],
				[
					"taille",
					"Integer",
					"->",
					"Nouvelle taille de BLOB"
				],
				[
					"remplisseur",
					"Integer",
					"->",
					"Code du caractère de remplissage"
				]
			],
			"Summary": "**SET BLOB SIZE** redimensionne *blob* selon la valeur passée dans le paramètre *taille*."
		},
		"SET BLOBS CACHE PRIORITY": {
			"Syntax": "**SET BLOBS CACHE PRIORITY** ( *laTable* ; *priorité* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous souhaitez modifier la priorité des données \"blobs\" pour toute la session"
				],
				[
					"priorité",
					"Integer",
					"->",
					"Priorité des données \"blobs\" de la table dans le cache"
				]
			],
			"Summary": "Cette commande est réservée pour des besoins spécifiques."
		},
		"SET CACHE SIZE": {
			"Syntax": "**SET CACHE SIZE** ( *taille* {; *libereMini*} )",
			"Params": [
				[
					"taille",
					"Real",
					"->",
					"Taille du cache du la base de données en octets"
				],
				[
					"libereMini",
					"Real",
					"->",
					"Nombre minimum d'octets à libérer lorsque le cache est plein"
				]
			],
			"Summary": "La commande **SET CACHE SIZE** fixe dynamiquement la taille du cache de la base de données et, optionnellement, permet de fixer la taille minimum en octets à partir de laquelle on commence à libérer la mémoire."
		},
		"SET CHANNEL": {
			"Syntax": "**SET CHANNEL** ( *port* ; *param* ) <br/>\n**SET CHANNEL** ( *opération* ; *nomFichier* )",
			"Params": [
				[
					"port",
					"Integer",
					"->",
					"Numéro de port série"
				],
				[
					"param",
					"Integer",
					"->",
					"Paramètres de communication"
				],
				[
					"SET CHANNEL ( opération ; nomFichier )"
				],
				[
					"Paramètre",
					"Type",
					"Description"
				],
				[
					"opération",
					"Integer",
					"->",
					"Opération à effectuer sur document"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du document"
				]
			],
			"Summary": "La commande **SET CHANNEL** permet d'ouvrir un port série ou un document."
		},
		"SET CURRENT PRINTER": {
			"Syntax": "**SET CURRENT PRINTER** ( *nomImpr* )",
			"Params": [
				[
					"nomImpr",
					"Text",
					"->",
					"Nom de l’imprimante à utiliser"
				]
			],
			"Summary": "La commande **SET CURRENT PRINTER** permet de désigner l’imprimante à utiliser pour les impressions avec l’application 4D courante."
		},
		"SET CURSOR": {
			"Syntax": "**SET CURSOR** {( *curseur* )}",
			"Params": [
				[
					"curseur",
					"Integer",
					"->",
					"Numéro de curseur système"
				]
			],
			"Summary": "La commande **SET CURSOR** remplace le pointeur (graphique) de la souris par le pointeur système dont vous avez passé le numéro d'ID dans le paramètre *curseur*."
		},
		"SET DATABASE LOCALIZATION": {
			"Syntax": "**SET DATABASE LOCALIZATION** ( *codeLangue* {; *} )",
			"Params": [
				[
					"codeLangue",
					"Text",
					"->",
					"Sélecteur de langue"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Portée de la commande"
				]
			],
			"Summary": "La commande **SET DATABASE LOCALIZATION** permet de modifier la langue courante de la base pour la session courante."
		},
		"SET DATABASE PARAMETER": {
			"Syntax": "**SET DATABASE PARAMETER** ( {*laTable* ;} *sélecteur* ; *valeur* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table à paramétrer ou Table par défaut si ce paramètre est omis"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Code du paramètre de la base à modifier"
				],
				[
					"valeur",
					"Real, Text",
					"->",
					"Valeur du paramètre"
				]
			],
			"Summary": "La commande **SET DATABASE PARAMETER** permet de modifier divers paramètres internes de la base de données 4D."
		},
		"SET DEFAULT CENTURY": {
			"Syntax": "**SET DEFAULT CENTURY** ( *siècle* {; *anPivot*} )",
			"Params": [
				[
					"siècle",
					"Integer",
					"->",
					"Siècle par défaut (moins un) lors de la saisie d'années sur 2 chiffres"
				],
				[
					"anPivot",
					"Integer",
					"->",
					"Année pivot lors de la saisie d'années sur 2 chiffres"
				]
			],
			"Summary": "La commande **SET DEFAULT CENTURY** vous permet de définir le siècle courant par défaut et l'année pivot adoptés par 4D lorsque des dates sont saisies avec seulement deux chiffres pour l'année."
		},
		"SET DOCUMENT POSITION": {
			"Syntax": "**SET DOCUMENT POSITION** ( *docRef* ; *offset* {; *ancre*} )",
			"Params": [
				[
					"docRef",
					"Time",
					"->",
					"Numéro de référence de document"
				],
				[
					"offset",
					"Real",
					"->",
					"Position dans fichier (exprimée en octets)"
				],
				[
					"ancre",
					"Integer",
					"->",
					"1 = Par rapport au début du fichier 2 = Par rapport à la fin du fichier 3 = Par rapport à la position courante"
				]
			],
			"Summary": "Cette commande ne fonctionne qu'avec un document déjà ouvert, dont vous avez passé le numéro de référence dans le paramètre *docRef*."
		},
		"SET DOCUMENT PROPERTIES": {
			"Syntax": "**SET DOCUMENT PROPERTIES** ( *nomFichier* ; *verrouillé* ; *invisible* ; créé le ; créé à  ; modifié le ; modifié à )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom du document ou Chemin d'accès complet au document"
				],
				[
					"verrouillé",
					"Boolean",
					"->",
					"Verrouillé (Vrai) ou non verrouillé (Faux)"
				],
				[
					"invisible",
					"Boolean",
					"->",
					"Invisible (Vrai) ou visible (Faux)"
				],
				[
					"créé le",
					"Date",
					"->",
					"Date de création"
				],
				[
					"créé à",
					"Heure",
					"->",
					"Heure de création"
				],
				[
					"modifié le",
					"Date",
					"->",
					"Date de dernière modification"
				],
				[
					"modifié à",
					"Heure",
					"->",
					"Heure de dernière modification"
				]
			],
			"Summary": "La commande **SET DOCUMENT PROPERTIES** modifie certaines informations du document dont vous avez passé le nom ou le chemin d'accès dans *document*."
		},
		"SET DOCUMENT SIZE": {
			"Syntax": "**SET DOCUMENT SIZE** ( *docRef* ; *taille* )",
			"Params": [
				[
					"docRef",
					"Time",
					"->",
					"Numéro de référence de document"
				],
				[
					"taille",
					"Real",
					"->",
					"Nouvelle taille (en octets) de document"
				]
			],
			"Summary": "La commande **SET DOCUMENT SIZE** fixe la taille d'un document au nombre d'octets que vous avez passé dans *taille*."
		},
		"SET DRAG ICON": {
			"Syntax": "**SET DRAG ICON** ( *icône* {; *décalageH* {; *décalageV*}} )",
			"Params": [
				[
					"icône",
					"Picture",
					"->",
					"Icône à utiliser lors du glisser"
				],
				[
					"décalageH",
					"Integer",
					"->",
					"Décalage horizontal du bord gauche de l’image par rapport à la position du curseur (>0 = vers la gauche, <0 = vers la droite)"
				],
				[
					"décalageV",
					"Integer",
					"->",
					"Décalage vertical du bord supérieur de l’image par rapport à la position du curseur (>0 = vers le haut, <0 = vers le bas)"
				]
			],
			"Summary": "La commande **SET DRAG ICON** vous permet d’associer l’image *icône* au curseur lors des glisser-déposer gérés par programmation."
		},
		"SET ENVIRONMENT VARIABLE": {
			"Syntax": "**SET ENVIRONMENT VARIABLE** ( *nomVar* ; *valeurVar* )",
			"Params": [
				[
					"nomVar",
					"Text",
					"->",
					"Nom de la variable à fixer"
				],
				[
					"valeurVar",
					"Text",
					"->",
					"Valeur de la variable ou \"\" pour rétablir la valeur par défaut"
				]
			],
			"Summary": "La commande **SET ENVIRONMENT VARIABLE** vous permet de fixer la valeur d’une variable d’environnement sous macOS et Windows."
		},
		"SET EXTERNAL DATA PATH": {
			"Syntax": "**SET EXTERNAL DATA PATH** ( *leChamp* ; *chemin* )",
			"Params": [
				[
					"leChamp",
					"Text, Blob, Picture",
					"->",
					"Champ pour lequel définir le lieu de stockage"
				],
				[
					"chemin",
					"Text, Integer",
					"->",
					"Chemin d’accès et nom du fichier de stockage externe ou<br/>0 = utiliser la définition en structure<br/>1 = utiliser le dossier par défaut"
				]
			],
			"Summary": "La commande **SET EXTERNAL DATA PATH** permet de définir ou de modifier, pour l’enregistrement courant, l’emplacement de stockage externe du champ *leChamp* passé en paramètre."
		},
		"SET FIELD RELATION": {
			"Syntax": "**SET FIELD RELATION** ( tableN | champN ; *aller* ; *retour* )",
			"Params": [
				[
					"tableN &#124; champN",
					"Table, Champ",
					"->",
					"Table de départ des liens ou Champ de départ du lien"
				],
				[
					"aller",
					"Integer",
					"->",
					"Statut du lien aller partant du champ ou des liens aller partant de la table"
				],
				[
					"retour",
					"Integer",
					"->",
					"Statut du lien retour partant du champ ou des liens retour partant de la table"
				]
			],
			"Summary": "La commande **SET FIELD RELATION** permet de définir séparément le statut automatique/manuel de chaque lien de la base pour le process courant, quel que soit son statut initial défini en mode Développement dans la fenêtre de paramétrage des liens."
		},
		"SET FIELD TITLES": {
			"Syntax": "**SET FIELD TITLES** ( *laTable* ; *titresChamps* ; *numChamps* {; *} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous voulez redéfinir les titres des champs"
				],
				[
					"titresChamps",
					"Text array",
					"->",
					"Nouveaux titres des champs"
				],
				[
					"numChamps",
					"Integer array",
					"->",
					"Numéros des champs"
				],
				[
					"*",
					"Operator",
					"->",
					"Utiliser les noms personnalisés dans l’éditeur de formules"
				]
			],
			"Summary": "**SET FIELD TITLES** vous permet de masquer, renommer et réordonner les champs d'une table de votre base lorsqu'ils apparaissent dans les éditeurs standard de 4D en mode Application (lorsque le mode de lancement est le mode **Application**, ou après avoir sélectionné \"**Tester l'application**\" dans le menu **Exécution**)."
		},
		"SET FIELD VALUE NULL": {
			"Syntax": "**SET FIELD VALUE NULL** ( *leChamp* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ auquel attribuer la valeur NULL"
				]
			],
			"Summary": "La commande **SET FIELD VALUE NULL** attribue la valeur NULL au champ désigné par le paramètre *leChamp*."
		},
		"SET FILE TO PASTEBOARD": {
			"Syntax": "**SET FILE TO PASTEBOARD** ( *fichier* {; *} )",
			"Params": [
				[
					"fichier",
					"Text",
					"->",
					"Nom de fichier ou Chemin d'accès complet de fichier"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = ajouter, Si omis = remplacer"
				]
			],
			"Summary": "La commande **SET FILE TO PASTEBOARD** ajoute dans le conteneur de données le chemin d’accès complet du fichier passé dans le paramètre *fichier*."
		},
		"SET GROUP ACCESS": {
			"Syntax": "**SET GROUP ACCESS** {( *groupes* )}",
			"Params": [
				[
					"groupes",
					"Collection",
					"->",
					"Nom(s) de groupe(s) au(x)quel(s) le compte utilisateur doit appartenir durant la session"
				]
			],
			"Summary": "La commande **SET GROUP ACCESS** modifie l'adhésion du compte utilisateur pour la session courante."
		},
		"Set group properties": {
			"Syntax": "**Set group properties** ( *réfGroupe* ; *nom* ; *propriétaire* {; *membres*} )  : Integer",
			"Params": [
				[
					"réfGroupe",
					"Integer",
					"->",
					"Numéro de référence unique du groupe activé ou -1 pour ajouter un groupe de Super_Utilisateur -2 pour ajouter un groupe d'Administrateur"
				],
				[
					"<-",
					"Unique ID number of added group (if any)"
				],
				[
					"nom",
					"Text",
					"->",
					"Nouveau nom de groupe"
				],
				[
					"propriétaire",
					"Integer",
					"->",
					"Numéro de référence unique de l'utilisateur ou le propriétaire du nouveau groupe"
				],
				[
					"membres",
					"Integer array",
					"->",
					"Nouveaux membres du groupe"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence unique du nouveau groupe"
				]
			],
			"Summary": "**Set group properties** vous permet de modifier et de mettre à jour les propriétés d'un groupe existant dont vous passez le numéro de référence unique dans *réfGroupe*, ou d'ajouter un nouveau groupe."
		},
		"SET HELP MENU": {
			"Syntax": "**SET HELP MENU** ( *menuCol* )",
			"Params": [
				[
					"menuCol",
					"Collection",
					"->",
					"Collection of menu objects"
				]
			],
			"Summary": "La commande **SET HELP MENU** vous permet de remplacer le menu **Aide** par défaut de 4D par la collection d'éléments de menu MenuCol dans le mode d'application."
		},
		"SET INDEX CACHE PRIORITY": {
			"Syntax": "**SET INDEX CACHE PRIORITY** ( *leChamp* ; *priorité* )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ dont vous voulez modifier la priorité des index pour toute la session"
				],
				[
					"priorité",
					"Integer",
					"->",
					"Priorité du ou des index du champ dans le cache"
				]
			],
			"Summary": "Cette commande est réservée pour des besoins spécifiques."
		},
		"SET INDEX": {
			"Syntax": "**SET INDEX** ( *leChamp* ; *index* {; *} )",
			"Params": [
				[
					"leField",
					"Field",
					"->",
					"Champ duquel créer ou supprimer l’index"
				],
				[
					"index",
					"Boolean, Integer",
					"->",
					"• Vrai=Créer l’index, Faux=Supprimer l’index, ou• Créer un index de type : -1=mots-clés, 0=par défaut, 1=B-Tree standard, 3=B-Tree cluster"
				],
				[
					"*",
					"Operator",
					"->",
					"Indexation asynchrone si * est passé"
				]
			],
			"Summary": "Bien que **SET INDEX** soit une ancienne commande, elle reste entièrement prise en charge et peut être conservée dans votre application -- il n'est pas nécessaire de réécrire le code existant."
		},
		"SET LIST ITEM FONT": {
			"Syntax": "**SET LIST ITEM FONT** ( {* ;} *liste* ; refElément | * ; *police* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d’élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"police",
					"Text, Integer",
					"->",
					"Nom ou numéro de police"
				]
			],
			"Summary": "La commande **SET LIST ITEM FONT** modifie la police de caractères de l’élément désigné par le paramètre *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d’objet dans *liste*."
		},
		"SET LIST ITEM ICON": {
			"Syntax": "**SET LIST ITEM ICON** ( {* ;} *liste* ; réfElément | * ; *icône* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"réfElément &#124; *",
					"Entier long, Opérateur",
					"->",
					"Numéro de référence d’élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"icône",
					"Picture",
					"->",
					"Icône à associer à l'élément"
				]
			],
			"Summary": "La commande **SET LIST ITEM ICON** permet de modifier l’icône associée à l’élément désigné par le paramètre *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d’objet dans *liste*."
		},
		"SET LIST ITEM PARAMETER": {
			"Syntax": "**SET LIST ITEM PARAMETER** ( {* ;} *liste* ; refElément | * ; *sélecteur* ; *valeur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d’objet (chaîne) Si omis, liste est un numéro de référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Opérateur, Entier long",
					"->",
					"Numéro de référence d’élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"sélecteur",
					"Text",
					"->",
					"Constante de paramètre"
				],
				[
					"valeur",
					"Text, Boolean, Real",
					"->",
					"Valeur de paramètre"
				]
			],
			"Summary": "La commande **SET LIST ITEM PARAMETER** permet de modifier le paramètre *sélecteur* pour l’élément *réfElément* de la liste hiérarchique dont vous avez passé la référence ou le nom d’objet dans le paramètre *liste*."
		},
		"SET LIST ITEM PROPERTIES": {
			"Syntax": "**SET LIST ITEM PROPERTIES** ( {* ;} *liste* ; refElément | * ; *saisissable* ; *style* {; *icône* {; *couleur*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Opérateur, Entier long",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"saisissable",
					"Boolean",
					"->",
					"Vrai = Saisissable, Faux = Non-saisissable"
				],
				[
					"style",
					"Integer",
					"->",
					"Style de police pour l'élément"
				],
				[
					"icône",
					"Text, Integer",
					"->",
					"Nom ou numéro d'image (\"\" ou 0 pour ne pas associer d'icône)"
				],
				[
					"couleur",
					"Integer",
					"->",
					"Valeur de couleur RVB ou -1 = rétablir couleur originale"
				]
			],
			"Summary": "La commande **SET LIST ITEM PROPERTIES** modifie l'élément désigné par le paramètre *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"SET LIST ITEM": {
			"Syntax": "**SET LIST ITEM** ( {* ;} *liste* ; refElément | * ; *libelléElément* ; *nouvelRéf* {; sous_Liste ; *déployée*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, liste est un nom d'objet (chaîne) Si omis, liste est une référence de liste"
				],
				[
					"liste",
					"Integer, Text",
					"->",
					"Numéro de référence de liste (si * omis) ou Nom d'objet de type liste (si * passé)"
				],
				[
					"refElément &#124; *",
					"Opérateur, Entier long",
					"->",
					"Numéro de référence d'élément ou 0 pour le dernier élément ajouté à la liste ou * pour l’élément courant de la liste"
				],
				[
					"libelléElément",
					"Text",
					"->",
					"Nouveau libellé d'élément"
				],
				[
					"nouvelRéf",
					"Integer",
					"->",
					"Nouveau numéro de référence d'élément"
				],
				[
					"sous_Liste",
					"Integer",
					"->",
					"Nouvelle sous-liste rattachée à l'élément ou 0 = pas de sous-liste (détacher sous-liste courante) ou -1 = pas de changement"
				],
				[
					"déployée",
					"Boolean",
					"->",
					"Indique si la sous-liste doit être déployée/contractée"
				]
			],
			"Summary": "La commande **SET LIST ITEM** modifie l'élément désigné par le paramètre *réfElément* de la liste dont vous avez passé le numéro de référence ou le nom d'objet dans *liste*."
		},
		"SET LIST PROPERTIES": {
			"Syntax": "**SET LIST PROPERTIES** ( *liste* ; *apparence* {; *icône* {; *hauteurLigne* {; *doubleClic* {; *multiSélection* {; *modifiable*}}}}} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de la liste"
				],
				[
					"apparence",
					"Integer",
					"->",
					"*** paramètre obsolète, toujours passer 0 ***"
				],
				[
					"icône",
					"Integer",
					"->",
					"*** Paramètre obsolète, toujours passer 0 ***"
				],
				[
					"hauteurLigne",
					"Integer",
					"->",
					"Hauteur minimale de la ligne (pixels)"
				],
				[
					"doubleClic",
					"Integer",
					"->",
					"Déploiement/contraction sur double-clic 0 = autoriser, 1= empêcher"
				],
				[
					"multiSélection",
					"Integer",
					"->",
					"Sélections multiples 0 = interdire (défaut), 1 = autoriser"
				],
				[
					"modifiable",
					"Integer",
					"->",
					"Enumération modifiable 0 = non, 1 = oui (défaut)"
				]
			],
			"Summary": "La commande **SET LIST PROPERTIES** définit la hauteur de ligne et le fonctionnement de la liste hiérarchique dont la référence est passée dans le paramètre *liste*."
		},
		"SET MACRO PARAMETER": {
			"Syntax": "**SET MACRO PARAMETER** ( *sélecteur* ; *paramTexte* )",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Sélection à utiliser"
				],
				[
					"paramText",
					"Text",
					"->",
					"Texte envoyé"
				]
			],
			"Summary": "La commande **SET MACRO PARAMETER** insère le texte *paramTexte* dans la méthode depuis laquelle elle a été appelée."
		},
		"SET MENU BAR": {
			"Syntax": "**SET MENU BAR** ( *barre* {; *process*}{; *} )",
			"Params": [
				[
					"barre",
					"Integer, Text, Text",
					"->",
					"Numéro ou nom de la barre de menus ou Référence de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Conserver l'état de la barre de menus"
				]
			],
			"Summary": "La commande **SET MENU BAR** remplace la barre de menus courante par la barre de menus *barre*, pour le process en cours uniquement."
		},
		"SET MENU ITEM ICON": {
			"Syntax": "**SET MENU ITEM ICON** ( *menu* ; *ligneMenu* ; *refIcône* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"refIcône",
					"Text, Integer",
					"->",
					"Nom ou numéro de l’image à associer à la ligne de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "La commande **SET MENU ITEM ICON** permet de modifier l’icône associée à la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"SET MENU ITEM MARK": {
			"Syntax": "**SET MENU ITEM MARK** ( *menu* ; *ligneMenu* ; *marque* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"marque",
					"Text",
					"->",
					"Nouvelle marque de ligne de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				]
			],
			"Summary": "La commande **SET MENU ITEM MARK** remplace la marque (ou \"coche\") de la ligne de menu dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu* par le premier caractère de la chaîne que vous avez passée dans *marque* (sous Mac OS) ou par la coche standard (sous Windows)."
		},
		"SET MENU ITEM METHOD": {
			"Syntax": "**SET MENU ITEM METHOD** ( *menu* ; *ligneMenu* ; *nomMéthode* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de la méthode"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "La commande **SET MENU ITEM METHOD** permet de modifier la méthode projet 4D associée à la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"SET MENU ITEM PARAMETER": {
			"Syntax": "**SET MENU ITEM PARAMETER** ( *menu* ; *ligneMenu* ; *param* )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"param",
					"Text",
					"->",
					"Chaîne à associer en tant que paramètre"
				]
			],
			"Summary": "La commande **SET MENU ITEM PARAMETER** vous permet d’associer une chaîne de caractères personnalisée à la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"SET MENU ITEM PROPERTY": {
			"Syntax": "**SET MENU ITEM PROPERTY** ( *menu* ; *ligneMenu* ; *propriété* ; *valeur* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Référence de menu ou Numéro de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée au menu"
				],
				[
					"propriété",
					"Text",
					"->",
					"Type de propriété"
				],
				[
					"valeur",
					"Text, Number, Boolean",
					"->",
					"Valeur de la propriété"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de process"
				]
			],
			"Summary": "La commande **SET MENU ITEM PROPERTY** permet de fixer la *valeur* de la *propriété* pour la ligne de menu désignée par les paramètres *menu* et *ligneMenu*."
		},
		"SET MENU ITEM SHORTCUT": {
			"Syntax": "**SET MENU ITEM SHORTCUT** ( *menu* ; *ligneMenu* ; *touche* ; *modificateurs* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro du menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"touche",
					"Text, Integer",
					"->",
					"Lettre du raccourci clavier ou code de caractère du raccourci clavier (ancienne syntaxe)"
				],
				[
					"modificateurs",
					"Integer",
					"->",
					"Modificateur(s) à associer au raccourci (ignoré si un code de touche est passé)"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				]
			],
			"Summary": "La commande **SET MENU ITEM SHORTCUT** remplace la touche du raccourci clavier associé à la ligne de menu désignée par *menu* et *ligneMenu*, par le caractère dont vous avez passé le code de caractère ou le texte dans *touche*."
		},
		"SET MENU ITEM STYLE": {
			"Syntax": "**SET MENU ITEM STYLE** ( *menu* ; *ligneMenu* ; *styleLigne* {; *process*} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"styleLigne",
					"Integer",
					"->",
					"Nouveau style de la ligne de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence du process"
				]
			],
			"Summary": "La commande **SET MENU ITEM STYLE** remplace le style de police de la ligne de menu, dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*, par le style de police que vous avez passé dans *styleLigne*."
		},
		"SET MENU ITEM": {
			"Syntax": "**SET MENU ITEM** ( *menu* ; *ligneMenu* ; *libelléElément* {; *process*}{; *} )",
			"Params": [
				[
					"menu",
					"Integer, Text",
					"->",
					"Numéro de menu ou Référence de menu"
				],
				[
					"ligneMenu",
					"Integer",
					"->",
					"Numéro de ligne de menu ou -1 pour la dernière ligne ajoutée"
				],
				[
					"libelléElément",
					"Text",
					"->",
					"Nouveau libellé de la ligne de menu"
				],
				[
					"process",
					"Integer",
					"->",
					"Numéro de référence de process"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : considérer les métacaractères comme des caractères standard"
				]
			],
			"Summary": "La commande **SET MENU ITEM** remplace le libellé de la ligne de menu, dont vous avez passé le numéro ou la référence de menu et le numéro de ligne dans *menu* et *ligneMenu*, par le libellé que vous avez passé dans *texteLigne*."
		},
		"SET PICTURE FILE NAME": {
			"Syntax": "**SET PICTURE FILE NAME** ( *image* ; *nomFichier* )",
			"Params": [
				[
					"image",
					"Picture, Picture",
					"->",
					"Image dont vous souhaitez fixer le nom par défaut"
				],
				[
					"nomFichier",
					"Text",
					"->",
					"Nom par défaut de l’image"
				]
			],
			"Summary": "La commande **SET PICTURE FILE NAME** vous permet de définir ou de modifier le nom de fichier par défaut de l’image passée en paramètre."
		},
		"SET PICTURE METADATA": {
			"Syntax": "**SET PICTURE METADATA** ( *image* ; *nomMeta* ; *contenuMeta* {; *nomMeta2* ; *contenuMeta2* ; ... ; *nomMetaN* ; *contenuMetaN*} )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image dont vous souhaitez écrire les métadonnées"
				],
				[
					"nomMeta",
					"Text",
					"->",
					"Nom ou chemin du bloc à écrire"
				],
				[
					"contenuMeta",
					"Variable",
					"->",
					"Contenu de la métadonnée"
				]
			],
			"Summary": "La commande **SET PICTURE METADATA** permet d’écrire ou de modifier le contenu de métadonnées (ou méta-balises) présentes dans *image* (champ ou une variable image 4D), lorsqu'elles sont modifiables."
		},
		"SET PICTURE TO LIBRARY": {
			"Syntax": "**SET PICTURE TO LIBRARY** ( *image* ; *refImage* ; *nomImage* )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Nouvelle image"
				],
				[
					"refImage",
					"Integer",
					"->",
					"Numéro de référence de l'image dans la bibliothèque d'images"
				],
				[
					"nomImage",
					"Text",
					"->",
					"Nouveau nom de l’image"
				]
			],
			"Summary": "La commande **SET PICTURE TO LIBRARY** crée une nouvelle image ou remplace une image existante dans la bibliothèque d’images."
		},
		"SET PICTURE TO PASTEBOARD": {
			"Syntax": "**SET PICTURE TO PASTEBOARD** ( *image* )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image à placer dans le conteneur de données"
				]
			],
			"Summary": "**SET PICTURE TO PASTEBOARD** place dans le conteneur de données une copie de l'image que vous avez passée dans *image*."
		},
		"SET PLUGIN ACCESS": {
			"Syntax": "**SET PLUGIN ACCESS** ( *plugIn* ; *groupe* )",
			"Params": [
				[
					"plugIn",
					"Integer",
					"->",
					"Numéro du plug-in"
				],
				[
					"groupe",
					"Text",
					"->",
					"Nom du groupe à associer au plug-in"
				]
			],
			"Summary": "La commande **SET PLUGIN ACCESS** permet de spécifier par programmation le groupe d’utilisateurs autorisé à utiliser chaque plug-in “sérialisé” installé dans la base."
		},
		"SET PRINT MARKER": {
			"Syntax": "**SET PRINT MARKER** ( *numTaquet* ; *position* {; *} )",
			"Params": [
				[
					"numTaquet",
					"Integer",
					"->",
					"Numéro de taquet"
				],
				[
					"position",
					"Integer",
					"->",
					"Nouvelle position du taquet"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = déplacer les marqueurs suivants Si omis = ne pas déplacer les marqueurs suivants"
				]
			],
			"Summary": "La commande **SET PRINT MARKER** permet de définir la position d’un taquet au moment de l’impression."
		},
		"SET PRINT OPTION": {
			"Syntax": "**SET PRINT OPTION** ( *option* ; *valeur1* {; *valeur2*} )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Numéro d’option ou Code d'option PDF"
				],
				[
					"valeur1",
					"Integer, Text",
					"->",
					"Valeur 1 de l’option"
				],
				[
					"valeur2",
					"Integer, Text",
					"->",
					"Valeur 2 de l’option"
				]
			],
			"Summary": "La commande **SET PRINT OPTION** permet de modifier par programmation la valeur d’une option d’impression."
		},
		"SET PRINT PREVIEW": {
			"Syntax": "**SET PRINT PREVIEW** ( *aperçu* )",
			"Params": [
				[
					"aperçu",
					"Boolean",
					"->",
					"Impression à l'écran (Vrai) ou non (Faux)"
				]
			],
			"Summary": "La commande **SET PRINT PREVIEW** vous permet de sélectionner ou de désélectionner l'option d'**aperçu** dans la boîte de dialogue standard d'impression."
		},
		"SET PRINTABLE MARGIN": {
			"Syntax": "**SET PRINTABLE MARGIN** ( *gauche* ; *haut* ; *droit* ; *bas* )",
			"Params": [
				[
					"gauche",
					"Integer",
					"->",
					"Marge gauche"
				],
				[
					"haut",
					"Integer",
					"->",
					"Marge supérieure"
				],
				[
					"droit",
					"Integer",
					"->",
					"Marge droite"
				],
				[
					"bas",
					"Integer",
					"->",
					"Marge inférieure"
				]
			],
			"Summary": "La commande **SET PRINTABLE MARGIN** permet de fixer les valeurs des différentes marges d’impression lors de l’utilisation des commandes Print form, PRINT SELECTION et PRINT RECORD."
		},
		"SET PROCESS VARIABLE": {
			"Syntax": "**SET PROCESS VARIABLE** ( *process* ; *varDestination* ; *exprSource* {; *varDestination2* ; *exprSource2* ; ... ; *varDestinationN* ; *exprSourceN*} )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro de process de destination"
				],
				[
					"varDestination",
					"Variable",
					"->",
					"Variable de destination"
				],
				[
					"exprSource",
					"Variable",
					"->",
					"Expression source (ou variable source)"
				]
			],
			"Summary": "La commande **SET PROCESS VARIABLE** écrit la ou les valeur(s) de *exprSource* (*exprSource2*, etc.) dans la ou les variable(s) process *varDestination* (*varDestination2*, etc.) du process de destination dont le numéro est passé dans *process*."
		},
		"SET QUERY AND LOCK": {
			"Syntax": "**SET QUERY AND LOCK** ( *verrou* )",
			"Params": [
				[
					"verrou",
					"Boolean",
					"->",
					"Vrai = verrouiller les enregistrements trouvés par les recherches, Faux = ne pas les verrouiller"
				]
			],
			"Summary": "La commande **SET QUERY AND LOCK** vous permet de demander le verrouillage automatique des enregistrements trouvés par toutes les recherches qui suivent son appel dans la transaction courante."
		},
		"SET QUERY DESTINATION": {
			"Syntax": "**SET QUERY DESTINATION** ( *destinationType* {; *destinationObjet* {; *destinationPtr*}} )",
			"Params": [
				[
					"destinationType",
					"Integer",
					"->",
					"0=sélection courante, 1=ensemble, 2=sélection temporaire, 3=variable"
				],
				[
					"destinationObjet",
					"Text, Variable",
					"->",
					"Nom de l'ensemble ou Nom de la sélection temporaire ou Variable"
				],
				[
					"destinationPtr",
					"Pointer",
					"->",
					"Pointeur vers la variable locale si destinationType=3"
				]
			],
			"Summary": "La commande **SET QUERY DESTINATION** vous permet d'indiquer à 4D où placer les résultats de toutes les recherches qui suivent l'appel de cette commande dans le process courant."
		},
		"SET QUERY LIMIT": {
			"Syntax": "**SET QUERY LIMIT** ( *limite* )",
			"Params": [
				[
					"limite",
					"Integer",
					"->",
					"Nombre limite d'enregistrements ou 0 pour nombre illimité"
				]
			],
			"Summary": "La commande **SET QUERY LIMIT** vous permet d'indiquer à 4D d'arrêter toutes les recherches suivant l'appel de cette commande dans le process courant dès que le nombre d'enregistrements défini dans *limite* a été atteint."
		},
		"SET REAL COMPARISON LEVEL": {
			"Syntax": "**SET REAL COMPARISON LEVEL** ( *epsilon* )",
			"Params": [
				[
					"epsilon",
					"Real",
					"->",
					"Valeur epsilon pour les comparaisons d'égalité des réels"
				]
			],
			"Summary": "La commande **SET REAL COMPARISON LEVEL** définit la valeur *epsilon* utilisée par 4D lors d'une comparaison d'égalité des valeurs et expressions de type Réel."
		},
		"SET RECENT FONTS": {
			"Syntax": "**SET RECENT FONTS** ( *tabPolices* )",
			"Params": [
				[
					"tabPolices",
					"Text array",
					"->",
					"Tableau de noms de polices"
				]
			],
			"Summary": "La commande **SET RECENT FONTS** permet de modifier la liste des polices récentes affichées dans le menu contextuel des \"polices récentes\"."
		},
		"SET TABLE CACHE PRIORITY": {
			"Syntax": "**SET TABLE CACHE PRIORITY** ( *laTable* ; *priorité* )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table dont vous souhaitez modifier la priorité des données scalaires pour toute la session"
				],
				[
					"priorité",
					"Integer",
					"->",
					"Priorité des valeurs scalaires de la table dans le cache"
				]
			],
			"Summary": "Cette commande est réservée pour des besoins spécifiques."
		},
		"SET TABLE TITLES": {
			"Syntax": "**SET TABLE TITLES** {( *titresTables* ; *numTables* {; *})}",
			"Params": [
				[
					"titresTables",
					"Text array",
					"->",
					"Noms des tables tels qu'ils doivent apparaître"
				],
				[
					"numTables",
					"Integer array",
					"->",
					"Numéros des tables"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Utiliser les noms personnalisés dans l’éditeur de formules"
				]
			],
			"Summary": "**SET TABLE TITLES** vous permet de masquer, renommer et réordonner les tables de votre base qui apparaissent dans les éditeurs standard de 4D en mode Application (lorsque le mode de lancement est le mode **Application**, ou après avoir sélectionné \"**Tester l'application**\" dans le menu **Exécution**) ."
		},
		"SET TEXT TO PASTEBOARD": {
			"Syntax": "**SET TEXT TO PASTEBOARD** ( *texte* )",
			"Params": [
				[
					"texte",
					"Text",
					"->",
					"Texte à placer dans le conteneur de données"
				]
			],
			"Summary": "**SET TEXT TO PASTEBOARD** place une copie du texte que vous avez passé dans *texte* dans le conteneur de données."
		},
		"SET TIMEOUT": {
			"Syntax": "**SET TIMEOUT** ( *secondes* )",
			"Params": [
				[
					"secondes",
					"Integer",
					"->",
					"Nombre de secondes jusqu'au timeout"
				]
			],
			"Summary": "La commande **SET TIMEOUT** vous permet de définir le temps d'attente maximum pour l'exécution d'une commande de communication série."
		},
		"SET TIMER": {
			"Syntax": "**SET TIMER** ( *tickCount* )",
			"Params": [
				[
					"tickCount",
					"Integer",
					"->",
					"Nombre de ticks ou -1 = Déclenchement dès que possible"
				]
			],
			"Summary": "La commande **SET TIMER** permet d’activer l’événement formulaire On Timer et de fixer, pour le process et le formulaire courants, le nombre de ticks (1 tick = 1/60ème de seconde) entre chaque événement formulaire On Timer."
		},
		"SET UPDATE FOLDER": {
			"Syntax": "**SET UPDATE FOLDER** ( *cheminDossier* {; *erreursDiscrètes*} )",
			"Params": [
				[
					"cheminDossier",
					"Text",
					"->",
					"Chemin d’accès du dossier (package sous macOS) contenant l’application mise à jour"
				],
				[
					"erreursDiscrètes",
					"Boolean",
					"->",
					"Faux (défaut) = afficher des messages d’erreur, Vrai = ne pas afficher de messages (uniquement enregistrer les erreurs)"
				]
			],
			"Summary": "La commande **SET UPDATE FOLDER** permet de définir le dossier contenant la mise à jour de l’application 4D fusionnée courante."
		},
		"SET USER ALIAS": {
			"Syntax": "**SET USER ALIAS** ( *alias* )",
			"Params": [
				[
					"alias",
					"Text",
					"->",
					"Nom d'utilisateur qui remplace celui du compte utilisateur 4D ou \"\" pour réinitialiser"
				]
			],
			"Summary": "La commande **SET USER ALIAS** définit un nom personnalisé à utiliser à la place de celui du compte utilisateur 4D pour la session courante."
		},
		"Set user properties": {
			"Syntax": "**Set user properties** ( *réfUtilisateur* ; *nom* ; *démarrage* ; *motDePasse* ; *nbUtilisations* ; *dernièreUtilisation* {; *adhésions* {; *groupePropriétaire*}} ) : Integer",
			"Params": [
				[
					"réfUtilisateur",
					"Integer",
					"->",
					"Numéro de référence unique du compte de l'utilisateur ou -1 pour l'ajout d'un utilisateur affilié au Super_Utilisateur ou -2 pour l'ajout d'un utilisateur affilié à l'Administrateur"
				],
				[
					"<-",
					"Unique ID number of added user account (if any)"
				],
				[
					"nom",
					"Text",
					"->",
					"Nouveau nom de l'utilisateur"
				],
				[
					"démarrage",
					"Text",
					"->",
					"Nom de la nouvelle méthode de démarrage"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Nouveau mot de passe (non crypté) ou * pour ne pas modifier le mot de passe"
				],
				[
					"nbUtilisations",
					"Integer",
					"->",
					"Nouveau nombre d'utilisations de la base"
				],
				[
					"dernièreUtilisation",
					"Date",
					"->",
					"Nouvelle date de dernière utilisation de la base"
				],
				[
					"adhésions",
					"Integer array",
					"->",
					"Numéros de référence des groupes auxquels l'utilisateur appartient"
				],
				[
					"groupePropriétaire",
					"Integer",
					"->",
					"Numéro de référence du groupe propriétaire de l’utilisateur"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence unique du nouvel utilisateur"
				]
			],
			"Summary": "**Set user properties** vous permet de modifier et de mettre à jour les propriétés d'un compte actif d'utilisateur existant dont le numéro de référence est passé dans le paramètre *réfUtilisateur*, ou d'ajouter un nouvel utilisateur."
		},
		"SET WINDOW RECT": {
			"Syntax": "**SET WINDOW RECT** ( *gauche* ; *haut* ; *droite* ; *bas* {; *fenêtre*}{; *} )",
			"Params": [
				[
					"gauche",
					"Integer",
					"->",
					"Coordonnée gauche de l'intérieur de la fenêtre"
				],
				[
					"haut",
					"Integer",
					"->",
					"Coordonnée supérieure de l'intérieur de la fenêtre"
				],
				[
					"droite",
					"Integer",
					"->",
					"Coordonnée droite de l'intérieur de la fenêtre"
				],
				[
					"bas",
					"Integer",
					"->",
					"Coordonnée inférieure de l'intérieur de la fenêtre"
				],
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process si ce paramètre est omis"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si omis (défaut) = passer la fenêtre au premier plan<br/>Si passé = ne pas changer le plan de la fenêtre"
				]
			],
			"Summary": "La commande **SET WINDOW RECT** modifie les coordonnées globales de la fenêtre dont vous avez passé le numéro de référence RefFen dans le paramètre *fenêtre*."
		},
		"SET WINDOW TITLE": {
			"Syntax": "**SET WINDOW TITLE** ( *titre* {; *fenêtre*} )",
			"Params": [
				[
					"titre",
					"Text",
					"->",
					"Titre de la fenêtre"
				],
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de fenêtre ou Fenêtre au premier plan du process courant si ce paramètre est omis"
				]
			],
			"Summary": "La commande **SET WINDOW TITLE** remplace le titre de la fenêtre dont le numéro de référence est passé dans *fenêtre* par le texte passé dans *titre* (longueur maximale 80 caractères)."
		},
		"Shift down": {
			"Syntax": "**Shift down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Majuscule"
				]
			],
			"Summary": "**Shift down** retourne Vrai si la touche **Majuscule** est enfoncée."
		},
		"SHOW MENU BAR": {
			"Syntax": "**SHOW MENU BAR**",
			"Params": [],
			"Summary": "La commande **SHOW MENU BAR** rend visible la barre de menus."
		},
		"SHOW ON DISK": {
			"Syntax": "**SHOW ON DISK** ( *cheminAccès* {; *} )",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Chemin d’accès de l’élément à montrer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si l’élément est un dossier, montrer son contenu"
				]
			],
			"Summary": "La commande **SHOW ON DISK** affiche dans une fenêtre standard du système d’exploitation le fichier ou le dossier dont le chemin d’accès est passé dans le paramètre *cheminAccès*."
		},
		"SHOW PROCESS": {
			"Syntax": "**SHOW PROCESS** ( *process* )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro du process dont les fenêtres doivent être affichées"
				]
			],
			"Summary": "**SHOW PROCESS** fait apparaître l'ensemble des fenêtres appartenant à *process*."
		},
		"SHOW TOOL BAR": {
			"Syntax": "**SHOW TOOL BAR**",
			"Params": [],
			"Summary": "La commande **SHOW TOOL BAR** permet de gérer l'affichage des barres d'outils personnalisées créées par la commande Open form window pour le process courant."
		},
		"SHOW WINDOW": {
			"Syntax": "**SHOW WINDOW** {( *fenêtre* )}",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process courant si omis"
				]
			],
			"Summary": "La commande **SHOW WINDOW** permet d'afficher la fenêtre dont vous avez passé le numéro de référence dans *fenêtre* ou, si ce paramètre est omis, la fenêtre de premier plan du process courant."
		},
		"Sin": {
			"Syntax": "**Sin** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre, exprimé en radians, dont vous voulez connaître le sinus"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Sinus de nombre"
				]
			],
			"Summary": "**Sin** retourne le sinus de *nombre*."
		},
		"Size of array": {
			"Syntax": "**Size of array** ( *tableau* ) : Integer",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau dont vous désirez connaître la taille"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre d'éléments dans le tableau"
				]
			],
			"Summary": "**Size of array** retourne le nombre d'éléments de *tableau*."
		},
		"SOAP DECLARATION": {
			"Syntax": "**SOAP DECLARATION** ( *variable* ; *type* ; entrée_sortie {; *alias*} )",
			"Params": [
				[
					"variable",
					"Variable",
					"->",
					"Variable référençant un argument SOAP entrant ou sortant"
				],
				[
					"type",
					"Integer",
					"->",
					"Type 4D vers lequel pointe l’argument"
				],
				[
					"entrée_sortie",
					"Integer",
					"->",
					"1 = Entrée SOAP, 2 = Sortie SOAP"
				],
				[
					"alias",
					"Text",
					"->",
					"Nom publié pour cet argument lors des échanges SOAP"
				]
			],
			"Summary": "La commande **SOAP DECLARATION** permet de déclarer explicitement le type des paramètres utilisés dans une méthode 4D publiée comme Web Service."
		},
		"SOAP Get info": {
			"Syntax": "**SOAP Get info** ( *numInfo* ) : Text",
			"Params": [
				[
					"numInfo",
					"Integer",
					"->",
					"Numéro du type d’information SOAP à lire"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Information SOAP"
				]
			],
			"Summary": "La commande **SOAP Get info** permet de récupérer sous forme de chaîne de caractères différents types d’informations concernant une requête SOAP."
		},
		"SOAP REJECT NEW REQUESTS": {
			"Syntax": "**SOAP REJECT NEW REQUESTS** ( *statutRejet* )",
			"Params": [
				[
					"statutRejet",
					"Boolean",
					"->",
					"Vrai si rejet de nouvelles requêtes, sinon Faux"
				]
			],
			"Summary": "La commande **SOAP REJECT NEW REQUESTS** permet d'indiquer si le serveur Web Services accepte ou non de nouvelles requêtes SOAP."
		},
		"SOAP Request": {
			"Syntax": "**SOAP Request**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si la requête est SOAP, Faux sinon"
				]
			],
			"Summary": "La commande **SOAP Request** retourne Vrai si le code en cours d’exécution fait partie d’une requête SOAP."
		},
		"SOAP SEND FAULT": {
			"Syntax": "**SOAP SEND FAULT** ( *typeErreur* ; *description* )",
			"Params": [
				[
					"typeErreur",
					"Integer",
					"->",
					"1 = Erreur Client, 2 = Erreur Serveur"
				],
				[
					"description",
					"Text",
					"->",
					"Description de l’erreur à envoyer au client SOAP"
				]
			],
			"Summary": "La commande **SOAP SEND FAULT** permet de retourner une erreur à un client SOAP en indiquant l’origine de l’erreur : client ou serveur."
		},
		"SORT ARRAY": {
			"Syntax": "**SORT ARRAY** ( *tableau* {; *tableau2* ; ... ; *tableauN*}{; > ou <} )",
			"Params": [
				[
					"tableau",
					"Array",
					"->",
					"Tableau(x) à trier"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"\">\" pour effectuer un tri par ordre croissant ou \"<\" pour effectuer un tri par ordre décroissant (tri croissant si omis)"
				]
			],
			"Summary": "La commande **SORT ARRAY** trie un ou plusieurs tableau(x) par ordre croissant ou décroissant."
		},
		"SORT LIST": {
			"Syntax": "**SORT LIST** ( *liste* {; > ou <} )",
			"Params": [
				[
					"liste",
					"Integer",
					"->",
					"Numéro de référence de liste"
				],
				[
					"> ou <",
					"Opérateur",
					"->",
					"Ordre de tri : > pour trier la liste dans l'ordre croissant ou < pour trier la liste dans l'ordre décroissant"
				]
			],
			"Summary": "La commande **SORT LIST** effectue un tri sur la liste dont vous avez passé le numéro de référence dans le paramètre *liste*."
		},
		"SPELL ADD TO USER DICTIONARY": {
			"Syntax": "**SPELL ADD TO USER DICTIONARY** ( *mots* )",
			"Params": [
				[
					"mots",
					"Text, Text array",
					"->",
					"Mot ou liste de mots à ajouter au dictionnaire utilisateur"
				]
			],
			"Summary": "La commande **SPELL ADD TO USER DICTIONARY** permet d’ajouter un ou plusieurs mot(s) au dictionnaire utilisateur courant."
		},
		"SPELL CHECK TEXT": {
			"Syntax": "**SPELL CHECK TEXT** ( *leTexte* ; *posErr* ; *longErr* ; *posVérif* ; *tabSuggest* )",
			"Params": [
				[
					"leText",
					"Text",
					"->",
					"Texte à vérifier"
				],
				[
					"posErr",
					"Integer",
					"<-",
					"Position du premier caractère du mot inconnu"
				],
				[
					"longErr",
					"Integer",
					"<-",
					"Longueur du mot inconnu"
				],
				[
					"posVérif",
					"Integer",
					"->",
					"Position de départ de la vérification"
				],
				[
					"tabSuggest",
					"Text array",
					"<-",
					"Liste des suggestions"
				]
			],
			"Summary": "La commande **SPELL CHECK TEXT** vérifie le contenu du paramètre *leTexte* à partir du caractère *posVérif* et retourne la position du premier mot inconnu rencontré (le cas échéant)."
		},
		"SPELL CHECKING": {
			"Syntax": "**SPELL CHECKING**",
			"Params": [],
			"Summary": "La commande **SPELL CHECKING** déclenche la vérification de l’orthographe du champ ou de la variable ayant le focus dans le formulaire affiché à l’écran."
		},
		"SPELL Get current dictionary": {
			"Syntax": "**SPELL Get current dictionary**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"ID du dictionnaire utilisé pour la correction orthographique"
				]
			],
			"Summary": "La commande **SPELL Get current dictionary** retourne le numéro d’ID du dictionnaire en cours d’utilisation."
		},
		"SPELL GET DICTIONARY LIST": {
			"Syntax": "**SPELL GET DICTIONARY LIST** ( *langID* ; *langFichiers* ; *langNoms* )",
			"Params": [
				[
					"langID",
					"Integer array",
					"<-",
					"ID uniques des langues"
				],
				[
					"langFichiers",
					"Text array",
					"<-",
					"Noms des fichiers de langue installés"
				],
				[
					"langNoms",
					"Text array",
					"<-",
					"Noms locaux des langues"
				]
			],
			"Summary": "La commande **SPELL GET DICTIONARY LIST** retourne dans les tableaux *langID*, *langFichiers* et *langNoms* les IDs, les noms de fichiers et les noms des langues correspondant aux fichiers de dictionnaires Hunspell installés sur la machine."
		},
		"SPELL SET CURRENT DICTIONARY": {
			"Syntax": "**SPELL SET CURRENT DICTIONARY** ( *dictionnaire* )",
			"Params": [
				[
					"dictionnaire",
					"Integer, Text",
					"->",
					"ID, Nom ou Code de langue du dictionnaire à utiliser pour la correction orthographique"
				]
			],
			"Summary": "La commande **SPELL SET CURRENT DICTIONARY** provoque le remplacement du dictionnaire courant par celui spécifié par le paramètre *dictionnaire*."
		},
		"Split string": {
			"Syntax": "**Split string** ( *chaîneASéparer* ; *séparateur* {; *options*} ) : Collection",
			"Params": [
				[
					"chaîneASéparer",
					"Text",
					"->",
					"Chaîne d'origine à découper"
				],
				[
					"séparateur",
					"Text",
					"->",
					"Chaîne à laquelle chaîneASéparer doit être découpée. Si chaîne vide (\"\"), chaque caractère de chaîneASéparer sera un élément de la collection"
				],
				[
					"options",
					"Integer",
					"->",
					"Option(s) relative(s) aux chaînes vides et espaces"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de sous-chaînes"
				]
			],
			"Summary": "La commande **Split string** retourne une collection de chaînes, créée à partir du découpage de *chaîneASéparer* en sous-chaînes aux limites définies par le paramètre *séparateur*."
		},
		"SQL CANCEL LOAD": {
			"Syntax": "**SQL CANCEL LOAD**",
			"Params": [],
			"Summary": "La commande **SQL CANCEL LOAD** met fin à la requête SELECT courante et initialise les paramètres du curseur."
		},
		"SQL End selection": {
			"Syntax": "**SQL End selection**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Limites de l’ensemble de recherche atteintes"
				]
			],
			"Summary": "La commande **SQL End selection** indique si les limites de l’ensemble résultat ont été atteintes."
		},
		"SQL EXECUTE SCRIPT": {
			"Syntax": "**SQL EXECUTE SCRIPT** ( *cheminScript* ; *actionErreur* {; *nomAttribut* ; *valAttribut*} {; *nomAttribut2* ; *valAttribut2* ; ... ; *nomAttributN* ; *valAttributN*} )",
			"Params": [
				[
					"cheminScript",
					"Text",
					"->",
					"Chemin d'accès complet du fichier contenant le script SQL à exécuter"
				],
				[
					"actionErreur",
					"Integer",
					"->",
					"Action à effectuer en cas d’erreur durant l’exécution du script"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Nom d’attribut à utiliser"
				],
				[
					"valAttribut",
					"Text",
					"->",
					"Valeur de l’attribut"
				]
			],
			"Summary": "La commande **SQL EXECUTE SCRIPT** vous permet d’exécuter une suite d’instructions SQL placées dans le fichier de script désigné par *cheminScript*."
		},
		"SQL EXECUTE": {
			"Syntax": "**SQL EXECUTE** ( *instructionSQL* {; *objetLié*}{; *objetLié2* ; ... ; *objetLiéN*} )",
			"Params": [
				[
					"instructionSQL",
					"Text",
					"->",
					"Commande SQL à exécuter"
				],
				[
					"objetLié",
					"Variable, Field",
					"<-",
					"Réception du résultat (si nécessaire)"
				]
			],
			"Summary": "La commande **SQL EXECUTE** permet d’exécuter une commande SQL et d’associer le résultat à des objets 4D (tableaux, variables ou champs) liés."
		},
		"SQL EXPORT DATABASE": {
			"Syntax": "**SQL EXPORT DATABASE** ( *cheminDossier* {; *nbFichiers* {; *tailleLimiteFichiers* {; *tailleLimiteChamps*}}} )",
			"Params": [
				[
					"cheminDossier",
					"Text",
					"->",
					"Chemin d'accès du dossier d'export ou \"\" pour afficher une boîte de dialogue de sélection de dossier"
				],
				[
					"nbFichiers",
					"Integer",
					"->",
					"Nombre maximum de fichiers par dossier"
				],
				[
					"tailleLimiteFichiers",
					"Integer",
					"->",
					"Valeur de limite de taille des fichiers d'exportation (en Ko)"
				],
				[
					"tailleLimiteChamps",
					"Integer",
					"->",
					"Limite de taille au-dessous de laquelle le contenu d'un champ Texte, BLOB ou Image sera intégré au fichier principal (en octets)"
				]
			],
			"Summary": "La commande **SQL EXPORT DATABASE** exporte au format SQL tous les enregistrements de toutes les tables de la base."
		},
		"SQL EXPORT SELECTION": {
			"Syntax": "**SQL EXPORT SELECTION** ( *laTable* ; *cheminDossier* {; *nbFichiers* {; *tailleLimiteFichiers* {; *tailleLimiteChamps*}}} )",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle exporter la sélection"
				],
				[
					"cheminDossier",
					"Text",
					"->",
					"Chemin d'accès du dossier d'export ou \"\" pour afficher une boîte de dialogue de sélection de dossier"
				],
				[
					"nbFichiers",
					"Integer",
					"->",
					"Nombre maximum de fichiers par dossier"
				],
				[
					"tailleLimiteFichiers",
					"Integer",
					"->",
					"Valeur de limite de taille des fichiers d’export (en Ko)"
				],
				[
					"tailleLimiteChamps",
					"Integer",
					"->",
					"Limite de taille au-dessous de laquelle le contenu d'un champ Texte, BLOB ou Image sera intégré au fichier principal (en octets)"
				]
			],
			"Summary": "La commande **SQL EXPORT SELECTION** exporte au format SQL les enregistrements de la sélection courante de la table 4D désignée par le paramètre *laTable*."
		},
		"SQL Get current data source": {
			"Syntax": "**SQL Get current data source**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la source de données en cours d’utilisation"
				]
			],
			"Summary": "La commande **SQL Get current data source** retourne le nom de la source de données courante de l’application."
		},
		"SQL GET DATA SOURCE LIST": {
			"Syntax": "**SQL GET DATA SOURCE LIST** ( *typeSource* ; *tabNomsSources* ; *tabPilotes* )",
			"Params": [
				[
					"typeSource",
					"Integer",
					"->",
					"Type de source : utilisateur ou système"
				],
				[
					"tabNomsSources",
					"Text array",
					"<-",
					"Tableau des noms de sources de données"
				],
				[
					"tabPilotes",
					"Text array",
					"<-",
					"Tableau des pilotes des sources"
				]
			],
			"Summary": "La commande **SQL GET DATA SOURCE LIST** retourne dans les tableaux *tabNomsSources* et *tabPilotes* les noms et les pilotes des sources de données de type *typeSource* définies dans le gestionnaire ODBC du système d’exploitation."
		},
		"SQL GET LAST ERROR": {
			"Syntax": "**SQL GET LAST ERROR** ( *errCode* ; *errTexte* ; *errODBC* ; *errSQLServer* )",
			"Params": [
				[
					"errCode",
					"Integer",
					"<-",
					"Code de l’erreur"
				],
				[
					"errText",
					"Text",
					"<-",
					"Texte de l’erreur"
				],
				[
					"errODBC",
					"Text",
					"<-",
					"Code d’erreur ODBC"
				],
				[
					"errSQLServer",
					"Integer",
					"<-",
					"Code d’erreur native serveur SQL"
				]
			],
			"Summary": "La commande **SQL GET LAST ERROR** retourne des informations relatives à la dernière erreur rencontrée lors de l’exécution d’une commande ODBC."
		},
		"SQL GET OPTION": {
			"Syntax": "**SQL GET OPTION** ( *option* ; *valeur* )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Numéro d’option"
				],
				[
					"valeur",
					"Integer, Text",
					"<-",
					"Valeur de l’option"
				]
			],
			"Summary": "La commande **SQL GET OPTION** retourne la *valeur* courante de l’option passée dans le paramètre *option*."
		},
		"SQL LOAD RECORD": {
			"Syntax": "**SQL LOAD RECORD** {( *nombreEnr* )}",
			"Params": [
				[
					"nombreEnr",
					"Integer",
					"->",
					"Nombre d’enregistrements à charger"
				]
			],
			"Summary": "La commande **SQL LOAD RECORD** récupère dans 4D un ou plusieurs enregistrement(s) provenant de la source de données ouverte dans la connexion courante."
		},
		"SQL LOGIN": {
			"Syntax": "**SQL LOGIN** {( *source* ; *nomUtilisateur* ; *motDePasse* ; * )}",
			"Params": [
				[
					"source",
					"Text",
					"->",
					"Nom de publication de base 4D ouAdresse IP de base distante ouNom de source de données dans le gestionnaire ODBC ou\"\" pour afficher le dialogue de sélection"
				],
				[
					"nomUtilisateur",
					"Text",
					"->",
					"Nom d’utilisateur enregistré dans la source de données"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe de l’utilisateur"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Appliquer à Debut SQL/Fin SQL Si omis : ne pas appliquer (base locale), si passé : appliquer"
				]
			],
			"Summary": "La commande **SQL LOGIN** vous permet d’ouvrir une connexion avec une source de données SQL, définie dans le paramètre *source*."
		},
		"SQL LOGOUT": {
			"Syntax": "**SQL LOGOUT**",
			"Params": [],
			"Summary": "La commande **SQL LOGOUT** referme la connexion avec une source ODBC ouverte dans le process courant (le cas échéant)."
		},
		"SQL SET OPTION": {
			"Syntax": "**SQL SET OPTION** ( *option* ; *valeur* )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Numéro d’option à définir"
				],
				[
					"valeur",
					"Integer, Text",
					"->",
					"Nouvelle valeur de l’option"
				]
			],
			"Summary": "La commande **SQL SET OPTION** permet de modifier la *valeur* de l’option passée dans le paramètre *option*."
		},
		"SQL SET PARAMETER": {
			"Syntax": "**SQL SET PARAMETER** ( *objet* ; *typeParam* )",
			"Params": [
				[
					"objet",
					"Object",
					"->",
					"Objet 4D à utiliser (variable, tableau ou champ)"
				],
				[
					"typeParam",
					"Integer",
					"->",
					"Type du paramètre"
				]
			],
			"Summary": "La commande **SQL SET PARAMETER** permet d’utiliser la valeur d’une variable, d’un tableau ou d’un champ 4D dans les requêtes SQL."
		},
		"Square root": {
			"Syntax": "**Square root** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre duquel calculer la racine carrée"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Racine carrée de nombre"
				]
			],
			"Summary": "**Square root** retourne la racine carrée de *nombre*."
		},
		"ST COMPUTE EXPRESSIONS": {
			"Syntax": "**ST COMPUTE EXPRESSIONS** ( {* ;} *objet* {; *débutSél* {; *finSél*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				]
			],
			"Summary": "La commande **ST COMPUTE EXPRESSIONS** met à jour les expressions 4D dynamiques situées dans le champ ou la variable de texte multistyle ou de 4D Write Pro désigné(e) par le paramètre *objet*."
		},
		"ST FREEZE EXPRESSIONS": {
			"Syntax": "**ST FREEZE EXPRESSIONS** ( {* ;} *objet* {; *débutSél* {; *finSél*}}{; *} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = mettre à jour les expressions avant de les figer"
				]
			],
			"Summary": "La commande **ST FREEZE EXPRESSIONS** \"gèle\" le contenu des expressions situées dans le champ ou la variable texte multistyle ou 4D Write Pro désigné(e) par le paramètre *objet*."
		},
		"ST GET ATTRIBUTES": {
			"Syntax": "**ST GET ATTRIBUTES** ( {* ;} *objet* ; *débutSél* ; *finSél* ; *nomAttribut* ; *valeurAttribut* {; *nomAttribut2* ; *valeurAttribut2* ; ... ; *nomAttributN* ; *valeurAttributN*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection de texte"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection de texte"
				],
				[
					"nomAttribut",
					"Integer",
					"->",
					"Attribut à lire"
				],
				[
					"valeurAttribut",
					"Variable",
					"<-",
					"Valeur courante de l’attribut"
				]
			],
			"Summary": "La commande **ST GET ATTRIBUTES** permet de récupérer la valeur courante d’un attribut de style dans une sélection de texte du ou des objet(s) de formulaire désigné(s) par *objet*."
		},
		"ST Get content type": {
			"Syntax": "**ST Get content type** ( {* ;} *objet* {; *débutSél* {; *finSél* {; *débutBloc* {; *finBloc*}}}} ) : Integer",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				],
				[
					"débutBloc",
					"Integer",
					"<-",
					"Début de position du premier type de la sélection"
				],
				[
					"finBloc",
					"Integer",
					"<-",
					"Fin de position du premier type de la sélection"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type de contenu"
				]
			],
			"Summary": "La commande **ST Get content type** retourne le type de contenu présent dans le champ ou la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"ST Get expression": {
			"Syntax": "**ST Get expression** ( {* ;} *objet* {; *débutSél* {; *finSél*}} )  : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Libellé de l’expression"
				]
			],
			"Summary": "La commande **ST Get expression** retourne la première expression présente dans la sélection courante du champ ou de la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"ST GET OPTIONS": {
			"Syntax": "**ST GET OPTIONS** ( {* ;} *objet* ; *option* ; *valeur* {; *option2* ; *valeur2* ; ... ; *optionN* ; *valeurN*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"option",
					"Integer",
					"->",
					"Option à lire"
				],
				[
					"valeur",
					"Integer",
					"<-",
					"Valeur courante de l’option"
				]
			],
			"Summary": "La commande **ST GET OPTIONS** permet d’obtenir la valeur courante d’une ou plusieurs options de fonctionnement du champ ou de la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"ST Get plain text": {
			"Syntax": "**ST Get plain text** ( {* ;} *objet* {; *modeRéf*} ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"modeRéf",
					"Integer",
					"->",
					"Mode de prise en charge des références présentes dans le texte"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte sans balises"
				]
			],
			"Summary": "La commande **ST Get plain text** supprime toute balise de style du champ ou de la variable texte désigné(e) par les paramètres *\\** et *objet*, et retourne le texte brut."
		},
		"ST Get text": {
			"Syntax": "**ST Get text** ( {* ;} *objet* {; *débutSél* {; *finSél*}} )  : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ Texte (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte incluant les balises de style"
				]
			],
			"Summary": "La commande **ST Get text** retourne le texte multistyle présent dans le champ ou la variable de texte désigné(e) par le paramètre *objet*."
		},
		"ST GET URL": {
			"Syntax": "**ST GET URL** ( {* ;} *objet* ; *texteURL* ; *adresseURL* {; *débutSél* {; *finSél*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"texteURL",
					"Text",
					"<-",
					"Libellé visible de l’URL"
				],
				[
					"adresseURL",
					"Text",
					"<-",
					"Adresse de l’URL"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				]
			],
			"Summary": "La commande **ST GET URL** retourne le libellé et l’adresse du premier URL détecté dans le champ ou la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"ST INSERT EXPRESSION": {
			"Syntax": "**ST INSERT EXPRESSION** ( {* ;} *objet* ; *expression* {; *débutSél* {; *finSél*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"Object",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"expression",
					"Text",
					"->",
					"Expression et (optionnel) format à insérer"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				]
			],
			"Summary": "La commande **ST INSERT EXPRESSION** insère une référence à l’*expression* dans le champ ou la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"ST INSERT URL": {
			"Syntax": "**ST INSERT URL** ( {* ;} *objet* ; *texteURL* ; *adresseURL* {; *débutSél* {; *finSél*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"texteURL",
					"Text",
					"->",
					"Libellé visible de l’URL"
				],
				[
					"adresseURL",
					"Text",
					"->",
					"Adresse de l’URL"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				]
			],
			"Summary": "La commande **ST INSERT URL** insère un lien URL dans le champ ou la variable de texte stylé désigné(e) par le paramètre *objet*."
		},
		"ST SET ATTRIBUTES": {
			"Syntax": "**ST SET ATTRIBUTES** ( {* ;} *objet* ; *débutSél* ; *finSél* ; *nomAttribut* ; *valeurAttribut* {; *nomAttribut2* ; *valeurAttribut2* ; ... ; *nomAttributN* ; *valeurAttributN*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ Texte (si * est omis)"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la nouvelle sélection de texte"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la nouvelle sélection de texte"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Attribut à définir"
				],
				[
					"valeurAttribut",
					"Text, Integer",
					"->",
					"Nouvelle valeur d’attribut"
				]
			],
			"Summary": "La commande **ST SET ATTRIBUTES** permet de modifier un ou plusieurs attribut(s) de style dans le ou les objet(s) de formulaire désigné(s) par *objet*."
		},
		"ST SET OPTIONS": {
			"Syntax": "**ST SET OPTIONS** ( {* ;} *objet* ; *option* ; *valeur* {; *option2* ; *valeur2* ; ... ; *optionN* ; *valeurN*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne)<br/>Si omis, objet est un champ ou une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Champ ou variable (si * est omis)"
				],
				[
					"option",
					"Integer",
					"->",
					"Option à définir"
				],
				[
					"valeur",
					"Integer",
					"->",
					"Nouvelle valeur de l’option"
				]
			],
			"Summary": "La commande **ST SET OPTIONS** vous permet de modifier une ou plusieurs options de fonctionnement du champ ou de la variable de texte stylé désigné(e) par le paramètre *objet*."
		},
		"ST SET PLAIN TEXT": {
			"Syntax": "**ST SET PLAIN TEXT** ( {* ;} *objet* ; *nouvTexte* {; *débutSél* {; *finSél*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ (si * est omis)"
				],
				[
					"nouvText",
					"Text",
					"->",
					"Texte brut à insérer"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				]
			],
			"Summary": "La commande **ST SET PLAIN TEXT** insère le texte passé dans le paramètre *nouvTexte* dans le champ ou la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"ST SET TEXT": {
			"Syntax": "**ST SET TEXT** ( {* ;} *objet* ; *nouvTexte* {; *débutSél* {; *finSél*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) <br/>Si omis, objet est une variable ou un champ"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou <br/>Variable ou champ Texte (si * est omis)"
				],
				[
					"nouvText",
					"Text",
					"->",
					"Texte multistyle à insérer"
				],
				[
					"débutSél",
					"Integer",
					"->",
					"Début de la sélection"
				],
				[
					"finSél",
					"Integer",
					"->",
					"Fin de la sélection"
				]
			],
			"Summary": "La commande **ST SET TEXT** insère le texte passé dans le paramètre *nouvTexte* dans le champ ou la variable de texte multistyle désigné(e) par le paramètre *objet*."
		},
		"START MONITORING ACTIVITY": {
			"Syntax": "**START MONITORING ACTIVITY** ( *duree* {; *source*} )",
			"Params": [
				[
					"duree",
					"Real",
					"->",
					"Durée (en secondes) avant l'ouverture d'une session"
				],
				[
					"source",
					"Integer",
					"->",
					"Origine d'une opération"
				]
			],
			"Summary": "La commande **START MONITORING ACTIVITY** enregistre les opérations qui dépassent une certaine *durée* dans la mémoire."
		},
		"START SQL SERVER": {
			"Syntax": "**START SQL SERVER**",
			"Params": [],
			"Summary": "La commande **START SQL SERVER** démarre le serveur SQL intégré de l’application 4D sur laquelle elle a été exécutée."
		},
		"START TRANSACTION": {
			"Syntax": "**START TRANSACTION**",
			"Params": [],
			"Summary": "**START TRANSACTION** débute une transaction dans le process courant."
		},
		"Std deviation": {
			"Syntax": "**Std deviation** ( *séries* ) : Real",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs dont vous voulez obtenir l'écart type"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Ecart type de séries"
				]
			],
			"Summary": "**Std deviation** retourne l'écart type (c.-à-d. la racine carrée de la variance) de *séries*."
		},
		"STOP MONITORING ACTIVITY": {
			"Syntax": "**STOP MONITORING ACTIVITY**",
			"Params": [],
			"Summary": "La commande **STOP MONITORING ACTIVITY** arrête le suivi des activités lancées avec la commande START MONITORING ACTIVITY."
		},
		"STOP SQL SERVER": {
			"Syntax": "**STOP SQL SERVER**",
			"Params": [],
			"Summary": "La commande **STOP SQL SERVER** stoppe le serveur SQL intégré de l’application 4D sur laquelle elle a été exécutée."
		},
		"Storage": {
			"Syntax": "**Storage**  : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Catalogue des objets et collections partagé(e)s enregistré(e)s dans Storage"
				]
			],
			"Summary": "La commande **Storage** retourne le catalogue des objets partagés et des collections partagées qui ont été enregistré(e)s dans l'objet *Storage* sur la machine ou le composant courant(e)."
		},
		"STRING LIST TO ARRAY": {
			"Syntax": "**STRING LIST TO ARRAY** ( *resNum* ; *tabChaînes* {; *resFichier*} )",
			"Params": [
				[
					"resNum",
					"Integer",
					"->",
					"Numéro de ressource ou Attribut 'id' de l'élément 'group' (XLIFF)"
				],
				[
					"tabChaînes",
					"Text array",
					"<-",
					"Chaînes de la ressource STR# ou Chaînes de l'élément 'group' (XLIFF)"
				],
				[
					"resFichier",
					"Time",
					"->",
					"Numéro de référence de fichier de ressources Si omis : tous les fichiers XLIFF ou les fichiers de ressources ouverts"
				]
			],
			"Summary": "La commande **STRING LIST TO ARRAY** remplit le tableau *chaînes*"
		},
		"Structure file": {
			"Syntax": "**Structure file** {( * )} : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Retourner le fichier de structure de la base hôte"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom long du fichier de structure de la base"
				]
			],
			"Summary": "La fonction **Structure file** retourne le chemin d'accès du fichier de structure de la base en cours d'utilisation."
		},
		"Substring": {
			"Syntax": "**Substring** ( *source* ; àPartirDe {; *nbCars*} ) : Text",
			"Params": [
				[
					"source",
					"Text",
					"->",
					"Chaîne de laquelle extraire une sous-chaîne"
				],
				[
					"àPartirDe",
					"Integer",
					"->",
					"Position du premier caractère"
				],
				[
					"nbCars",
					"Integer",
					"->",
					"Nombre de caractères à extraire"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Sous-chaîne de source"
				]
			],
			"Summary": "La fonction **Substring** retourne la partie de *source* délimitée par les paramètres *àPartirDe* et *nbCars*."
		},
		"Subtotal": {
			"Syntax": "**Subtotal** ( *valeurs* {; *sautPage*} ) : Real",
			"Params": [
				[
					"valeurs",
					"Field",
					"->",
					"Champ ou variable numérique dont vous voulez calculer le sous-total"
				],
				[
					"sautPage",
					"Integer",
					"->",
					"Niveau de rupture auquel effectuer un saut de page"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Sous-total de valeurs"
				]
			],
			"Summary": "**Subtotal** retourne le sous-total de *valeurs* pour le niveau de rupture courant ou précédent."
		},
		"Sum squares": {
			"Syntax": "**Sum squares** ( *séries* ) : Real",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs dont vous voulez obtenir la somme des carrés"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Somme des carrés de séries"
				]
			],
			"Summary": "**Sum squares** retourne la somme des carrés de *séries*."
		},
		"Sum": {
			"Syntax": "**Sum** ( *séries* {; *cheminAttribut*} ) : Real",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs dont vous souhaitez calculer la somme"
				],
				[
					"cheminAttribut",
					"Text",
					"->",
					"Chemin d'attribut duquel calculer la somme"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Somme de séries"
				]
			],
			"Summary": "**Sum** retourne la somme (c'est-à-dire le total de toutes les valeurs) de *séries*."
		},
		"SUSPEND TRANSACTION": {
			"Syntax": "**SUSPEND TRANSACTION**",
			"Params": [],
			"Summary": "La commande **SUSPEND TRANSACTION** suspend les mécanismes de la transaction courante dans le process courant."
		},
		"SVG EXPORT TO PICTURE": {
			"Syntax": "**SVG EXPORT TO PICTURE** ( *refElément* ; *vVarImage* {; *typeExport*} )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML racine"
				],
				[
					"vVarPicture",
					"Picture",
					"->",
					"Variable image devant recevoir l’arbre XML (image SVG)"
				],
				[
					"typeExport",
					"Integer",
					"->",
					"0=Ne pas stocker la source de données, 1=Copier la source de données  (par défaut), 2 = Prendre possession de la source de données"
				]
			],
			"Summary": "La commande **SVG EXPORT TO PICTURE** permet de sauvegarder dans la variable ou le champ image désigné(e) par le paramètre *vVarImage* une image au format SVG contenue dans un arbre XML."
		},
		"SVG Find element ID by coordinates": {
			"Syntax": "**SVG Find element ID by coordinates** ( {* ;} *objetImage* ; *x* ; *y* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objetImage est un nom d’objet (chaîne) Si omis, objetImage est un champ ou une variable"
				],
				[
					"objetPicture",
					"Picture",
					"->",
					"Nom d’objet (si * spécifié) ou Champ ou Variable (si * omis)"
				],
				[
					"x",
					"Integer",
					"->",
					"Coordonnée X en pixels"
				],
				[
					"y",
					"Integer",
					"->",
					"Coordonnée Y en pixels"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"ID de l’élément se trouvant à l’emplacement x,y"
				]
			],
			"Summary": "La commande **SVG Find element ID by coordinates** retourne l’ID (attribut \"id\" ou \"xml:id\") de l’élément XML situé à l’emplacement défini par les coordonnées (*x*,*y*) dans l’image SVG désignée par le paramètre *objetImage*."
		},
		"SVG Find element IDs by rect": {
			"Syntax": "**SVG Find element IDs by rect** ( {* ;} *objetImage* ; *x* ; *y* ; *largeur* ; *hauteur* ; *tabIds* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objetImage est un nom d'objet (chaîne) <br/>Si omis, objetImage est un champ ou une variable"
				],
				[
					"objetPicture",
					"Picture",
					"->",
					"Nom d’objet (si * spécifié) ou Champ ou Variable (si * omis)"
				],
				[
					"x",
					"Integer",
					"->",
					"Coordonnée horizontale du coin haut gauche du rectangle de sélection"
				],
				[
					"y",
					"Integer",
					"->",
					"Coordonnée verticale du coin haut gauche du rectangle de sélection"
				],
				[
					"largeur",
					"Integer",
					"->",
					"Largeur du rectangle de sélection"
				],
				[
					"hauteur",
					"Integer",
					"->",
					"Hauteur du rectangle de sélection"
				],
				[
					"tabIds",
					"Text array",
					"<-",
					"IDs des éléments dont le rectangle englobant est en intersection avec le rectangle de sélection"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = au moins un élément est trouvé, Faux sinon"
				]
			],
			"Summary": "La commande **SVG Find element IDs by rect** remplit le tableau texte *tabIds* avec les IDs (attribut \"id\" ou \"xml:id\") des éléments XML dont le rectangle englobant est en intersection avec le rectangle de sélection à l’emplacement défini par les paramètres *x* et *y*."
		},
		"SVG GET ATTRIBUTE": {
			"Syntax": "**SVG GET ATTRIBUTE** ( {* ;} *objetImage* ; id_Element ; *nomAttribut* ; *valeurAttribut* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objetImage est un nom d'objet (chaîne) <br/>Si omis, objetImage est une variable ou un champ"
				],
				[
					"objetPicture",
					"Picture",
					"->",
					"Nom d’objet (si * spécifié) ou Variable ou champ (si * omis)"
				],
				[
					"id_Element",
					"Text",
					"->",
					"ID de l'élément dont vous souhaitez connaître une valeur d'attribut"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Nom d’attribut"
				],
				[
					"valeurAttribut",
					"Text, Integer",
					"<-",
					"Valeur courante de l'attribut"
				]
			],
			"Summary": "La commande **SVG GET ATTRIBUTE** permet de lire la valeur courante de l’attribut *nomAttribut* dans un objet ou une image SVG."
		},
		"SVG SET ATTRIBUTE": {
			"Syntax": "**SVG SET ATTRIBUTE** ( {* ;} *objetImage* ; id_Element ; *nomAttribut* ; *valeurAttribut* {; *nomAttribut2* ; *valeurAttribut2* ; ... ; *nomAttributN* ; *valeurAttributN*} {; *})",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objetImage est un nom d'objet (chaîne) <br/>Si omis, objetImage est une variable ou un champ"
				],
				[
					"objetPicture",
					"Picture",
					"->",
					"Nom d’objet (si * spécifié) ou Variable ou champ (si * omis)"
				],
				[
					"id_Element",
					"Text",
					"->",
					"ID de l'élément dont un ou plusieurs attribut(s) sont à définir"
				],
				[
					"nomAttribut",
					"Text",
					"->",
					"Attribut à définir"
				],
				[
					"valeurAttribut",
					"Text, Integer",
					"->",
					"Nouvelle valeur d’attribut"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = modifier l'arbre DOM interne de l'image SVG (variable uniquement)"
				]
			],
			"Summary": "La commande **SVG SET ATTRIBUTE** permet de modifier la valeur d’un attribut existant dans l’arbre de rendu SVG d’une image affichée ou dans l'arbre DOM interne d'une image."
		},
		"SVG SHOW ELEMENT": {
			"Syntax": "**SVG SHOW ELEMENT** ( {* ;} *objetImage* ; *id* {; *marge*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objetImage est un nom d'objet (chaîne) <br/>Si omis, objetImage est une variable ou un champ"
				],
				[
					"objetPicture",
					"Picture",
					"->",
					"Nom d’objet (si * spécifié) ou Variable ou champ (si * omis)"
				],
				[
					"id",
					"Text",
					"->",
					"Attribut id de l’élément à visualiser"
				],
				[
					"marge",
					"Integer",
					"->",
					"Marge de visibilité (en pixels par défaut)"
				]
			],
			"Summary": "La commande **SVG SHOW ELEMENT** déplace le document SVG *objetImage* de façon à rendre visible l’élement dont l’attribut \"id\" est désigné par le paramètre *id*."
		},
		"System folder": {
			"Syntax": "**System folder** {( *type* )} : Text",
			"Params": [
				[
					"type",
					"Integer",
					"->",
					"Type de dossier système"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d’accès d’un dossier du système actif"
				]
			],
			"Summary": "La fonction **System folder** retourne le chemin d'accès du dossier Système Windows ou macOS actif, ou le chemin d’accès d’un dossier particulier du système d'exploitation."
		},
		"System info": {
			"Syntax": "**System info**  : Object",
			"Params": [
				[
					"Résultat",
					"Object",
					"<-",
					"Informations système"
				]
			],
			"Summary": "La commande **System info** retourne un objet contenant les informations sur le système d'exploitation ainsi que les caractéristiques matérielles et logicielles de la machine sur laquelle elle est exécutée."
		},
		"Table fragmentation": {
			"Syntax": "**Table fragmentation** ( *laTable* ) : Real",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle connaître le taux de fragmentation"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Pourcentage de fragmentation"
				]
			],
			"Summary": "La commande **Table fragmentation** retourne le pourcentage de fragmentation logique des enregistrements de la table désignée par le paramètre *laTable*."
		},
		"Table name": {
			"Syntax": "**Table name** ( numTable | ptrTable ) : Text",
			"Params": [
				[
					"numTable &#124; ptrTable",
					"Entier long, Pointeur",
					"->",
					"Numéro de table ou pointeur de table"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Nom de la table"
				]
			],
			"Summary": "**Table name** retourne le nom de la table dont le numéro ou le pointeur a été passé dans *numTable* ou *ptrTable*."
		},
		"Table": {
			"Syntax": "**Table** ( numTable | unPtr ) : any",
			"Params": [
				[
					"numTable &#124; unPtr",
					"Entier long, Pointeur",
					"->",
					"Numéro de table ou Pointeur de table ou Pointeur de champ"
				],
				[
					"Résultat",
					"Integer, Pointer",
					"<-",
					"Pointeur de table si un Numéro de table est passé, Numéro de table si un Pointeur de table est passé, Numéro de table si un Pointeur de champ est passé"
				]
			],
			"Summary": "**Table** a trois syntaxes différentes."
		},
		"Tan": {
			"Syntax": "**Tan** ( *nombre* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre, exprimé en radians, dont vous voulez connaître la tangente"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Tangente de nombre"
				]
			],
			"Summary": "**Tan** retourne la tangente de *nombre*."
		},
		"Temporary folder": {
			"Syntax": "**Temporary folder**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Chemin d'accès au dossier temporaire"
				]
			],
			"Summary": "La fonction **Temporary folder** retourne le chemin d'accès au dossier temporaire courant tel que défini par votre système d'exploitation."
		},
		"Test path name": {
			"Syntax": "**Test path name** ( *cheminAccès* ) : Integer",
			"Params": [
				[
					"cheminAccès",
					"Text",
					"->",
					"Chemin d'accès à un dossier ou un document"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"1= cheminAccès est un document existant 0 = cheminAccès est un dossier existant <0 = chemin d'accès invalide, code d'erreur du gestionnaire de fichiers du système"
				]
			],
			"Summary": "La fonction **Test path name** vérifie si le document ou le dossier dont vous avez passé le chemin d'accès et le nom dans *cheminAccès* est présent sur le disque."
		},
		"Test semaphore": {
			"Syntax": "**Test semaphore** ( *sémaphore* ) : Boolean",
			"Params": [
				[
					"sémaphore",
					"Text",
					"->",
					"Nom du sémaphore à tester"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = le sémaphore existe, Faux = le sémaphore n’existe pas"
				]
			],
			"Summary": "La commande **Test semaphore** permet de tester l’existence d’un sémaphore."
		},
		"TEXT TO ARRAY": {
			"Syntax": "**TEXT TO ARRAY** ( *varTexte* ; *tabTexte* ; *largeur* ; *nomPolice* ; *taillePolice* {; *stylePolice* {; *}} )",
			"Params": [
				[
					"varText",
					"Text",
					"->",
					"Texte original à découper"
				],
				[
					"tabTexte",
					"Text array",
					"<-",
					"Tableau contenant le texte découpé en mots ou lignes"
				],
				[
					"largeur",
					"Integer",
					"->",
					"Largeur maximale de la chaîne (en pixels)"
				],
				[
					"nomPolice",
					"Text",
					"->",
					"Nom de police"
				],
				[
					"taillePolice",
					"Integer",
					"->",
					"Taille de police"
				],
				[
					"stylePolice",
					"Integer",
					"->",
					"Style de police"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé = interpréter le texte en multistyle"
				]
			],
			"Summary": "La commande **TEXT TO ARRAY** permet de transformer une variable texte en tableau texte."
		},
		"TEXT TO BLOB": {
			"Syntax": "**TEXT TO BLOB** ( *texte* ; *blob* {; *formatTexte* {; offset | *}} )",
			"Params": [
				[
					"texte",
					"Text",
					"->",
					"Texte à écrire dans blob"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB devant recevoir le texte"
				],
				[
					"formatTexte",
					"Integer",
					"->",
					"Format et jeu de caractères du texte"
				],
				[
					"offset &#124; *",
					"Variable, Opérateur",
					"<->",
					"Offset (en octets) dans le BLOB ou * pour ajouter la valeur à la fin du BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après l'écriture si * omis"
				]
			],
			"Summary": "La commande **TEXT TO BLOB** écrit la valeur de type Texte *texte* dans le BLOB *blob*."
		},
		"TEXT TO DOCUMENT": {
			"Syntax": "**TEXT TO DOCUMENT** ( *nomFichier* ; *texte* {; *jeuCaractères* {; *modeRetour*}} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom de document ou Chemin d'accès à un document"
				],
				[
					"texte",
					"Text",
					"->",
					"Texte à stocker dans un document"
				],
				[
					"jeuCaractères",
					"Text, Integer",
					"->",
					"Nom ou Numéro de jeu de caractères"
				],
				[
					"modeRetour",
					"Integer",
					"->",
					"Mode de traitement des retours à la ligne"
				]
			],
			"Summary": "La commande **TEXT TO DOCUMENT** permet d’écrire directement le *texte* dans un fichier sur disque."
		},
		"throw": {
			"Syntax": "**throw** ( *errorCode* {; *description*} ) <br/>\n*throw* {( *errorObj* )}",
			"Params": [
				[
					"errorCode",
					"Integer",
					"->",
					"Code d'erreur"
				],
				[
					"description",
					"Text",
					"->",
					"Description de l'erreur"
				],
				[
					"throw {( errorObj )}"
				],
				[
					"Paramètre",
					"Type",
					"Description"
				],
				[
					"errorObj",
					"Object",
					"->",
					"Propriétés de l'erreur à construire"
				]
			],
			"Summary": "La commande **throw** crée une erreur qui sera levée soit immédiatement, soit lorsque la méthode appelante retournera à l'appelant (mode différé)."
		},
		"Tickcount": {
			"Syntax": "**Tickcount**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de ticks (60ème de seconde) écoulés depuis le démarrage de la machine"
				]
			],
			"Summary": "**Tickcount** retourne le nombre de ticks (1 tick = 1/60ème de seconde) écoulés depuis le démarrage de la machine."
		},
		"Time string": {
			"Syntax": "**Time string** ( *secondes* ) : Text",
			"Params": [
				[
					"secondes",
					"Integer, Time",
					"->",
					"Secondes écoulées depuis minuit"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Heure sous forme de chaîne au format 24 heures"
				]
			],
			"Summary": "La fonction **Time string** retourne sous forme de chaîne alphanumérique sur 24 heures l'expression de type Heure passée dans *secondes*."
		},
		"Time": {
			"Syntax": "**Time** ( *valHeure* ) : Time",
			"Params": [
				[
					"valHeure",
					"Text, Integer",
					"->",
					"Valeur à retourner sous forme d'heure"
				],
				[
					"Résultat",
					"Time",
					"<-",
					"Heure définie par valHeure"
				]
			],
			"Summary": "La fonction **Time** retourne, sous la forme d'une expression de type Heure, l'heure définie dans le paramètre *valHeure*."
		},
		"Timestamp": {
			"Syntax": "**Timestamp** : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"Heure courante au format ISO avec millisecondes"
				]
			],
			"Summary": "La commande **Timestamp** retourne l'heure UTC courante au format ISO avec millisecondes, i."
		},
		"Tool bar height": {
			"Syntax": "**Tool bar height**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Hauteur (exprimée en pixels) de la barre d’outils ou 0 si la barre d’outils n’est pas affichée"
				]
			],
			"Summary": "La commande **Tool bar height** retourne la hauteur de la barre d'outils visible courante, exprimée en pixels."
		},
		"TRACE": {
			"Syntax": "**TRACE**",
			"Params": [],
			"Summary": "La commande **TRACE** est utilisée, lors du développement des bases, pour tracer des méthodes, c'est-à-dire contrôler leur exécution pas à pas."
		},
		"Transaction level": {
			"Syntax": "**Transaction level**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Niveau de transaction courant (0 si aucune transaction n’a été démarrée)"
				]
			],
			"Summary": "La commande **Transaction level** retourne le niveau de transaction courant pour le process."
		},
		"TRANSFORM PICTURE": {
			"Syntax": "**TRANSFORM PICTURE** ( *image* ; *opérateur* {; *param1* {; *param2* {; *param3* {; *param4*}}}} )",
			"Params": [
				[
					"image",
					"Picture",
					"->",
					"Image source à transformer"
				],
				[
					"<-",
					"Image résultant de la transformation"
				],
				[
					"opérateur",
					"Integer",
					"->",
					"Type de transformation à effectuer"
				],
				[
					"param1",
					"Real",
					"->",
					"Paramètre de la transformation"
				],
				[
					"param2",
					"Real",
					"->",
					"Paramètre de la transformation"
				],
				[
					"param3",
					"Real",
					"->",
					"Paramètre de la transformation"
				],
				[
					"param4",
					"Real",
					"->",
					"Paramètre de la transformation"
				]
			],
			"Summary": "La commande **TRANSFORM PICTURE** permet d’appliquer une transformation de type *opérateur* à l’image passée dans le paramètre *image*."
		},
		"Trigger event": {
			"Syntax": "**Trigger event**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"0=Hors de tout événement de trigger, 1=Sauvegarde d'un nouvel enregistrement, 2=Sauvegarde d'un enregistrement existant, 3=Suppression d'un enregistrement"
				]
			],
			"Summary": "La commande **Trigger event** est appelée dans un trigger et renvoie une valeur numérique qui indique le type de l'événement de la base, ou la raison pour laquelle le trigger a été appelé."
		},
		"Trigger level": {
			"Syntax": "**Trigger level**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Niveau d'exécution du trigger (0 si hors du cycle d'exécution du trigger)"
				]
			],
			"Summary": "La commande **Trigger level** retourne le niveau d'exécution du trigger."
		},
		"TRIGGER PROPERTIES": {
			"Syntax": "**TRIGGER PROPERTIES** ( *niveauTrigger* ; *evenementBase* ; *numTable* ; *numEnreg* )",
			"Params": [
				[
					"niveauTrigger",
					"Integer",
					"->",
					"Niveau d'exécution du trigger"
				],
				[
					"evenementBase",
					"Integer",
					"<-",
					"Evénement de base de données"
				],
				[
					"numTable",
					"Integer",
					"<-",
					"Numéro de la table"
				],
				[
					"numEnreg",
					"Integer",
					"<-",
					"Numéro de l'enregistrement"
				]
			],
			"Summary": "La commande **TRIGGER PROPERTIES** fournit des informations sur le niveau d'exécution du trigger que vous avez passé dans *niveauTrigger*."
		},
		"True": {
			"Syntax": "**True**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai"
				]
			],
			"Summary": "**True** retourne la valeur booléenne Vrai."
		},
		"Trunc": {
			"Syntax": "**Trunc** ( *nombre* ; *nbDécimales* ) : Real",
			"Params": [
				[
					"nombre",
					"Real",
					"->",
					"Nombre à tronquer"
				],
				[
					"nbDécimales",
					"Integer",
					"->",
					"Nombre de décimales à conserver"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"nombre tronqué à partir du nombre de décimales indiqué par nbDécimales"
				]
			],
			"Summary": "**Trunc** retourne *nombre* dont la partie décimale a été tronquée à partir du nombre de décimales spécifié par *nbDécimales*."
		},
		"TRUNCATE TABLE": {
			"Syntax": "**TRUNCATE TABLE** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table de laquelle vous voulez supprimer tous les enregistrements ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "La commande **TRUNCATE TABLE** supprime tous les enregistrements de *laTable* de façon très rapide."
		},
		"Type": {
			"Syntax": "**Type** ( *champVar* ) : Integer",
			"Params": [
				[
					"champVar",
					"Field, Variable",
					"->",
					"Champ ou variable à tester"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du type de données"
				]
			],
			"Summary": "**Type** retourne une valeur numérique qui indique le type du champ ou de la variable que vous avez passé(e) dans le paramètre *champVar*."
		},
		"Undefined": {
			"Syntax": "**Undefined** ( *expression* ) : Boolean",
			"Params": [
				[
					"expression",
					"Expression",
					"->",
					"Expression à tester"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = Variable actuellement indéfinie Faux = Variable actuellement définie"
				]
			],
			"Summary": "La commande **Undefined** retourne Vrai si le résultat de l'évaluation d'*expression* n'est pas une valeur définie, sinon elle retourne Faux si *expression* a été définie."
		},
		"UNION": {
			"Syntax": "**UNION** ( *ensemble1* ; *ensemble2* ; *résultat* )",
			"Params": [
				[
					"ensemble1",
					"Text",
					"->",
					"Premier ensemble"
				],
				[
					"ensemble2",
					"Text",
					"->",
					"Second ensemble"
				],
				[
					"résultat",
					"Text",
					"->",
					"Ensemble résultant"
				]
			],
			"Summary": "**UNION** crée un nouvel ensemble contenant tous les enregistrements de *ensemble1* et *ensemble2*."
		},
		"UNLOAD RECORD": {
			"Syntax": "**UNLOAD RECORD** {( *laTable* )}",
			"Params": [
				[
					"laTable",
					"Table",
					"->",
					"Table pour laquelle l'enregistrement est à libérer ou Table par défaut si ce paramètre est omis"
				]
			],
			"Summary": "**UNLOAD RECORD** place l'enregistrement courant de *laTable* dans l'état non verrouillé."
		},
		"UNREGISTER CLIENT": {
			"Syntax": "**UNREGISTER CLIENT**",
			"Params": [],
			"Summary": "La commande **UNREGISTER CLIENT** “désinscrit” le client 4D de 4D Server."
		},
		"Uppercase": {
			"Syntax": "**Uppercase** ( *laChaîne* {; *} ) : Text",
			"Params": [
				[
					"laText",
					"Text",
					"->",
					"Chaîne à convertir en majuscules"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : conserver les accents Si omis : supprimer les accents"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"chaîne en majuscules"
				]
			],
			"Summary": "**Uppercase** retourne une chaîne de caractères égale à *laChaîne* dont tous les caractères alphabétiques ont été convertis en majuscules."
		},
		"USE CHARACTER SET": {
			"Syntax": "**USE CHARACTER SET** ( *filtre* {; *typeFiltre*} )",
			"Params": [
				[
					"filtre",
					"Text, *",
					"->",
					"Nom du jeu de caractères à utiliser ou * pour restaurer le jeu par défaut"
				],
				[
					"typeFiltre",
					"Integer",
					"->",
					"0 = Filtre d'exportation, 1 = Filtre d'importation"
				]
			],
			"Summary": "La commande **USE CHARACTER SET** permet de modifier le jeu de caractères utilisé par 4D pour toutes les opérations de transfert entre la base et un document ou un port série pour le process courant."
		},
		"USE NAMED SELECTION": {
			"Syntax": "**USE NAMED SELECTION** ( *nom* )",
			"Params": [
				[
					"nom",
					"Text",
					"->",
					"Nom de la sélection temporaire à utiliser"
				]
			],
			"Summary": "**USE NAMED SELECTION** désigne la sélection temporaire *nom* comme sélection courante pour la table à laquelle elle appartient."
		},
		"USE SET": {
			"Syntax": "**USE SET** ( *ensemble* )",
			"Params": [
				[
					"ensemble",
					"Text",
					"->",
					"Nom de l'ensemble à utiliser"
				]
			],
			"Summary": "**USE SET** crée, avec les enregistrements de *ensemble*, une nouvelle sélection courante pour la table à laquelle *ensemble* appartient."
		},
		"User in group": {
			"Syntax": "**User in group** ( *nomUtilisateur* ; *groupe* ) : Boolean",
			"Params": [
				[
					"nomUtilisateur",
					"Text",
					"->",
					"Nom de l'utilisateur (compte)"
				],
				[
					"groupe",
					"Text",
					"->",
					"Nom du groupe"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = utilisateur est dans groupe Faux = utilisateur n'est pas dans groupe"
				]
			],
			"Summary": "La fonction **User in group** retourne Vrai si *nomUtilisateur* appartient au *groupe*."
		},
		"USERS TO BLOB": {
			"Syntax": "**USERS TO BLOB** ( *utilisateurs* )",
			"Params": [
				[
					"utilisateurs",
					"Blob",
					"->",
					"BLOB devant contenir les utilisateurs"
				],
				[
					"<-",
					"Comptes utilisateurs (crypté)"
				]
			],
			"Summary": "**Note de compatibilité :** Cette commande fonctionne uniquement dans les bases binaires."
		},
		"Validate password": {
			"Syntax": "**Validate password** ( *utilisateur* ; *motDePasse* {; *digest*} ) : Boolean",
			"Params": [
				[
					"utilisateur",
					"Integer, Text",
					"->",
					"N° de référence unique ou Nom de l’utilisateur"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe non crypté"
				],
				[
					"digest",
					"Boolean",
					"->",
					"Mot de passe digest = Vrai, <br/>Mot de passe en clair (défaut)= Faux"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = mot de passe correct, Faux = mot de passe incorrect"
				]
			],
			"Summary": "La commande **Validate password** retourne Vrai si la chaîne passée dans *motDePasse* est le mot de passe du compte utilisateur dont le n° de référence ou le nom est passé dans *utilisateur*."
		},
		"VALIDATE TRANSACTION": {
			"Syntax": "**VALIDATE TRANSACTION**",
			"Params": [],
			"Summary": "**VALIDATE TRANSACTION** accepte la transaction ouverte par la commande START TRANSACTION de niveau correspondant dans le process courant."
		},
		"Value type": {
			"Syntax": "**Value type** ( *expression* ) : Integer",
			"Params": [
				[
					"expression",
					"Expression",
					"->",
					"Expression dont la valeur résultante doit être testée"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro du type de données"
				]
			],
			"Summary": "La commande **Value type** retourne le type de la valeur résultant de l'évaluation de l'*expression* passée en paramètre."
		},
		"VARIABLE TO BLOB": {
			"Syntax": "**VARIABLE TO BLOB** ( *variable* ; *blob* {; offset } )<br/>**VARIABLE TO BLOB** ( *variable* ; *blob* {; *} )",
			"Params": [
				[
					"variable",
					"Variable",
					"->",
					"Variable à stocker dans le BLOB"
				],
				[
					"blob",
					"Blob",
					"->",
					"BLOB devant recevoir la variable"
				],
				[
					"offset &#124; *",
					"Variable, Opérateur",
					"<->",
					"Offset de la variable (en octets) dans BLOB ou * pour ajouter la variable à la fin du BLOB"
				],
				[
					"",
					"",
					"",
					"Nouvel offset après écriture si * omis"
				]
			],
			"Summary": "**VARIABLE TO BLOB** stocke la variable *variable* dans le BLOB *blob*."
		},
		"VARIABLE TO VARIABLE": {
			"Syntax": "**VARIABLE TO VARIABLE** ( *process* ; *varDestination* ; *varSource* {; *varDestination2* ; *varSource2* ; ... ; *varDestinationN* ; *varSourceN*} )",
			"Params": [
				[
					"process",
					"Integer",
					"->",
					"Numéro du process de destination"
				],
				[
					"varDestination",
					"Variable",
					"->",
					"Variable de destination"
				],
				[
					"varSource",
					"Variable",
					"->",
					"Variable source"
				]
			],
			"Summary": "La commande **VARIABLE TO VARIABLE** écrit la valeur de la ou des variable(s) *varSource1* (*varSource2*, etc.), dans la ou les variable(s) process *varDestination* (*varDestination2*, etc.) du process de destination dont vous avez passé le numéro dans *process*."
		},
		"Variance": {
			"Syntax": "**Variance** ( *séries* ) : Real",
			"Params": [
				[
					"séries",
					"Field, Array",
					"->",
					"Valeurs dont vous voulez obtenir la variance"
				],
				[
					"Résultat",
					"Real",
					"<-",
					"Variance de séries"
				]
			],
			"Summary": "**Variance** retourne la variance de *séries*."
		},
		"VERIFY CURRENT DATA FILE": {
			"Syntax": "**VERIFY CURRENT DATA FILE** {( *objets* ; *options* ; *méthode* {; *tabTables* {; *tabChamps*}} )}",
			"Params": [
				[
					"objets",
					"Integer",
					"->",
					"Objets à vérifier"
				],
				[
					"options",
					"Integer",
					"->",
					"Options de vérification"
				],
				[
					"méthode",
					"Text",
					"->",
					"Nom de la méthode 4D de rétro-appel"
				],
				[
					"tabTables",
					"Integer array",
					"->",
					"Numéros des tables à vérifier"
				],
				[
					"tabChamps",
					"2D Integer array, 2D Integer array, 2D Real array",
					"->",
					"Numéros des index à vérifier"
				]
			],
			"Summary": "La commande **VERIFY CURRENT DATA FILE** effectue une vérification structurelle des objets contenus dans le fichier de données actuellement ouvert par 4D."
		},
		"VERIFY DATA FILE": {
			"Syntax": "**VERIFY DATA FILE** ( *cheminStructure* ; *cheminDonnées* ; *objets* ; *options* ; *méthode* {; *tabTables* {; *tabChamps*}} )",
			"Params": [
				[
					"cheminStructure",
					"Text",
					"->",
					"Chemin d’accès du fichier de structure de la base à vérifier"
				],
				[
					"cheminDonnées",
					"Text",
					"->",
					"Chemin d’accès du fichier de données de la base à vérifier"
				],
				[
					"objets",
					"Integer",
					"->",
					"Objets à vérifier"
				],
				[
					"options",
					"Integer",
					"->",
					"Options de vérification"
				],
				[
					"méthode",
					"Text",
					"->",
					"Nom de la méthode 4D de rétroappel"
				],
				[
					"tabTables",
					"Integer array",
					"->",
					"Numéros des tables à vérifier"
				],
				[
					"tabChamps",
					"2D Integer array, 2D Integer array, 2D Real array",
					"->",
					"Numéros des index à vérifier"
				]
			],
			"Summary": "La commande **VERIFY DATA FILE** effectue une vérification structurelle des objets contenus dans le fichier de données 4D désigné par *cheminStructure* et *cheminDonnées*."
		},
		"Verify password hash": {
			"Syntax": "**Verify password hash** ( *motDePasse* ; *hash* ) : Boolean",
			"Params": [
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe utilisateur (seuls les 72 premiers caractères sont utilisés)"
				],
				[
					"hash",
					"Text",
					"->",
					"Hash du mot de passe"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si motDePasse et hash correspondent, Faux sinon"
				]
			],
			"Summary": "La fonction **Verify password hash** vérifie que l'empreinte cryptographique *hash* correspond bien au *motDePasse*."
		},
		"Version type": {
			"Syntax": "**Version type**  : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Informations sur le type de version (champ de bits)"
				]
			],
			"Summary": "La commande **Version type** retourne une valeur numérique qui représente le type de version de 4D ou de 4D Server que vous utilisez."
		},
		"VOLUME ATTRIBUTES": {
			"Syntax": "**VOLUME ATTRIBUTES** ( *volume* ; *taille* ; *utilisé* ; *libre* )",
			"Params": [
				[
					"volume",
					"Text",
					"->",
					"Nom du volume"
				],
				[
					"taille",
					"Real",
					"<-",
					"Taille du volume exprimée en octets"
				],
				[
					"utilisé",
					"Real",
					"<-",
					"Place utilisée sur le volume exprimée en octets"
				],
				[
					"libre",
					"Real",
					"<-",
					"Place libre sur le volume exprimée en octets"
				]
			],
			"Summary": "La commande **VOLUME ATTRIBUTES** retourne la taille, la place utilisée et la place libre sur le volume dont le nom est passé dans *volume*."
		},
		"VOLUME LIST": {
			"Syntax": "**VOLUME LIST** ( *volumes* )",
			"Params": [
				[
					"volumes",
					"Text array",
					"<-",
					"Noms des volumes actuellement montés"
				]
			],
			"Summary": "**VOLUME LIST** remplit le tableau *volumes*, de type texte, avec les noms des volumes définis (Windows) ou montés (macOS) sur votre machine."
		},
		"WA Back URL available": {
			"Syntax": "**WA Back URL available** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai s’il existe un URL précédent dans la séquence d’URLs ouverts, Faux sinon"
				]
			],
			"Summary": "La commande **WA Back URL available** permet de savoir s’il existe un URL précédent disponible dans la séquence d’URLs ouverts dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Create URL history menu": {
			"Syntax": "**WA Create URL history menu** ( {* ;} *objet* {; *direction*} ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"direction",
					"Integer",
					"->",
					"0 ou omis=Liste des URLs précédents, 1=Liste des URLs suivants"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Référence du menu"
				]
			],
			"Summary": "La commande **WA Create URL history menu** crée et remplit un menu pouvant être utilisé directement pour la navigation parmi les URLs visités au cours de la session dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Evaluate JavaScript": {
			"Syntax": "**WA Evaluate JavaScript** ( {* ;} *objet* ; *codeJS* {; *type*} )  : any",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"codeJS",
					"Text",
					"->",
					"Code JavaScript"
				],
				[
					"type",
					"Integer",
					"->",
					"Type dans lequel convertir le résultat"
				],
				[
					"Résultat",
					"Date, Time, Object, Pointer, Real, Text",
					"<-",
					"Résultat de l’exécution"
				]
			],
			"Summary": "La commande **WA Evaluate JavaScript** exécute dans la zone Web désignée par les paramètres *\\** et *objet* le code JavaScript passé dans *codeJS* et retourne le résultat."
		},
		"WA EXECUTE JAVASCRIPT FUNCTION": {
			"Syntax": "**WA EXECUTE JAVASCRIPT FUNCTION** ( {* ;} *objet* ; *fonctionJS* ; résultat | * {; *param*}{; *param2* ; ... ; *paramN*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"fonctionJS",
					"Text",
					"->",
					"Nom de la fonction JavaScript à exécuter"
				],
				[
					"résultat &#124; *",
					"Variable",
					"->",
					"* pour une fonction sans résultat ou"
				],
				[
					"<-",
					"Résultat de la fonction (si attendu)"
				],
				[
					"param",
					"Text, Number, Date, Object, Collection",
					"->",
					"Paramètre(s) à passer à la fonction"
				]
			],
			"Summary": "La commande **WA EXECUTE JAVASCRIPT FUNCTION** exécute dans la zone Web désignée par les paramètres *\\** et *objet* la fonction JavaScript *fonctionJS* et retourne facultativement son résultat dans le paramètre *résultat*."
		},
		"WA Forward URL available": {
			"Syntax": "**WA Forward URL available** ( {* ;} *objet* ) : Boolean",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai s’il existe un URL suivant dans la séquence d’URLs ouverts, Faux sinon"
				]
			],
			"Summary": "La commande **WA Forward URL available** permet de savoir s’il existe un URL suivant disponible dans la séquence d’URLs ouverts dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Get current URL": {
			"Syntax": "**WA Get current URL** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"URL actuellement chargé dans la zone Web"
				]
			],
			"Summary": "La commande **WA Get current URL** retourne l’adresse URL de la page affichée dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA GET EXTERNAL LINKS FILTERS": {
			"Syntax": "**WA GET EXTERNAL LINKS FILTERS** ( {* ;} *objet* ; *tabFiltres* ; *tabAutorisRefus* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabFiltres",
					"Text array",
					"<-",
					"Tableau de filtres"
				],
				[
					"tabAutorisRefus",
					"Boolean array",
					"<-",
					"Tableau autoriser-refuser"
				]
			],
			"Summary": "La commande **WA GET EXTERNAL LINKS FILTERS** retourne dans les tableaux *tabFiltres* et *tabAutorisRefus* les filtres de liens externes de la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Get last filtered URL": {
			"Syntax": "**WA Get last filtered URL** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Dernier URL filtré"
				]
			],
			"Summary": "La commande **WA Get last filtered URL** retourne le dernier URL ayant été filtré dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA GET LAST URL ERROR": {
			"Syntax": "**WA GET LAST URL ERROR** ( {* ;} *objet* ; *url* ; *description* ; *codeErreur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"url",
					"Text",
					"<-",
					"URL à l’origine de l’erreur"
				],
				[
					"description",
					"Text",
					"<-",
					"Description de l’erreur (macOS)"
				],
				[
					"codeErreur",
					"Integer",
					"<-",
					"Code d'erreur"
				]
			],
			"Summary": "La commande **WA GET LAST URL ERROR** vous permet de récupérer plusieurs informations relatives à la dernière erreur ayant eu lieu dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Get page content": {
			"Syntax": "**WA Get page content** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Code HTML source"
				]
			],
			"Summary": "La commande **WA Get page content** retourne le code HTML de la page courante ou en cours d’affichage dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Get page title": {
			"Syntax": "**WA Get page title** ( {* ;} *objet* ) : Text",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Titre de la page courante"
				]
			],
			"Summary": "La commande **WA Get page title** retourne le titre de la page courante ou en cours d’affichage dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA GET PREFERENCE": {
			"Syntax": "**WA GET PREFERENCE** ( {* ;} *objet* ; *sélecteur* ; *valeur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Préférence à lire"
				],
				[
					"valeur",
					"Variable",
					"<-",
					"Valeur courante de la préférence"
				]
			],
			"Summary": "La commande **WA GET PREFERENCE** permet de lire la valeur courante d’une préférence dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA GET URL FILTERS": {
			"Syntax": "**WA GET URL FILTERS** ( {* ;} *objet* ; *tabFiltres* ; *tabAutorisRefus* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabFiltres",
					"Text array",
					"<-",
					"Tableau de filtres"
				],
				[
					"tabAutorisRefus",
					"Boolean array",
					"<-",
					"Tableau autoriser-refuser"
				]
			],
			"Summary": "La commande **WA GET URL FILTERS** retourne dans les tableaux *tabFiltres* et *tabAutorisRefus* les filtres actifs dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA GET URL HISTORY": {
			"Syntax": "**WA GET URL HISTORY** ( {* ;} *objet* ; *tabsUrls* {; *sens* {; *tabTitres*}} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabsUrls",
					"Text array",
					"<-",
					"Tableau des URLs visités"
				],
				[
					"sens",
					"Integer",
					"->",
					"0 ou omis=Liste des URLs précédents, 1=Liste des URLs suivants"
				],
				[
					"tabTitres",
					"Text array",
					"<-",
					"Tableau des titres de fenêtres"
				]
			],
			"Summary": "La commande **WA GET URL HISTORY** retourne un ou deux tableaux contenant les URLs visités au cours de la session dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA OPEN BACK URL": {
			"Syntax": "**WA OPEN BACK URL** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA OPEN BACK URL** charge dans la zone Web désignée par les paramètres *\\** et *objet* l’URL précédent dans la séquence d’URLs ouverts."
		},
		"WA OPEN FORWARD URL": {
			"Syntax": "**WA OPEN FORWARD URL** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA OPEN FORWARD URL** charge dans la zone Web désignée par les paramètres *\\** et *objet* l’URL suivant dans la séquence d’URLs ouverts."
		},
		"WA OPEN URL": {
			"Syntax": "**WA OPEN URL** ( {* ;} *objet* ; *url* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"url",
					"Text",
					"->",
					"URL à charger dans la zone Web"
				]
			],
			"Summary": "La commande **WA OPEN URL** charge dans la zone Web désignée par les paramètres *\\** et *objet* l’URL passé dans le paramètre *url*."
		},
		"WA OPEN WEB INSPECTOR": {
			"Syntax": "**WA OPEN WEB INSPECTOR** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si ce paramètre est spécifié, objet est un nom d'objet (chaîne). S'il est omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié), ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA OPEN WEB INSPECTOR** ouvre un inspecteur web pour la zone web désignée par les paramètres *\\** et *objet*."
		},
		"WA REFRESH CURRENT URL": {
			"Syntax": "**WA REFRESH CURRENT URL** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA REFRESH CURRENT URL** provoque le rechargement de l’URL courant affiché dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA Run offscreen area": {
			"Syntax": "**WA Run offscreen area** ( *paramètres* ) : any",
			"Params": [
				[
					"paramètres",
					"Object",
					"->",
					"Objet contenant les attributs de la zone web"
				],
				[
					"Résultat",
					"any",
					"<-",
					"Valeur retournée par la méthode callback (ou méthode de rétro-appel)"
				]
			],
			"Summary": "La commande **WA Run offscreen area** crée une zone web dans la mémoire qui peut être utilisée pour charger et parser automatiquement des pages web."
		},
		"WA SET EXTERNAL LINKS FILTERS": {
			"Syntax": "**WA SET EXTERNAL LINKS FILTERS** ( {* ;} *objet* ; *tabFiltres* ; *tabAutorisRefus* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabFiltres",
					"Text array",
					"->",
					"Tableau de filtres"
				],
				[
					"tabAutorisRefus",
					"Boolean array",
					"->",
					"Tableau autoriser-refuser"
				]
			],
			"Summary": "La commande **WA SET EXTERNAL LINKS FILTERS** permet de mettre en place un ou plusieurs filtre(s) de liens externes pour la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA SET PAGE CONTENT": {
			"Syntax": "**WA SET PAGE CONTENT** ( {* ;} *objet* ; *contenu* ; *baseURL* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"contenu",
					"Text",
					"->",
					"Code HTML source"
				],
				[
					"baseURL",
					"Text",
					"->",
					"URL pour les références relatives (macOS)"
				]
			],
			"Summary": "Cette commande historique n'est plus vraiment utile."
		},
		"WA SET PREFERENCE": {
			"Syntax": "**WA SET PREFERENCE** ( {* ;} *objet* ; *sélecteur* ; *valeur* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Préférence à modifier"
				],
				[
					"valeur",
					"Boolean",
					"->",
					"Valeur de la préférence (Vrai = autorisé, Faux = non autorisé)"
				]
			],
			"Summary": "La commande **WA SET PREFERENCE** permet de fixer différentes préférences pour la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA SET URL FILTERS": {
			"Syntax": "**WA SET URL FILTERS** ( {* ;} *objet* ; *tabFiltres* ; *tabAutorisRefus* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				],
				[
					"tabFiltres",
					"Text array",
					"->",
					"Tableau de filtres"
				],
				[
					"tabAutorisRefus",
					"Boolean array",
					"->",
					"Tableau autoriser-refuser"
				]
			],
			"Summary": "La commande **WA SET URL FILTERS** permet de mettre en place un ou plusieurs filtre(s) pour la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA STOP LOADING URL": {
			"Syntax": "**WA STOP LOADING URL** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA STOP LOADING URL** stoppe le chargement des ressources de l’URL courant de la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA ZOOM IN": {
			"Syntax": "**WA ZOOM IN** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA ZOOM IN** augmente la taille du texte affiché dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WA ZOOM OUT": {
			"Syntax": "**WA ZOOM OUT** ( {* ;} *objet* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, objet est un nom d'objet (chaîne) Si omis, objet est une variable"
				],
				[
					"objet",
					"any",
					"->",
					"Nom d'objet (si * est spécifié) ou Variable (si * est omis)"
				]
			],
			"Summary": "La commande **WA ZOOM OUT** réduit la taille du texte affiché dans la zone Web désignée par les paramètres *\\** et *objet*."
		},
		"WEB Get body part count": {
			"Syntax": "**WEB Get body part count** : Integer",
			"Params": [
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de parties du corps"
				]
			],
			"Summary": "La commande **WEB Get body part count** retourne le nombre de parties qui composent le body (corps) reçu."
		},
		"WEB GET BODY PART": {
			"Syntax": "**WEB GET BODY PART** ( *partie* ; *contenuPartie* ; *nomPartie* ; *typeMime* ; *nomFichier* )",
			"Params": [
				[
					"partie",
					"Integer",
					"->",
					"Numéro de partie"
				],
				[
					"contenuPartie",
					"Blob, Text",
					"<-",
					"Contenu de la partie"
				],
				[
					"nomPartie",
					"Text",
					"<-",
					"Nom de la variable \"input\""
				],
				[
					"typeMime",
					"Text",
					"<-",
					"Type mime du fichier"
				],
				[
					"nomFichier",
					"Text",
					"<-",
					"Nom du fichier posté"
				]
			],
			"Summary": "La commande **WEB GET BODY PART**, appelée dans le contexte d’un process Web, permet d’analyser la partie \"corps\" d’une requête multi-part."
		},
		"WEB Get current session ID": {
			"Syntax": "**WEB Get current session ID**  : Text",
			"Params": [
				[
					"Résultat",
					"Text",
					"<-",
					"UUID de la session"
				]
			],
			"Summary": "La commande **WEB Get current session ID** retourne l’ID de la session ouverte pour la requête Web."
		},
		"WEB GET HTTP BODY": {
			"Syntax": "**WEB GET HTTP BODY** ( *corps* )",
			"Params": [
				[
					"corps",
					"Blob, Text",
					"<-",
					"Champ corps (Body) de la requête HTTP"
				]
			],
			"Summary": "La commande **WEB GET HTTP BODY** retourne le corps (body) de la requête HTTP en cours de traitement."
		},
		"WEB GET HTTP HEADER": {
			"Syntax": "**WEB GET HTTP HEADER** ( entête | tabChamps {; *tabValeurs*} )",
			"Params": [
				[
					"entête &#124; tabChamps",
					"Texte, Tableau texte",
					"<-",
					"En-tête HTTP de la requête ou Champs de l’en-tête HTTP"
				],
				[
					"tabValeurs",
					"Text array",
					"<-",
					"Contenu des champs de l’en-tête HTTP"
				]
			],
			"Summary": "La commande **WEB GET HTTP HEADER** retourne, soit sous forme de chaîne, soit sous forme de deux tableaux, l’en-tête HTTP de la requête en cours de traitement."
		},
		"WEB GET OPTION": {
			"Syntax": "**WEB GET OPTION** ( *sélecteur* ; *valeur* )",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Code de l’option à modifier"
				],
				[
					"valeur",
					"Integer, Text, Collection",
					"<-",
					"Valeur de l’option"
				]
			],
			"Summary": "La commande **WEB GET OPTION** permet de lire la valeur courante d’une option de fonctionnement du serveur Web de 4D."
		},
		"WEB Get server info": {
			"Syntax": "**WEB Get server info** {( *avecCache* )} : Object",
			"Params": [
				[
					"avecCache",
					"Boolean",
					"->",
					"Vrai pour obtenir la description du cache Web. Sinon (par défaut) la description du cache n'est pas retournée."
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur le serveur Web et le serveur SOAP en cours d'exécution."
				]
			],
			"Summary": "La commande **WEB Get server info** retourne un objet contenant des informations détaillées sur la session courante du serveur Web 4D."
		},
		"WEB GET STATISTICS": {
			"Syntax": "**WEB GET STATISTICS** ( *pages* ; *hits* ; *usage* )",
			"Params": [
				[
					"pages",
					"Text array",
					"<-",
					"Noms des pages les plus consultées"
				],
				[
					"hits",
					"Integer array",
					"<-",
					"Nombre de hits pour chaque page"
				],
				[
					"usage",
					"Integer",
					"<-",
					"Pourcentages du cache utilisé"
				]
			],
			"Summary": "La commande **WEB GET STATISTICS** vous permet d’obtenir des informations sur les pages les plus consultées, chargées dans le cache du serveur Web."
		},
		"WEB GET VARIABLES": {
			"Syntax": "**WEB GET VARIABLES** ( *tabNoms* ; *tabValeurs* )",
			"Params": [
				[
					"tabNoms",
					"Text array",
					"<-",
					"Noms des variables du formulaire Web"
				],
				[
					"tabValeurs",
					"Text array",
					"<-",
					"Valeurs des variables du formulaire Web"
				]
			],
			"Summary": "La commande **WEB GET VARIABLES** remplit les tableaux texte *tabNoms* et *tabValeurs* avec, respectivement, les noms et les valeurs des variables contenues dans un formulaire Web “soumis” (c’est-à-dire envoyé) au serveur Web."
		},
		"WEB Is secured connection": {
			"Syntax": "**WEB Is secured connection**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai = la connexion Web est sécurisée, Faux = la connexion Web n’est pas sécurisée"
				]
			],
			"Summary": "La commande **WEB Is secured connection** retourne un booléen indiquant si la connexion au serveur Web 4D s’effectue en mode sécurisé via TLS/SSL (la requête débute par “https:” au lieu de “http:”)."
		},
		"WEB Is server running": {
			"Syntax": "**WEB Is server running** : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le serveur Web est démarré, sinon Faux"
				]
			],
			"Summary": "La commande **WEB Is server running** retourne **Vrai** si le serveur Web intégré de 4D est démarré, et **Faux** si le serveur Web est stoppé."
		},
		"WEB LEGACY CLOSE SESSION": {
			"Syntax": "**WEB LEGACY CLOSE SESSION** ( *idSession* )",
			"Params": [
				[
					"idSession",
					"Text",
					"->",
					"UUID de session"
				]
			],
			"Summary": "Cette commande peut être utilisée uniquement avec les **anciennes sessions Web**, disponibles dans les bases de données converties à partir de versions antérieures à 4D v18 R6\\."
		},
		"WEB LEGACY GET SESSION EXPIRATION": {
			"Syntax": "**WEB LEGACY GET SESSION EXPIRATION** ( *idSession* ; *dateExp* ; *heureExp* )",
			"Params": [
				[
					"idSession",
					"Text",
					"->",
					"UUID de session"
				],
				[
					"dateExp",
					"Date",
					"<-",
					"Date d’expiration du cookie"
				],
				[
					"heureExp",
					"Time",
					"<-",
					"Heure d’expiration du cookie"
				]
			],
			"Summary": "Cette commande peut être utilisée uniquement avec les **anciennes sessions Web**, disponibles dans les bases de données converties à partir de versions antérieures à 4D v18 R6\\."
		},
		"WEB SEND BLOB": {
			"Syntax": "**WEB SEND BLOB** ( *blob* ; *type* )",
			"Params": [
				[
					"blob",
					"Blob",
					"->",
					"BLOB à envoyer au browser"
				],
				[
					"type",
					"Text",
					"->",
					"Type de données du BLOB"
				]
			],
			"Summary": "La commande **WEB SEND BLOB** permet d’envoyer le BLOB *blob* au navigateur."
		},
		"WEB SEND FILE": {
			"Syntax": "**WEB SEND FILE** ( *fichierWeb* )",
			"Params": [
				[
					"fichierWeb",
					"Text",
					"->",
					"Chemin d'accès au fichier Web à envoyer"
				]
			],
			"Summary": "La commande **WEB SEND FILE** envoie au navigateur Web la page HTML ou le fichier Web stocké dans le document dont vous passez le chemin d'accès dans *fichierHTML*."
		},
		"WEB SEND HTTP REDIRECT": {
			"Syntax": "**WEB SEND HTTP REDIRECT** ( *url* {; *} )",
			"Params": [
				[
					"url",
					"Text",
					"->",
					"Nouvel URL"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié = l’URL n’est pas traduit, Si omis = l’URL est traduit"
				]
			],
			"Summary": "La commande **WEB SEND HTTP REDIRECT** permet de transformer un URL en un autre."
		},
		"WEB SEND RAW DATA": {
			"Syntax": "**WEB SEND RAW DATA** ( *données* {; *} )",
			"Params": [
				[
					"données",
					"Blob",
					"->",
					"Données HTTP à envoyer"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Envoi morcelé (chunked)"
				]
			],
			"Summary": "La commande **WEB SEND RAW DATA** permet au serveur Web 4D d’envoyer des données HTTP “brutes”, pouvant être morcelées."
		},
		"WEB SEND TEXT": {
			"Syntax": "**WEB SEND TEXT** ( *texteHTML* {; *type*} )",
			"Params": [
				[
					"texteHTML",
					"Text",
					"->",
					"Champ ou variable texte au format HTML à envoyer au navigateur"
				],
				[
					"type",
					"Text",
					"->",
					"Type MIME"
				]
			],
			"Summary": "La commande **WEB SEND TEXT** permet d’envoyer directement des données texte formatées en HTML."
		},
		"WEB SERVICE AUTHENTICATE": {
			"Syntax": "**WEB SERVICE AUTHENTICATE** ( *nom* ; *motDePasse* {; *méthodeAuth*} {; *} )",
			"Params": [
				[
					"nom",
					"Text",
					"->",
					"Nom de l’utilisateur"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe de l’utilisateur"
				],
				[
					"méthodeAuth",
					"Integer",
					"->",
					"Méthode d’authentification : 0 ou omis=non définie, 1=BASIC, 2=DIGEST"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si passé : authentification par proxy"
				]
			],
			"Summary": "La commande **WEB SERVICE AUTHENTICATE** vous permet d’utiliser des Web Services nécessitant l’authentification de l’application cliente."
		},
		"WEB SERVICE CALL": {
			"Syntax": "**WEB SERVICE CALL** ( *urlAccès* ; *soapAction* ; *nomMéthode* ; *nameSpace* {; *typeComposé* {; *}} )",
			"Params": [
				[
					"urlAccès",
					"Text",
					"->",
					"URL d’accès au Web Service"
				],
				[
					"soapAction",
					"Text",
					"->",
					"Contenu du champ SOAPAction"
				],
				[
					"nomMéthode",
					"Text",
					"->",
					"Nom de la méthode"
				],
				[
					"nameSpace",
					"Text",
					"->",
					"Espace de nommage"
				],
				[
					"typeComposé",
					"Integer",
					"->",
					"Configuration de types composés (types simples si omis)"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Ne pas fermer la connexion"
				]
			],
			"Summary": "La commande **WEB SERVICE CALL** permet d’invoquer un Web Service en envoyant une requête HTTP."
		},
		"WEB SERVICE Get info": {
			"Syntax": "**WEB SERVICE Get info** ( *typeInfo* ) : Text",
			"Params": [
				[
					"typeInfo",
					"Integer",
					"->",
					"Information à récupérer"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Information sur la dernière erreur SOAP"
				]
			],
			"Summary": "La commande **WEB SERVICE Get info** retourne des informations relatives à l'erreur éventuellement générée lors de l’exécution de la dernière requête SOAP adressée à un Web Service."
		},
		"WEB SERVICE GET RESULT": {
			"Syntax": "**WEB SERVICE GET RESULT** ( *valeurRetour* {; *nomRetour* {; *}} )",
			"Params": [
				[
					"valeurRetour",
					"Variable",
					"<-",
					"Valeur retournée par le Web Service"
				],
				[
					"nomRetour",
					"Text",
					"->",
					"Nom du paramètre à récupérer"
				],
				[
					"*",
					"Operator",
					"->",
					"Libérer la mémoire"
				]
			],
			"Summary": "La commande **WEB SERVICE GET RESULT** permet de récupérer une valeur renvoyée par le Web Service à l’issue du traitement effectué."
		},
		"WEB SERVICE SET OPTION": {
			"Syntax": "**WEB SERVICE SET OPTION** ( *option* ; *valeur* )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Code de l’option à fixer"
				],
				[
					"valeur",
					"Integer, Text",
					"->",
					"Valeur de l’option"
				]
			],
			"Summary": "Cette commande est destinée aux utilisateurs avancés des Web Services."
		},
		"WEB SERVICE SET PARAMETER": {
			"Syntax": "**WEB SERVICE SET PARAMETER** ( *nom* ; *valeur* {; *typeSOAP*} )",
			"Params": [
				[
					"nom",
					"Text",
					"->",
					"Nom du paramètre à inclure dans la requête SOAP"
				],
				[
					"valeur",
					"Variable",
					"->",
					"Variable 4D contenant la valeur du paramètre"
				],
				[
					"typeSOAP",
					"Text",
					"->",
					"Type SOAP du paramètre"
				]
			],
			"Summary": "La commande **WEB SERVICE SET PARAMETER** permet de définir un paramètre utilisé pour une requête SOAP cliente."
		},
		"WEB SET HOME PAGE": {
			"Syntax": "**WEB SET HOME PAGE** ( *homePage* )",
			"Params": [
				[
					"homePage",
					"Text",
					"->",
					"Nom de page ou chemin d’accès HTML à la page ou \"\" pour ne pas envoyer de page d’accueil personnalisée"
				]
			],
			"Summary": "La commande **WEB SET HOME PAGE** vous permet de modifier la page d’accueil (page Home) personnalisée pour le process Web courant."
		},
		"WEB SET HTTP HEADER": {
			"Syntax": "**WEB SET HTTP HEADER** ( entête | tabChamps {; *tabValeurs*} )",
			"Params": [
				[
					"entête &#124; tabChamps",
					"Texte, Tableau texte",
					"->",
					"Champ ou variable contenant l'en-tête HTTP de la requête ou Tableau des champs de l'en-tête HTTP"
				],
				[
					"tabValeurs",
					"Text array",
					"->",
					"Contenu des champs de l’en-tête HTTP"
				]
			],
			"Summary": "La commande **WEB SET HTTP HEADER** permet de fixer les champs de l’en-tête HTTP de la réponse faite au navigateur Web par 4D."
		},
		"WEB SET OPTION": {
			"Syntax": "**WEB SET OPTION** ( *sélecteur* ; *valeur* )",
			"Params": [
				[
					"sélecteur",
					"Integer",
					"->",
					"Code de l’option à modifier"
				],
				[
					"valeur",
					"Integer, Text, Collection",
					"->",
					"Valeur de l’option"
				]
			],
			"Summary": "La commande **WEB SET OPTION** permet de modifier la valeur courante de diverses options de fonctionnement du serveur Web de 4D."
		},
		"WEB SET ROOT FOLDER": {
			"Syntax": "**WEB SET ROOT FOLDER** ( *dossierRacine* )",
			"Params": [
				[
					"dossierRacine",
					"Text",
					"->",
					"Chemin d'accès du dossier racine du serveur Web"
				]
			],
			"Summary": "La commande **WEB SET ROOT FOLDER** permet de modifier le dossier racine par défaut dans lequel 4D ira rechercher les fichiers HTML demandés au serveur Web."
		},
		"WEB START SERVER": {
			"Syntax": "**WEB START SERVER**",
			"Params": [],
			"Summary": "La commande **WEB START SERVER** démarre le serveur Web de l'application 4D sur laquelle elle a été exécutée (4D ou 4D Server)."
		},
		"WEB STOP SERVER": {
			"Syntax": "**WEB STOP SERVER**",
			"Params": [],
			"Summary": "La commande **WEB STOP SERVER** stoppe le serveur Web de l'application 4D sur laquelle elle a été exécutée (4D ou 4D Server)."
		},
		"WEB Validate digest": {
			"Syntax": "**WEB Validate digest** ( *nomUtilisateur* ; *motDePasse* ) : Boolean",
			"Params": [
				[
					"nomUtilisateur",
					"Text",
					"->",
					"Nom de l'utilisateur"
				],
				[
					"motDePasse",
					"Text",
					"->",
					"Mot de passe de l'utilisateur"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai=Authentification correcte, Faux=Echec de l’authentification"
				]
			],
			"Summary": "La commande **WEB Validate digest** permet de vérifier la validité des identifiants (nom et mot de passe) fournis par un utilisateur se connectant au serveur Web."
		},
		"Window kind": {
			"Syntax": "**Window kind** {( *fenêtre* )} : Integer",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de la fenêtre ou Fenêtre de premier plan du process courant si omis"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Type de la fenêtre"
				]
			],
			"Summary": "La commande **Window kind** retourne le type de fenêtre 4D dont vous avez passé la référence dans *fenêtre*."
		},
		"WINDOW LIST": {
			"Syntax": "**WINDOW LIST** ( *fenêtres* {; *} )",
			"Params": [
				[
					"fenêtres",
					"Array",
					"<-",
					"Tableau des numéros de référence des fenêtres"
				],
				[
					"*",
					"Opérateur",
					"->",
					"Si omis, ignorer fenêtres flottantes Si spécifié, tenir compte des fenêtres flottantes"
				]
			],
			"Summary": "La commande **WINDOW LIST** remplit le tableau *fenêtres* avec les numéros de référence des fenêtres actuellement ouvertes dans tous les process (process moteur et process utilisateur)."
		},
		"Window process": {
			"Syntax": "**Window process** {( *fenêtre* )} : Integer",
			"Params": [
				[
					"fenêtre",
					"Integer",
					"->",
					"Numéro de référence de fenêtre"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Numéro de référence de process"
				]
			],
			"Summary": "La commande **Window process** retourne le numéro du process qui exécute la fenêtre dont le numéro de référence est passé dans *fenêtre*."
		},
		"Windows Alt down": {
			"Syntax": "**Windows Alt down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Windows Alt ou Etat de la touche Macintosh Option"
				]
			],
			"Summary": "**Windows Alt down** retourne Vrai si la touche **Alt** Windows est enfoncée."
		},
		"Windows Ctrl down": {
			"Syntax": "**Windows Ctrl down**  : Boolean",
			"Params": [
				[
					"Résultat",
					"Boolean",
					"<-",
					"Etat de la touche Ctrl Windows ou Etat de la touche Commande Macintosh"
				]
			],
			"Summary": "**Windows Ctrl down** retourne Vrai si la touche **Ctrl** Windows est enfoncée."
		},
		"WRITE PICTURE FILE": {
			"Syntax": "**WRITE PICTURE FILE** ( *nomFichier* ; *image* {; *codec*} )",
			"Params": [
				[
					"nomFichier",
					"Text",
					"->",
					"Nom ou chemin d’accès complet du fichier à écrire, ou chaîne vide"
				],
				[
					"image",
					"Picture",
					"->",
					"Champ ou variable image à écrire"
				],
				[
					"codec",
					"Text",
					"->",
					"Identifiant de codec d'image"
				]
			],
			"Summary": "La commande **WRITE PICTURE FILE** vous permet de sauvegarder dans un fichier sur disque l’image passée dans le paramètre *image*, au format défini par *codec*."
		},
		"XML DECODE": {
			"Syntax": "**XML DECODE** ( *valeurXML* ; *var4D* )",
			"Params": [
				[
					"valeurXML",
					"Text",
					"->",
					"Valeur de type texte provenant d’une structure XML"
				],
				[
					"var4D",
					"Field, Variable",
					"<-",
					"Variable ou champ 4D devant recevoir la valeur XML convertie"
				]
			],
			"Summary": "La commande **XML DECODE** convertit une valeur stockée en tant que chaîne XML en une valeur 4D typée."
		},
		"XML GET ERROR": {
			"Syntax": "**XML GET ERROR** ( *refElément* ; *texteErreur* {; *ligne* {; *colonne*}} )",
			"Params": [
				[
					"refElément",
					"Text",
					"->",
					"Référence d’élément XML"
				],
				[
					"texteErreur",
					"Variable",
					"<-",
					"Texte de l’erreur"
				],
				[
					"ligne",
					"Variable",
					"<-",
					"Numéro de ligne"
				],
				[
					"colonne",
					"Variable",
					"<-",
					"Numéro de colonne"
				]
			],
			"Summary": "La commande **XML GET ERROR** retourne dans le paramètre *texteErreur* la description de l’erreur rencontrée lors du traitement de l’élément XML désigné par le paramètre *refElément*."
		},
		"XML GET OPTIONS": {
			"Syntax": "**XML GET OPTIONS** ( refElément | document ; *sélecteur* ; *valeur* {; *sélecteur2* ; *valeur2* ; ... ; *sélecteurN* ; *valeurN*} )",
			"Params": [
				[
					"refElément &#124; document",
					"Texte",
					"->",
					"Référence d’élément XML racine ou<br/>Référence de document ouvert"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Option à lire"
				],
				[
					"valeur",
					"Integer",
					"<-",
					"Valeur courante de l’option"
				]
			],
			"Summary": "La commande **XML GET OPTIONS** permet de lire la valeur d’un ou plusieurs paramètre(s) XML définis pour la session courante et l’utilisateur courant."
		},
		"XML SET OPTIONS": {
			"Syntax": "**XML SET OPTIONS** ( refElément | document ; *sélecteur* ; *valeur* {; *sélecteur2* ; *valeur2* ; ... ; *sélecteurN* ; *valeurN*} )",
			"Params": [
				[
					"refElément &#124; document",
					"Texte",
					"->",
					"Référence d’élément XML racine ou<br/>Référence de document ouvert"
				],
				[
					"sélecteur",
					"Integer",
					"->",
					"Option à définir"
				],
				[
					"valeur",
					"Integer",
					"->",
					"Valeur de l'option"
				]
			],
			"Summary": "La commande **XML SET OPTIONS** permet de modifier la valeur d’une ou plusieurs option(s) XML pour la structure passée dans le premier paramètre."
		},
		"Year of": {
			"Syntax": "**Year of** ( *date* ) : Integer",
			"Params": [
				[
					"date",
					"Date",
					"->",
					"Date dont vous voulez extraire l'année"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre indiquant l'année de date"
				]
			],
			"Summary": "**Year of** retourne un nombre indiquant l'année de *laDate*."
		},
		"cs": {
			"Syntax": "**cs** : Object",
			"Params": [
				[
					"classStore",
					"Object",
					"<-",
					"Class store utilisateur utilisateurs pour le projet ou le composant"
				]
			],
			"Summary": "retourne le class store utilisateur pour le projet ou le composant courant"
		},
		"4D": {
			"Syntax": "**4D** : Object",
			"Params": [
				[
					"classStore",
					"Object",
					"<-",
					"Class store 4D"
				]
			],
			"Summary": "retourne le class store des classes 4D intégrées disponibles"
		},
		"WP Add picture": {
			"Syntax": "**WP Add picture** ( *wpDoc* {; *picture*} ) : Object<br/>**WP Add picture** ( *wpDoc* {; *picturePath*} ) : Object<br/>**WP Add picture** ( *wpDoc* {; *pictureFileObj*} ) : Object",
			"Params": [
				[
					"wpDoc",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"picture",
					"Picture",
					"->",
					"Image 4D"
				],
				[
					"picturePath",
					"Text",
					"->",
					"Chemin de l'image"
				],
				[
					"pictureFileObj",
					"4D.File",
					"->",
					"Objet 4D.File représentant un fichier image"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet référençant l'image"
				]
			],
			"Summary": "ancre l'image passée en paramètre à un emplacement fixe dans le *wpDoc* spécifié et retourne sa référence."
		},
		"WP DELETE SECTION": {
			"Syntax": "**WP DELETE SECTION** ( *section* )<br/> **WP DELETE SECTION** ( *wpDoc* ; *indexNumber* {; *count*} )",
			"Params": [
				[
					"section",
					"Object",
					"->",
					"Section 4D Write Pro"
				],
				[
					"wpDoc",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"indexNumber",
					"Integer",
					"->",
					"Index de la section à supprimer"
				],
				[
					"count",
					"Integer",
					"->",
					"Nombre de sections à supprimer"
				]
			],
			"Summary": "supprime l'objet *section* transmis, ou supprime une ou plusieurs sections à partir de *indexNumber* et en fonction du *count* transmis"
		},
		"WP DELETE SUBSECTION": {
			"Syntax": "**WP DELETE SUBSECTION** ( *wpSection* ; *subSectionType* )<br/>**WP DELETE SUBSECTION** ( *subSection* )",
			"Params": [
				[
					"wpSection",
					"Object",
					"->",
					"Section 4D Write Pro"
				],
				[
					"subSectionType",
					"Integer",
					"->",
					"Type de sous-section (wk first page, wk left page, or wk right page)"
				],
				[
					"subSection",
					"Object",
					"->",
					"Sous-section 4D Write Pro"
				]
			],
			"Summary": "supprime les éléments de sous-section *subSectionType* de la section *wpSection* 4D Write Pro, ou supprime directement la *subSection*"
		},
		"WP EXPORT DOCUMENT": {
			"Syntax": "**WP EXPORT DOCUMENT** ( *wpDoc* ; *filePath* {; *format* {; *option*}} )<br/>**WP EXPORT DOCUMENT** ( *wpDoc* ; *fileObj* {; *format* {; *option*}} )",
			"Params": [
				[
					"wpDoc",
					"Object",
					"->",
					"Variable 4D Write Pro"
				],
				[
					"filePath",
					"Text",
					"->",
					"Chemin du fichier d'export"
				],
				[
					"fileObj",
					"4D.File",
					"->",
					"Objet du fichier à exporter"
				],
				[
					"format",
					"Integer",
					"->",
					"Format de sortie du document (ex : .docx, .pdf, etc.)"
				],
				[
					"option",
					"Object, Integer",
					"->",
					"Options d'export, qui peuvent varier en fonction du format choisi."
				]
			],
			"Summary": "exporte l'objet 4D Write Pro *wpDoc* vers un document sur disque selon le paramètre *filePath* ou *fileObj* ainsi que tout paramètre optionnel."
		},
		"WP EXPORT VARIABLE": {
			"Syntax": "**WP EXPORT VARIABLE** ( *wpDoc* ; *destination* ; *format* {; *option*} )",
			"Params": [
				[
					"wpDoc",
					"Object",
					"->",
					"Variable 4D Write Pro"
				],
				[
					"destination",
					"Text, Blob",
					"->",
					"Variable pour recevoir les contenus exportés"
				],
				[
					"format",
					"Integer",
					"->",
					"Format de sortie variable"
				],
				[
					"option",
					"Object, Integer",
					"->",
					"Options d'export"
				]
			],
			"Summary": "The **WP EXPORT VARIABLE** command exports the *wpDoc* 4D Write Pro object to the 4D *destination* variable in the specified *format*."
		},
		"WP Get attributes": {
			"Syntax": "**WP Get attributes** ( *targetObj* ; *attribName* ; *attribValue* {; *attribName2* ; *attribValue2* ; ... ; *attribNameN* ; *attribValueN*} )<br/>**WP Get attributes** ( *targetObj* ; *attribColl* ) : Object",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"attribName",
					"Text",
					"->",
					"Name of attribute to get"
				],
				[
					"attribValue",
					"Text, Number, Array, Collection, Picture, Date",
					"<-",
					"Current value of attribute for the target"
				],
				[
					"attribColl",
					"Collection",
					"->",
					"Collection of attribute names to get"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Attribute names and values"
				]
			],
			"Summary": "returns the value of any attribute in a 4D Write Pro range, header, body, footer, table, or document."
		},
		"WP Import document": {
			"Syntax": "**WP Import document** ( *filePath* {; *option*} ) : Object<br/>**WP Import document** ( *fileObj* {; *option*} ) : Object",
			"Params": [
				[
					"filePath",
					"Text",
					"->",
					"Path to: a 4D Write document (.4w7 or .4wt) or a 4D Write Pro document (.4wp) or a .docx document (.docx)"
				],
				[
					"fileObj",
					"4D.File",
					"->",
					"File object to import"
				],
				[
					"option",
					"Integer, Object",
					"->",
					"(Integer) Import option for HTML expressions, (object) Import options for .docx document"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"4D Write Pro object"
				]
			],
			"Summary": "converts an existing 4D Write Pro / 4D Write document (.4wp, .4w7 or .4wt) or MS Word document (.docx) to a new 4D Write Pro object."
		},
		"WP Insert break": {
			"Syntax": "**WP Insert break** ( *targetObj* ; *breakType* ; *mode* {; *rangeUpdate*} ) : Object",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"breakType",
					"Integer",
					"->",
					"Type de rupture à insérer"
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode d'insertion"
				],
				[
					"rangeUpdate",
					"Integer",
					"->",
					"Mode de mise à jour de la plage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage de texte du caractère de rupture"
				]
			],
			"Summary": "insère une nouvelle rupture du type *breakType* dans le *targetObj* conformément aux paramètres *mode* d'insertion et *rangeUpdate* spécifiés, et retourne la plage de texte du caractère de rupture"
		},
		"WP Insert document body": {
			"Syntax": "**WP Insert document body** ( *targetObj* ; *wpDoc* ; *mode* {; *rangeUpdate*} ) : Object",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"wpDoc",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode d'insertion"
				],
				[
					"rangeUpdate",
					"Integer",
					"->",
					"Mode de mise à jour de la plage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Text range object referencing the inserted document body"
				]
			],
			"Summary": "inserts the body of the *wpDoc* document into the specified *targetObj* according to the passed insertion *mode* and *rangeUpdate* parameters, and it returns the range of the inserted document body."
		},
		"WP Insert formula": {
			"Syntax": "**WP Insert formula** ( *targetObj* ; *formula* ; *mode* {; *rangeUpdate*} ) : Object",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"formula",
					"Object",
					"->",
					"Objet de formule OU Objet avec des propriétés de formule et de nom"
				],
				[
					"mode",
					"Number",
					"->",
					"Mode d'insertion"
				],
				[
					"rangeUpdate",
					"Number",
					"->",
					"Inclut ou exclut le contenu inséré dans la plage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet de plage de texte représentant le résultat de la formule"
				]
			],
			"Summary": "insère une *formule* dans *targetObj* selon le *mode d'insertion* spécifié et retourne la plage de texte résultante."
		},
		"WP Insert picture": {
			"Syntax": "**WP Insert picture** ( *targetObj* ; *picture* ; *mode* {; *rangeUpdate*} ): Object<br/>**WP Insert picture** ( *targetObj* ; *pictureFileObj*; *mode* {; *rangeUpdate*}): Object",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"picture",
					"Picture",
					"->",
					"Champ image ou variable, ou chemin vers le fichier image sur le disque"
				],
				[
					"pictureFileObj",
					"4D.File",
					"->",
					"Un objet Fichier représentant un fichier image."
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode d'insertion"
				],
				[
					"rangeUpdate",
					"Integer",
					"->",
					"Mode de mise à jour de la plage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet référençant l'image"
				]
			],
			"Summary": "insère *picture* ou *pictureFileObj* dans le *targetObj* spécifié en fonction des paramètres *mode* d'insertion et *rangeUpdate*, et retourne une référence à l'élément picture."
		},
		"WP RESET ATTRIBUTES": {
			"Syntax": "**WP RESET ATTRIBUTES** ( *targetObj* ; *attribName* {; *attribName2* ; ... ; *attribNameN*} )<br/> **WP RESET ATTRIBUTES** ( *sectionOrSubsection* {; *attribName* }{; *attribName2* ; ... ; *attribNameN*} )<br/>**WP RESET ATTRIBUTES** ( *targetObj* ; *attribColl* )<br/> **WP RESET ATTRIBUTES** ( *sectionOrSubsection* {; *attribColl*})",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"sectionOrSubsection",
					"Object",
					"->",
					"Section ou sous-section d'un document 4D Write Pro"
				],
				[
					"attribName",
					"Text",
					"->",
					"Nom d'attribut(s) à supprimer"
				],
				[
					"attribColl",
					"Collection",
					"->",
					"Collection d'attributs à supprimer"
				]
			],
			"Summary": "permet de réinitialiser la valeur d'un ou plusieurs attributs dans la plage, l'élément ou le document passé en paramètre."
		},
		"WP SET ATTRIBUTES": {
			"Syntax": "**WP SET ATTRIBUTES** ( *targetObj* ; *attribName* ; *attribValue* {; *attribName2* ; *attribValue2* ; ... ; *attribNameN* ; *attribValueN*} )<br/>**WP SET ATTRIBUTES** ( *targetObj* ; *attribObj* )",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"attribName",
					"Text",
					"->",
					"Nom de l'attribut à définir"
				],
				[
					"attribValue",
					"Text, Number, Object, Collection, Picture, Date",
					"->",
					"Nouvelle valeur d'attribut"
				],
				[
					"attribObj",
					"Object",
					"->",
					"Objet contenant les noms des attributs et leurs valeurs correspondantes à définir"
				]
			],
			"Summary": "permet de définir la valeur de n'importe quel attribut d'une plage, d'un élément, d'un document."
		},
		"WP Table append row": {
			"Syntax": "**WP Table append row** ( *tableRef* ; *value* {; *value2* ; ... ; *valueN*} )  : Object<br/>**WP Table append row** ( *tableRef* ; *valueColl* ) : Object",
			"Params": [
				[
					"tableRef",
					"Object",
					"->",
					"Référence du tableau"
				],
				[
					"value",
					"Text, Number, Time, Date, Picture, Object",
					"->",
					"Valeur(s) à définir dans la ligne"
				],
				[
					"valueColl",
					"Collection",
					"->",
					"Collection de valeurs à définir dans la ligne"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet plage ligne"
				]
			],
			"Summary": "appends one row to the *tableRef* table, fills it with *value*(s) or a *valueColl* collection, and returns the corresponding row range object."
		},
		"WP Bookmark range": {
			"Syntax": "**WP Bookmark range** ( *docWP* ; *nomSignet* ) -> Résultat",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"nomSignet",
					"Text",
					"->",
					"Nom du signet dont vous souhaitez récupérer la plage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage du signet"
				]
			],
			"Summary": "La commande **WP Bookmark range** retourne un objet de type plage (objPlage) contenant la plage associée au signet nommé *nomSignet* dans le document *docWP*."
		},
		"WP COMPUTE FORMULAS": {
			"Syntax": "**WP COMPUTE FORMULAS** ( *objCible* )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				]
			],
			"Summary": "La commande **WP COMPUTE FORMULAS** évalue les formules dans *objCible*."
		},
		"WP DELETE BOOKMARK": {
			"Syntax": "**WP DELETE BOOKMARK** ( *docWP* ; *nomSignet* )",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"nomSignet",
					"Text",
					"->",
					"Nom du signet à supprimer"
				]
			],
			"Summary": "la commande **WP DELETE BOOKMARK** supprime de *docWP* le signet nommé *nomSignet*."
		},
		"WP DELETE FOOTER": {
			"Syntax": "**WP DELETE FOOTER** ( *wpSection* )",
			"Params": [
				[
					"wpSection",
					"Object",
					"->",
					"Section ou sous-section 4D Write Pro"
				]
			],
			"Summary": "La commande **WP DELETE FOOTER** supprime l'élément pied associé à la section ou à la sous-section définie par le paramètre *wpSection*."
		},
		"WP DELETE HEADER": {
			"Syntax": "**WP DELETE HEADER** ( *wpSection* )",
			"Params": [
				[
					"wpSection",
					"Object",
					"->",
					"Section ou sous-section 4D Write Pro"
				]
			],
			"Summary": "La commande **WP DELETE HEADER** supprime l'élément en-tête associé à la section ou à la sous-section définie par le paramètre *wpSection*."
		},
		"WP DELETE PICTURE": {
			"Syntax": "**WP DELETE PICTURE** ( *objImage* )",
			"Params": [
				[
					"objImage",
					"Object",
					"->",
					"Objet image (en ligne ou ancrée)"
				]
			],
			"Summary": "La commande **WP DELETE PICTURE** supprime l'image définie par le paramètre *objImage*."
		},
		"WP DELETE STYLE SHEET": {
			"Syntax": "**WP DELETE STYLE SHEET** ( *objFeuilleStyle* ) | (*docWP* ; *nomFeuilleStyle* )",
			"Params": [
				[
					"objFeuilleStyle",
					"Object",
					"->",
					"Objet feuille de style"
				],
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"nomFeuilleStyle",
					"Text",
					"->",
					"Nom de la feuille de style"
				]
			],
			"Summary": "La commande **WP DELETE STYLE SHEET** retire la feuille de style de paragraphe ou de caractère désignée du document courant."
		},
		"WP DELETE TEXT BOX": {
			"Syntax": "**WP DELETE TEXT BOX** ( *textBox* )",
			"Params": [
				[
					"textBox",
					"Object",
					"->",
					"Zone de texte"
				]
			],
			"Summary": "La commande **WP DELETE TEXT BOX** supprime la zone de texte définie par le paramètre *textBox* ."
		},
		"WP Find all": {
			"Syntax": "**WP Find all** ( *objCible* ; *valeurRecherche* ; *conditionRecherche* {; *remplacerValeur*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"valeurRecherche",
					"Text",
					"->",
					"Valeur à rechercher"
				],
				[
					"conditionRecherche",
					"Integer",
					"->",
					"Règle(s) de recherche"
				],
				[
					"remplacerValeur",
					"Text",
					"->",
					"Chaîne de remplacement"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets plage"
				]
			],
			"Summary": "La commande **WP Find all** recherche *valeurRecherche* dans *objCible* en utilisant les options de *conditionRecherche*."
		},
		"WP Find next": {
			"Syntax": "**WP Find next** ( *objCible* ; *rechercherAprès* ; *rechercherValeur* ; *conditionRecherche* {; *remplacerValeur*} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"rechercherAprès",
					"Object",
					"->",
					"Plage après laquelle la recherche va démarrer"
				],
				[
					"rechercherValeur",
					"Text",
					"->",
					"Rechercher une valeur"
				],
				[
					"conditionRecherche",
					"Integer",
					"->",
					"Règle(s) de recherche"
				],
				[
					"remplacerValeur",
					"Text",
					"->",
					"Chaîne de remplacement"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage de la valeur trouvée/remplacée"
				]
			],
			"Summary": "La commande **WP Find next** recherche le paramètre *objCible,* après la plage rechercherAprès, pour le paramètre rechercherValeur fondé sur conditionRecherche."
		},
		"WP Find previous": {
			"Syntax": "**WP Find previous** ( *objCible* ; *rechercherAprès* ; *rechercherValeur* ; *conditionRecherche* {; *remplacerValeur*} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"rechercherAprès",
					"Object",
					"->",
					"Plage avant laquelle la recherche va commencer"
				],
				[
					"rechercherValeur",
					"Text",
					"->",
					"Rechercher la valeur"
				],
				[
					"conditionRecherche",
					"Integer",
					"->",
					"Règle(s) de recherche"
				],
				[
					"remplacerValeur",
					"Text",
					"->",
					"Chaîne de remplacement"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage de la valeur trouvée/remplacée"
				]
			],
			"Summary": "La commande **WP Find previous** recherche le paramètre *objCible,* avant la plage rechercherAvant, pour le paramètre rechercherValeur fondé sur conditionRecherche."
		},
		"WP FREEZE FORMULAS": {
			"Syntax": "**WP FREEZE FORMULAS** ( *objCible* {; *recompute*} )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"recompute",
					"Integer",
					"->",
					"Option to control recomputing"
				]
			],
			"Summary": "La commande **WP FREEZE FORMULAS** \"fige\" le contenu des formules dans objCible."
		},
		"WP Get body": {
			"Syntax": "**WP Get body** ( *docWP* ) -> Résultat",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Corps de 4D Write Pro"
				]
			],
			"Summary": "La commande **WP Get body** retourne la partie corps (*body*) du document 4D Write Pro *docWP*."
		},
		"WP GET BOOKMARKS": {
			"Syntax": "**WP GET BOOKMARKS** ( *docWP* ; *tabNomsSignets* )",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"tabNomsSignets",
					"Tableau texte",
					"&#x1F858;",
					"Tableau des noms de signets"
				]
			],
			"Summary": "La commande **WP GET BOOKMARKS** retourne un tableau contenant le nom de tous les signets définis dans le document *docWP*."
		},
		"WP Get breaks": {
			"Syntax": "**WP Get breaks** ( *objCible* {; *typeSaut*} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"typeSaut",
					"Integer",
					"->",
					"Type de sauts à retourner"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de plages"
				]
			],
			"Summary": "La commande **WP Get breaks** retourne la collection de tous les sauts insérés dans *objCible*."
		},
		"WP Get data context": {
			"Syntax": "**WP Get data context** ( *wpDoc* ) -> Résultat",
			"Params": [
				[
					"wpDoc",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet contexte de données"
				]
			],
			"Summary": "La commande **WP Get data context** returne le contexte de données du document wpDoc\\[#/descv\\]."
		},
		"WP Get element by ID": {
			"Syntax": "**WP Get element by ID** ( *docWP* ; *ID* ) -> Résultat",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"ID",
					"Text",
					"->",
					"Identifiant de l'élément à retrouver"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Élément 4D Write Pro"
				]
			],
			"Summary": "La commande **WP Get element by ID** retourne un objet contenant l'élément de *docWP* passé dans le paramètre *ID*."
		},
		"WP Get elements": {
			"Syntax": "**WP Get elements** ( *objCible* {; *typeElement*} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"typeElement",
					"Integer",
					"->",
					"Choix du type d'éléments à retrouver"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection contenant des références d'éléments"
				]
			],
			"Summary": "La commande **WP Get elements** retourne une collection d'objets contenant des paragraphes, images, tableaux et/ou lignes de tableaux."
		},
		"WP Get footer": {
			"Syntax": "**WP Get footer** ( *objCible* ) | (*docWP* ; *indexSection* {; *typeSousSection*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément section/sous-section 4D Write Pro"
				],
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"indexSection",
					"Integer",
					"->",
					"Numéro de la section"
				],
				[
					"typeSousSection",
					"Integer",
					"->",
					"Type de sous-section (wk first page, wk left page ou wk right page)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Pied de page 4D Write Pro"
				]
			],
			"Summary": "La commande **WP Get footer** retourne le pied de page associé à la plage *objCible* ou à la section *indexSection* du document 4D Write Pro *docWP*."
		},
		"WP Get formulas": {
			"Syntax": "**WP Get formulas** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de formules"
				]
			],
			"Summary": "La commande **WP Get formulas** retoune une collection de toutes les formulas définies dans *objCible*."
		},
		"WP Get frame": {
			"Syntax": "**WP Get frame** ( {* ;} *zoneWP* {; *textBoxID*} ) -> Résultat",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, zoneWP est un nom d'objet de formulaire (chaîne). Si omis, zoneWP est un champ ou une variable objet"
				],
				[
					"zoneWP",
					"Text",
					"->",
					"Nom d'objet de formulaire (si * spécifié) ou champ ou variable objet 4D Write Pro (si * omis)"
				],
				[
					"textBoxID",
					"Chaîne",
					"&#x1F858;",
					"ID of the text box (only filled if a text box has the focus)"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Cadre dans lequel se trouve le curseur"
				]
			],
			"Summary": "La commande **WP Get frame** retourne le cadre de la zone 4D Write Pro *zoneWP* dans lequel se trouve actuellement le curseur."
		},
		"WP Get header": {
			"Syntax": "**WP Get header** ( *objCible* ) | (*docWP* ; *indexSection* {; *typeSousSection*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément section/sous-section 4D Write Pro"
				],
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"indexSection",
					"Integer",
					"->",
					"Numéro de la section"
				],
				[
					"typeSousSection",
					"Integer",
					"->",
					"Type de sous-section (wk first page, wk left page ou wk right page)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"En-tête 4D Write Pro"
				]
			],
			"Summary": "La commande **WP Get header** retourne l'en-tête associé à *objCible* ou à la section *indexSection* du document 4D Write Pro *docWP*."
		},
		"WP Get links": {
			"Syntax": "**WP Get links** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de liens"
				]
			],
			"Summary": "La commande **WP Get links** retourne la collection de tous les liens définis dans le paramètre *objCible*."
		},
		"WP Get page count": {
			"Syntax": "**WP Get page count** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Document ou section 4D Write Pro"
				],
				[
					"Résultat",
					"Integer",
					"<-",
					"Nombre de pages dans le document"
				]
			],
			"Summary": "La commande **WP Get page count** retourne le nombre total de pages passées dans le paramètre *objCible*."
		},
		"WP Get position": {
			"Syntax": "**WP Get position** ( *objCible* {; *presentation*} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"presentation",
					"Integer",
					"->",
					"Mise en page de document 4D Write Pro utilisée pour la présentation :<br/>0 (par défaut) = mise en page 4D Write Pro,<br/>1 = HTML WYSIWYG"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Informations sur la position"
				]
			],
			"Summary": "La commande **WP Get position** retourne un objet décrivant la position courante de *objCible*."
		},
		"WP Get section": {
			"Syntax": "**WP Get section** ( *objCible* ) | (*docWP* ; *indexSection* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément"
				],
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"indexSection",
					"Integer",
					"->",
					"Index section"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Section 4D Write Pro"
				]
			],
			"Summary": "La commande **WP Get section** retourne soit la première section intersectée par la plage ou par l'élément *objCible*, soit l'*indexSection* spécifié du document *docWP*."
		},
		"WP Get sections": {
			"Syntax": "**WP Get sections** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou document 4D Write Pro"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection de toutes les sections contenues dans objCible"
				]
			],
			"Summary": "La commande **WP Get sections** retourne une collection de toutes les sections définies dans le paramètre *objCible*."
		},
		"WP Get style sheet": {
			"Syntax": "**WP Get style sheet** ( *docWP* ; *nomFeuilleStyle* ) -> Résultat",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"nomFeuilleStyle",
					"Text",
					"->",
					"Nom de la feuille de style"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet feuille de style"
				]
			],
			"Summary": "La commande **WP Get style sheet** retourne l'objet feuille de style désigné par le *nomFeuilleStyle*."
		},
		"WP Get style sheets": {
			"Syntax": "**WP Get style sheets** ( *docWP* ; *type* ) -> Résultat",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"type",
					"Integer",
					"->",
					"Type de la feuille de style"
				],
				[
					"Résultat",
					"Collection",
					"<-",
					"Collection d'objets feuille de style"
				]
			],
			"Summary": "La commande **WP Get style sheets** retourne une collection de tous les objets feuille de style du *type* défini dans *docWP*."
		},
		"WP Get subsection": {
			"Syntax": "**WP Get subsection** ( *objCible* ) | (*wpSection* ; *typeSousSection* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément"
				],
				[
					"wpSection",
					"Object",
					"->",
					"Section 4D Write Pro"
				],
				[
					"typeSousSection",
					"Integer",
					"->",
					"Type de sous-section (wk first page, wk left page ou wk right page)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Sous-section"
				]
			],
			"Summary": "La commande **WP Get subsection** retourne soit la première sous-section intersectée par la plage ou par l'élément *objCible*, soit la sous-section *typeSousSection* spécifiée de la section *wpSection*."
		},
		"WP Get text": {
			"Syntax": "**WP Get text** ( *objCible* {; *expressions*} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"expressions",
					"Number",
					"->",
					"Instructions pour l'évaluation de l'expression"
				],
				[
					"Résultat",
					"Text",
					"<-",
					"Texte de objCible"
				]
			],
			"Summary": "La commande **WP Get text** récupère le contenu textuel d'un document 4D Write Pro dans l'*objCible* spécifié."
		},
		"WP Get view properties": {
			"Syntax": "**WP Get view properties** ( * ; *zoneWP* ) -> Résultat",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, zoneWP est un nom d'objet de formulaire (chaîne). Si omis, zoneWP est un champ ou une variable objet"
				],
				[
					"zoneWP",
					"Text, Object",
					"->",
					"Nom d'objet de formulaire (si * spécifié) ou champ ou variable objet 4D Write Pro (si * omis)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Attributs vue courants"
				]
			],
			"Summary": "La commande **WP Get view properties** retourne les attributs vue courants de la zone 4D Write Pro identifiés par *zoneWP*."
		},
		"WP IMPORT STYLE SHEETS": {
			"Syntax": "**WP IMPORT STYLE SHEETS** ( *docCible* ; *docSource* )",
			"Params": [
				[
					"docCible",
					"Object",
					"->",
					"Document 4D Write Pro qui reçoit les feuilles de style"
				],
				[
					"docSource",
					"Object",
					"->",
					"Document 4D Write Pro contenant les feuilles de style à lire"
				]
			],
			"Summary": "La commande **WP IMPORT STYLE SHEETS** importe toutes les feuilles de style du *docSource* vers *docCible*."
		},
		"WP Insert table": {
			"Syntax": "**WP Insert table** ( *objCible* ; *mode* {; *miseAJourPlage* {; *nbCols* {; *nbLignes*}}} ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"mode",
					"Integer",
					"->",
					"Mode d'insertion"
				],
				[
					"miseAJourPlage",
					"Integer",
					"->",
					"Mode de mise à jour de la plage de sélection"
				],
				[
					"nbCols",
					"Integer",
					"->",
					"Nombre de colonnes à créer dans le tableau"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à créer dans le tableau"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet listant les propriétés du tableau"
				]
			],
			"Summary": "La commande **WP Insert table** insère un nouveau tableau dans la plage *objCible* en fonction du *mode* d'insertion spécifié et retourne le nouvel objet correspondant."
		},
		"WP Is font style supported": {
			"Syntax": "**WP Is font style supported** ( *objCible* ; *stylePoliceWP* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément"
				],
				[
					"stylePoliceWP",
					"Integer",
					"->",
					"Constante de style de police"
				],
				[
					"Résultat",
					"Boolean",
					"<-",
					"Vrai si le style est pris en charge dans tout ou partie de objCible, Faux sinon"
				]
			],
			"Summary": "La commande **WP Is font style supported** retourne Vrai si le style *stylePoliceWP* est pris en charge par au moins une partie du texte inclus dans *objCible*."
		},
		"WP NEW BOOKMARK": {
			"Syntax": "**WP NEW BOOKMARK** ( *objCible* ; *nomSignet* )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément"
				],
				[
					"nomSignet",
					"Text",
					"->",
					"Nom du signet à créer"
				]
			],
			"Summary": "La commande **WP NEW BOOKMARK** crée un nouveau signet nommé *nomSignet* basé sur *objPlage* du document parent."
		},
		"WP New footer": {
			"Syntax": "**WP New footer** ( *wpSection* ) -> Résultat",
			"Params": [
				[
					"wpSection",
					"Object",
					"->",
					"Section ou sous-section 4D Write Pro"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Pied de page 4D Write Pro"
				]
			],
			"Summary": "La commande **WP New footer** crée et retourne le pied associé à la section ou à la sous-section définie par le paramètre *wpSection* ."
		},
		"WP New header": {
			"Syntax": "**WP New header** ( *wpSection* ) -> Résultat",
			"Params": [
				[
					"wpSection",
					"Object",
					"->",
					"Section ou sous-section 4D Write Pro"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"En-tête 4D Write Pro"
				]
			],
			"Summary": "La commande **WP New header** crée et retourne l'en-tête associé à la section ou à la sous-section définie par le paramètre *wpSection* ."
		},
		"WP New style sheet": {
			"Syntax": "**WP New style sheet** ( *docWP* ; *typeFeuilleStyle* ; *nomFeuilleStyle* ) -> Résultat",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"typeFeuilleStyle",
					"Integer",
					"->",
					"Type de la feuille de style"
				],
				[
					"nomFeuilleStyle",
					"Text",
					"->",
					"Nom de la feuille de style"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet feuille de style"
				]
			],
			"Summary": "La commande **WP New style sheet** crée un nouvel objet feuille de style (vide) pour le *docWP* désigné."
		},
		"WP New subsection": {
			"Syntax": "**WP New subsection** ( *wpSection* ; *typeSousSection* ) -> Résultat",
			"Params": [
				[
					"wpSection",
					"Object",
					"->",
					"Section 4D Write Pro"
				],
				[
					"typeSousSection",
					"Integer",
					"->",
					"Type de sous-section (wk first page, wk left page ou wk right page)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvelle sous-section"
				]
			],
			"Summary": "La commande **WP New subsection** crée et retourne une nouvelle sous-section de type *typeSousSection* dans la section 4D Write Pro *wpSection*."
		},
		"WP New text box": {
			"Syntax": "**WP New text box** ( *wpDoc* ; *pageNum* ) -> Résultat",
			"Params": [
				[
					"wpDoc",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"pageNum",
					"Number",
					"->",
					"Numéro de page où ancrer la zone de texte"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet zone de texte"
				]
			],
			"Summary": "La commande **WP New text box** crée et renvoie un nouvel objet zone de texte dans la page pageNum de wpDoc."
		},
		"WP New": {
			"Syntax": "**WP New** {( *source* {; *option*} )} -> Résultat",
			"Params": [
				[
					"source",
					"Text, Blob, Object",
					"->",
					"Chaîne : Source HTML,<br/>BLOB : Blob document 4D Write (.4w7/.4wt) ou document 4D Write Pro (.4wp),<br/>Objet : Objet plage ou élément 4D Write Pro"
				],
				[
					"option",
					"Integer",
					"->",
					"Option d'import des expressions HTML"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet 4D Write Pro"
				]
			],
			"Summary": "La commande **WP New** crée et retourne un nouvel objet 4D Write Pro."
		},
		"WP Paragraph range": {
			"Syntax": "**WP Paragraph range** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage définissant uniquement les paragraphes"
				]
			],
			"Summary": "La commande **WP Paragraph range** retourne un objet plage qui référence uniquement les paragraphes qui intersectent l'*objCible* que vous avez passé en paramètre."
		},
		"WP Picture range": {
			"Syntax": "**WP Picture range** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage contenant uniquement les images"
				]
			],
			"Summary": "La commande **WP Picture range** retourne un objet plage qui référence uniquement les images contenues dans *objCible* que vous avez passé en paramètre."
		},
		"WP PRINT": {
			"Syntax": "**WP PRINT** ( *docWP* {; *optionsImpr*} )",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"optionsImpr",
					"Integer",
					"->",
					"Options d'impression pour le document 4D Write Pro"
				]
			],
			"Summary": "La commande **WP PRINT** lance une tâche d'impression pour le document 4D Write Pro désigné par *docWP*, ou ajoute le document dans la tâche d'impression courante si elle est appelée entre les commandes OPEN PRINTING JOB et CLOSE PRINTING JOB."
		},
		"WP SELECT": {
			"Syntax": "**WP SELECT** ( {{* ;} *zoneWP*;} {*objCible*} {; *débutPlage* ; *finPlage*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, zoneWP est un nom d'objet de formulaire (chaîne). Si omis, zoneWP est un champ ou une variable objet (document)"
				],
				[
					"zoneWP",
					"Text, Object",
					"->",
					"Nom d'objet de formulaire (si * spécifié) ou champ ou variable objet 4D Write Pro (si * omis)"
				],
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"débutPlage",
					"Integer",
					"->",
					"Position du début de la plage texte"
				],
				[
					"finPlage",
					"Integer",
					"->",
					"Position de la fin de la plage texte"
				]
			],
			"Summary": "La commande **WP SELECT** crée une nouvelle sélection dans la zone de 4D Write Pro *zoneWP*, basée sur l'*objCible* ou la plage définie par *débutPlage* et *finPlage*."
		},
		"WP Selection range": {
			"Syntax": "**WP Selection range** ( {* ;} *zoneWP* ) -> Résultat",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, zoneWP est un nom d'objet de formulaire (chaîne). Si omis, zoneWP est un champ ou une variable objet."
				],
				[
					"zoneWP",
					"Text",
					"->",
					"Nom d'objet de formulaire (si * spécifié) ou champ ou variable objet 4D Write Pro (si * omis)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvel objet plage ou image"
				]
			],
			"Summary": "La commande **WP Selection range** retourne une nouvelle plage de sélection ou une nouvelle image basée sur la sélection courante dans la zone 4D Write Pro *zoneWP*."
		},
		"WP SET DATA CONTEXT": {
			"Syntax": "**WP SET DATA CONTEXT** ( *wpDoc* ; *contextData* )",
			"Params": [
				[
					"wpDoc",
					"Object",
					"->",
					"Document 4D Write Pro"
				],
				[
					"contextData",
					"Object",
					"->",
					"Données à insérer dans le contexte"
				]
			],
			"Summary": "La commande **WP SET DATA CONTEXT** définit l'objet *contextData* comme contexte de données du document 4D Write Pro wpDoc."
		},
		"WP SET FRAME": {
			"Syntax": "**WP SET FRAME** ( {* ;} *zoneWP* ; *sélecteurCadre* {; *textBoxID*} )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, zoneWP est un nom d'objet de formulaire (chaîne). Si omis, zoneWP est un champ ou une variable objet"
				],
				[
					"zoneWP",
					"Text",
					"->",
					"Nom d'objet de formulaire (si * spécifié) ou champ ou variable objet 4D Write Pro (si * omis)"
				],
				[
					"sélecteurCadre",
					"Integer",
					"->",
					"Cadre dans lequel placer le curseur"
				],
				[
					"textBoxID",
					"Text",
					"->",
					"Id of the text box where the cursor should be set"
				]
			],
			"Summary": "La commande **WP SET FRAME** place le curseur dans le cadre désigné par le paramètre *sélecteurCadre* et, facultativement, textBoxID, de la zone 4D Write Pro *wpZone*."
		},
		"WP SET LINK": {
			"Syntax": "**WP SET LINK** ( *objCible* ; *objLien* )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"objLien",
					"Object",
					"->",
					"Valeur du lien hypertexte"
				]
			],
			"Summary": "La commande **WP SET LINK** applique une référence de lien hypertexte au paramètre *objCible*."
		},
		"WP SET TEXT": {
			"Syntax": "**WP SET TEXT** ( *objCible* ; *nouveauTexte* ; *positionTexte* {; *miseAJourPlage*} )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"nouveauText",
					"Text",
					"->",
					"Texte à insérer"
				],
				[
					"positionTexte",
					"Number",
					"->",
					"Position de l'insertion (remplace, avant, après)"
				],
				[
					"miseAJourPlage",
					"Number",
					"->",
					"Inclut ou exclut le contenu inséré dans la plage"
				]
			],
			"Summary": "La commande **WP SET TEXT** insère le texte passé dans le paramètre *nouveauTexte* en texte brut dans le paramètre *objCible* à la position spécifiée par le paramètre *positionTexte*."
		},
		"WP SET VIEW PROPERTIES": {
			"Syntax": "**WP SET VIEW PROPERTIES** ( {* ;} *zoneWP* ; *attributsVueWP* )",
			"Params": [
				[
					"*",
					"Opérateur",
					"->",
					"Si spécifié, zoneWP est un nom d'objet de formulaire (chaîne). Si omis, zoneWP est un champ ou une variable objet"
				],
				[
					"zoneWP",
					"Text, Object",
					"->",
					"Nom d'objet de formulaire (si * spécifié) ou champ ou variable objet 4D Write Pro (si * omis)"
				],
				[
					"attributsVueWP",
					"Object",
					"->",
					"Attributs vue à modifier"
				]
			],
			"Summary": "La commande **WP SET VIEW PROPERTIES** vous permet de fixer dynamiquement une ou plusieurs propriétés de vue pour la zone 4D Write Pro *zoneWP*."
		},
		"WP TABLE DELETE COLUMNS": {
			"Syntax": "**WP TABLE DELETE COLUMNS** ( *objCible* ) | ( *refTableau* ; *numCol* {; *nbCols*} )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D View Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"numCol",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"nbCols",
					"Integer",
					"->",
					"Nombre de colonnes à supprimer (valeur par défaut=1)"
				]
			],
			"Summary": "La commande **WP TABLE DELETE COLUMNS** supprimer une ou plusieurs colonnes d'un tableau 4D Write."
		},
		"WP TABLE DELETE ROWS": {
			"Syntax": "**WP TABLE DELETE ROWS** ( *objCible* ) | ( *refTableau* ; *numLigne* {; *nbLignes*} )",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D View Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"numLigne",
					"Integer",
					"->",
					"Numéro d'indice de la ligne"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à supprimer (valeur par défaut=1)"
				]
			],
			"Summary": "La commande **WP TABLE DELETE ROWS** supprime une ou plusieurs lignes d'un tableau 4D Write Pro."
		},
		"WP Table get cells": {
			"Syntax": "**WP Table get cells** ( *objCible* ) | ( *refTableau* ; *debutCol* ; *debutLigne* {; *nbCols*{; *nbLignes*}} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"debutCol",
					"Integer",
					"->",
					"Position de la colonne de la première cellule"
				],
				[
					"debutLigne",
					"Integer",
					"->",
					"Position de la ligne de la première cellule"
				],
				[
					"nbCols",
					"Integer",
					"->",
					"Nombre de colonnes à lire"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à lire"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvelle plage contenant les cellules"
				]
			],
			"Summary": "La commande **WP Table get cells** retourne un nouvel objet cellule contenant la sélection de cellules de objCible ou de *refTableau* (définies par *debutCol*, *debutLigne*, *nbCols* et *nbLignes*)."
		},
		"WP Table get columns": {
			"Syntax": "**WP Table get columns** ( *objCible* ) | ( *refTableau* ; *debutCol* {; *nbCols*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"debutCol",
					"Integer",
					"->",
					"Position de la première colonne"
				],
				[
					"nbCols",
					"Integer",
					"->",
					"Nombre de colonnes à lire"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvelle plage contenant les colonnes sélectionnées"
				]
			],
			"Summary": "La commande **WP Table get columns** retourne un nouvel objet plage cellule contenant la sélection de colonnes de objCible ou de *refTableau* (définies par *debutCol* et *nbCols*)."
		},
		"WP Table get rows": {
			"Syntax": "**WP Table get rows** ( *objCible* ) | ( *refTableau* ; *debutLigne* {; *nbLignes*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"debutLigne",
					"Integer, Text",
					"->",
					"Position de la première ligne"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à lire"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvelle plage contenant les lignes sélectionnées"
				]
			],
			"Summary": "La commande **WP Table get rows** retourne un nouvel objet plage de lignes contenant une sélection de lignes de *objCible* ou de *refTableau*."
		},
		"WP Table insert columns": {
			"Syntax": "**WP Table insert columns** ( objCible | {*refTableau* ; *numCol*} {; *nbCols*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"numCol",
					"Integer",
					"->",
					"Numéro de colonne"
				],
				[
					"nbCols",
					"Integer",
					"->",
					"Nombre de colonnes à insérer (valeur par défaut = 1)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage de colonnes du tableau"
				]
			],
			"Summary": "La commande **WP Table insert columns** insère une ou plusieurs colonnes dans un tableau 4D Write Pro."
		},
		"WP Table insert rows": {
			"Syntax": "**WP Table insert rows** ( objCible | {*refTableau* ; *numLigne*} {; *nbLignes*} )  -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"refTableau",
					"Object",
					"->",
					"Référence de tableau"
				],
				[
					"numLigne",
					"Integer",
					"->",
					"Numéro d'indice de ligne"
				],
				[
					"nbLignes",
					"Integer",
					"->",
					"Nombre de lignes à insérer (valeur par défaut = 1)"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Plage de lignes du tableau"
				]
			],
			"Summary": "La commande **WP Table insert rows** insère une ou plusieurs lignes dans un tableau 4D Write Pro."
		},
		"WP TABLE MERGE CELLS": {
			"Syntax": "**WP TABLE MERGE CELLS** ( *targetObj* ) | ( *tableRef* ; *startColumn* ; *startRow* {; *columnCount*{; *rowCount*}} )",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Range or element or 4D Write Pro document"
				],
				[
					"tableRef",
					"Object",
					"->",
					"Table reference"
				],
				[
					"startColumn",
					"Integer",
					"->",
					"Position of first cell column"
				],
				[
					"startRow",
					"Integer",
					"->",
					"Position of first column row"
				],
				[
					"columnCount",
					"Integer",
					"->",
					"Number of columns to merge"
				],
				[
					"rowCount",
					"Integer",
					"->",
					"Number of rows to merge"
				]
			],
			"Summary": "La commande **WP TABLE MERGE CELLS**fusionne la sélection de cellules dans *targetObj* ou *tableRef* (défini par *startColumn*, *startRow*, *columnCount*, et *rowCount*)."
		},
		"WP Table range": {
			"Syntax": "**WP Table range** ( *objCible* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Objet plage contenant uniquement les tableaux"
				]
			],
			"Summary": "La commande **WP Table range** était nommée **WP Create table range** dans les versions précédentes de 4D Write Pro."
		},
		"WP TABLE SPLIT CELLS": {
			"Syntax": "**WP TABLE SPLIT CELLS** ( *targetObj* ) | ( *tableRef* ; *startColumn* ; *startRow* {; *columnCount*{; *rowCount*}} )",
			"Params": [
				[
					"targetObj",
					"Object",
					"->",
					"Range or element or 4D Write Pro document"
				],
				[
					"tableRef",
					"Object",
					"->",
					"Table reference"
				],
				[
					"startColumn",
					"Integer",
					"->",
					"Position of first cell column"
				],
				[
					"startRow",
					"Integer",
					"->",
					"Position of first column row"
				],
				[
					"columnCount",
					"Integer",
					"->",
					"Number of columns to split"
				],
				[
					"rowCount",
					"Integer",
					"->",
					"Number of rows to split"
				]
			],
			"Summary": "La commande **WP TABLE SPLIT CELLS** fractionne la sélection intersectée de cellules contenues dans *targetObj* ou *tableRef* (défini par *startColumn*, *startRow*, *columnCount*, et *rowCount*)."
		},
		"WP Text range": {
			"Syntax": "**WP Text range** ( *objCible* ; *débutPlage* ; *finPlage* ) -> Résultat",
			"Params": [
				[
					"objCible",
					"Object",
					"->",
					"Plage ou élément ou document 4D Write Pro"
				],
				[
					"débutPlage",
					"Integer",
					"->",
					"Position du début de la plage dans la zone"
				],
				[
					"finPlage",
					"Integer",
					"->",
					"Position de la fin de la plage dans la zone"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"Nouvel objet plage"
				]
			],
			"Summary": "La commande **WP Text range** retourne une nouvelle plage contenant les caractères situés entre *débutPlage* et *finPlage* dans l'objet *objCible*."
		},
		"WP USE PAGE SETUP": {
			"Syntax": "**WP USE PAGE SETUP** ( *docWP* )",
			"Params": [
				[
					"docWP",
					"Object",
					"->",
					"Document 4D Write Pro"
				]
			],
			"Summary": "La commande **WP USE PAGE SETUP** modifie les options d'impression de la page courante, sur la base des attributs du document 4D Write Pro qui concernent la taille et l'orientation de la page."
		}
	},
	"WebFormItem": {
		"hide()": {
			"Syntax": "**.hide**()",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "masque le composant"
		},
		"show()": {
			"Syntax": "**.show**()",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "rend le composant visible"
		},
		"addCSSClass()": {
			"Syntax": "**.addCSSClass**(*className* : string)",
			"Params": [
				[
					"className",
					"string",
					"->",
					"Nom de la classe CSS à ajouter au composant"
				]
			],
			"Summary": "ajoute la classe *className* au composant"
		},
		"removeCSSClass()": {
			"Syntax": "**.removeCSSClass**(*className*: string)",
			"Params": [
				[
					"className",
					"string",
					"->",
					"Nom de la classe CSS à supprimer du composant"
				]
			],
			"Summary": "supprime la classe *className* du composant"
		}
	},
	"WebServer": {
		"accessKeyDefined": {
			"Syntax": "**.accessKeyDefined** : Boolean",
			"Summary": "vrai si une access key est définie dans les settings du serveur Web"
		},
		"certificateFolder": {
			"Syntax": "**.certificateFolder** : Text",
			"Summary": "dossier contenant les fichiers des certificats"
		},
		"characterSet": {
			"Syntax": "**.characterSet** : Number<br/>**.characterSet** : Text",
			"Summary": "jeu de caractères que le serveur Web doit utiliser pour communiquer avec les navigateurs se connectant à l'application"
		},
		"cipherSuite": {
			"Syntax": "**.cipherSuite** : Text",
			"Summary": "liste de chiffrement utilisée pour le protocole sécurisé"
		},
		"CORSEnabled": {
			"Syntax": "**.CORSEnabled** : Boolean",
			"Summary": "statut du service CORS (*Cross-origin resource sharing*) pour le serveur Web"
		},
		"CORSSettings": {
			"Syntax": "**.CORSSettings** : Collection",
			"Summary": "liste d'hôtes et de méthodes autorisées pour le service CORS"
		},
		"debugLog": {
			"Syntax": "**.debugLog** : Integer",
			"Summary": "statut du fichier de log des requêtes HTTP"
		},
		"defaultHomepage": {
			"Syntax": "**.defaultHomepage** : Text",
			"Summary": "nom de la page home par défaut"
		},
		"HSTSEnabled": {
			"Syntax": "**.HSTSEnabled** : Boolean",
			"Summary": "statut du HTTP Strict Transport Security (HSTS)"
		},
		"HSTSMaxAge": {
			"Syntax": "**.HSTSMaxAge** : Integer",
			"Summary": "durée maximum (en secondes) pendant laquelle HSTS est actif pour chaque nouvelle connexion cliente"
		},
		"HTTPCompressionLevel": {
			"Syntax": "**.HTTPCompressionLevel** : Integer",
			"Summary": "niveau de compression pour tous les échanges HTTP compressés du serveur (requêtes clientes ou réponses du serveur)"
		},
		"HTTPCompressionThreshold": {
			"Syntax": "**.HTTPCompressionThreshold** : Integer",
			"Summary": "limite de la taille des requêtes (en octets) au-dessous de laquelle les échanges ne doivent pas être compressés"
		},
		"HTTPEnabled": {
			"Syntax": "**.HTTPEnabled** : Boolean",
			"Summary": "statut du protocole HTTP"
		},
		"HTTPPort": {
			"Syntax": "**.HTTPPort** : Integer",
			"Summary": "statut du protocole HTTPS"
		},
		"HTTPTrace": {
			"Syntax": "**.HTTPTrace** : Boolean",
			"Summary": "activation de `HTTP TRACE`"
		},
		"HTTPSEnabled": {
			"Syntax": "**.HTTPSEnabled** : Boolean",
			"Summary": "statut du protocole HTTPS"
		},
		"HTTPSPort": {
			"Syntax": "**.HTTPSPort** : Integer",
			"Summary": "numéro de port IP d'écoute pour HTTPS"
		},
		"inactiveProcessTimeout": {
			"Syntax": "**.inactiveProcessTimeout** : Integer",
			"Summary": "durée de vie (en minutes) des process de sessions legacy inactifs"
		},
		"inactiveSessionTimeout": {
			"Syntax": "**.inactiveSessionTimeout** : Integer",
			"Summary": "durée de vie (en minutes) des process de session legacy inactifs (durée définie dans le cookie)"
		},
		"IPAddressToListen": {
			"Syntax": "**.IPAddressToListen** : Text",
			"Summary": "adresse IP sur laquelle le serveur Web recevra les requêtes HTTP"
		},
		"isRunning": {
			"Syntax": "**.isRunning** : Boolean",
			"Summary": "statut d'exécution du serveur web"
		},
		"keepSession": {
			"Syntax": "**.keepSession** : Boolean",
			"Summary": "`True` si les anciennes sessions sont activées dans le serveur web, `False` sinon"
		},
		"logRecording": {
			"Syntax": "**.logRecording** : Integer",
			"Summary": "mode d'enregistrement du log des requêtes (logweb.txt)"
		},
		"maxConcurrentProcesses": {
			"Syntax": "**.maxConcurrentProcesses** : Integer",
			"Summary": "nombre maximum de process web simultanés accepté par le serveur Web"
		},
		"maxRequestSize": {
			"Syntax": "**.maxRequestSize** : Integer",
			"Summary": "taille maximum (en octets) des requêtes HTTP entrantes (POST) que le serveur Web est autorisé à traiter"
		},
		"maxSessions": {
			"Syntax": "**.maxSessions** : Integer",
			"Summary": "nombre maximum de sessions legacy simultanées"
		},
		"minTLSVersion": {
			"Syntax": "**.minTLSVersion** : Integer",
			"Summary": "version minimum de TLS acceptée pour les connexions"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "nom de l'application web server"
		},
		"openSSLVersion": {
			"Syntax": "**.openSSLVersion** : Text",
			"Summary": "version de la librairie OpenSSL utilisée"
		},
		"perfectForwardSecrecy": {
			"Syntax": "**.perfectForwardSecrecy** : Boolean",
			"Summary": "disponibilité de PFS sur le serveur"
		},
		"rootFolder": {
			"Syntax": "**.rootFolder** : Text",
			"Summary": "chemin du dossier racine du serveur Web"
		},
		"scalableSession": {
			"Syntax": "**.scalableSession** : Boolean",
			"Summary": "`True` si les sessions évolutives sont utilisées dans le serveur web, et `False` sinon"
		},
		"sessionCookieDomain": {
			"Syntax": "**.sessionCookieDomain** : Text",
			"Summary": "champ \"domain\" du cookie de session"
		},
		"sessionCookieName": {
			"Syntax": "**.sessionCookieName** : Text",
			"Summary": "nom du cookie utilisé pour stocker l'ID de session"
		},
		"sessionCookiePath": {
			"Syntax": "**.sessionCookiePath** : Text",
			"Summary": "champ \"path\" du cookie de session"
		},
		"sessionCookieSameSite": {
			"Syntax": "**.sessionCookieSameSite** : Text",
			"Summary": "valeur \"SameSite\" du cookie de session"
		},
		"sessionIPAddressValidation": {
			"Syntax": "**.sessionIPAddressValidation** : Boolean",
			"Summary": "validation de l'adresse IP des cookies de session"
		},
		"start()": {
			"Syntax": "**.start**() : Object<br/>**.start**( *settings* : Object ) : Object",
			"Params": [
				[
					"settings",
					"Object",
					"->",
					"Paramètres du serveur web au démarrage"
				],
				[
					"Résultat",
					"Object",
					"<-",
					"État du démarrage du serveur web"
				]
			],
			"Summary": "démarre le serveur web sur lequel elle est appliquée"
		},
		"stop()": {
			"Syntax": "**.stop()**",
			"Params": [
				[
					"",
					"",
					"",
					"Ne requiert aucun paramètre"
				]
			],
			"Summary": "arrête le serveur web sur lequel elle est appliquée"
		}
	},
	"WebSocket": {
		"dataType": {
			"Syntax": "**.dataType** : Text",
			"Summary": "le type de contenu du body de la réponse"
		},
		"handler": {
			"Syntax": "**.handler** : Object",
			"Summary": "l'accesseur qui récupère l'objet `connectionHandler` utilisé pour initier la connexion"
		},
		"id": {
			"Syntax": "**.id** : Integer",
			"Summary": "l'identifiant unique de la connexion"
		},
		"send()": {
			"Syntax": "**.send**( *message* : Text )<br/>**.send**( *message* : Blob )<br/>**.send**( *message* : Object )",
			"Params": [
				[
					"message",
					"Text, Blob, Object",
					"->",
					"Message à envoyer"
				]
			],
			"Summary": "envoie *message* au serveur WebSocket dans le type de données défini (Text, Blob ou Object)"
		},
		"status": {
			"Syntax": "**.status** : Text",
			"Summary": "le statut courant de la connexion (peut être \"Connecting\", \"Closing\", \"Closed\" ou \"Connected\")"
		},
		"terminate()": {
			"Syntax": "**.terminate**( { *code* : Integer { ; *reason* : Text } } )",
			"Params": [
				[
					"code",
					"Integer",
					"->",
					"Code de statut indiquant la cause de la fermeture de la connexion"
				],
				[
					"reason",
					"Text",
					"->",
					"Cause de la fermeture de la connexion"
				]
			],
			"Summary": "referme la connexion WebSocket, avec les paramètres optionnels *code* et *reason*"
		},
		"url": {
			"Syntax": "**.url** : Text",
			"Summary": "l'URL auquel le WebSocket s'est connecté"
		}
	},
	"WebSocketConnection": {
		"handler": {
			"Syntax": "**.handler** : Object",
			"Summary": "l'accesseur qui récupère l'objet `connectionHandler` utilisé pour initier la connexion"
		},
		"id": {
			"Syntax": "**.id** : Integer",
			"Summary": "l'identifiant unique de la connexion"
		},
		"send()": {
			"Syntax": "**.send**( *message* : Text )<br/>**.send**( *message* : Blob )<br/>**.send**( *message* : Object )",
			"Params": [
				[
					"message",
					"Text / Blob / Object",
					"->",
					"Le message à envoyer"
				]
			],
			"Summary": "envoie *message* au client"
		},
		"status": {
			"Syntax": "**.status** : Text",
			"Summary": "le statut de la connexion (peut être \"Closing\", \"Closed\" ou \"Connected\")"
		},
		"terminate()": {
			"Syntax": "**.terminate**( { *code* : Integer ; *message* : Text } )",
			"Params": [
				[
					"code",
					"Integer",
					"->",
					"Code d'erreur envoyé au client (doit être > 3000, sinon le message n'est pas envoyé)"
				],
				[
					"message",
					"Text",
					"->",
					"Message d'erreur envoyé au client"
				]
			],
			"Summary": "force la fermeture de la connexion"
		},
		"wss": {
			"Syntax": "**.wss** : 4D.WebSocketServer",
			"Summary": "l'objet parent `WebSocketServer` de la connexion"
		}
	},
	"WebSocketServer": {
		"connections": {
			"Syntax": "**.connections** : Collection",
			"Summary": "toutes les connexions courantes gérées par le serveur WebSocket"
		},
		"dataType": {
			"Syntax": "**.dataType** : Text",
			"Summary": "le type de données reçues ou envoyées"
		},
		"handler": {
			"Syntax": "**.handler** : Object",
			"Summary": "l'accesseur qui récupère l'objet `WSSHandler` utilisé pour initier le serveur WebSocket"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "le pattern du chemin d'accès au serveur WebSocket"
		},
		"terminate()": {
			"Syntax": "**.terminate**()<br/>**.terminate**( *timeout* : Integer )",
			"Params": [
				[
					"timeout",
					"Integer",
					"->",
					"Temps d'attente en secondes avant de terminer le serveur WebSocket"
				]
			],
			"Summary": "referme le serveur WebSocket"
		},
		"terminated": {
			"Syntax": "**.terminated** : Boolean",
			"Summary": "True si le serveur WebSocket est fermé"
		}
	},
	"ZipArchive": {
		"root": {
			"Syntax": "**.root** : 4D.ZipFolder",
			"Summary": "un dossier virtuel permettant d'accéder au contenu de l'archive ZIP"
		}
	},
	"ZipFile": {
		"_inheritedFrom_": "Document"
	},
	"ZipFolder": {
		"_inheritedFrom_": "Directory"
	}
}