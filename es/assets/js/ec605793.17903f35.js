/*! For license information please see ec605793.17903f35.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[36437],{346285:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>i,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(474848),s=n(28453);const r={id:"blob",title:"BLOB"},t=void 0,l={id:"Concepts/blob",title:"BLOB",description:"- Un campo, variable o expresi\xf3n BLOB (Binary Large OBjects) es una serie contigua de bytes que puede ser tratada como un objeto completo o cuyos bytes pueden ser direccionados individualmente. Un BLOB puede estar vac\xedo (longitud nula) o contener hasta 2147483647 bytes (2 GB).",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-18/Concepts/dt_blob.md",sourceDirName:"Concepts",slug:"/Concepts/blob",permalink:"/docs/es/18/Concepts/blob",draft:!1,unlisted:!1,editUrl:"https://github.com/4d/docs/issues/new?title=Comment%20on%20Concepts%2Fdt_blob.md%20(18)&body=Please%20enter%20your%20comment%3A",tags:[],version:"18",frontMatter:{id:"blob",title:"BLOB"},sidebar:"docs",previous:{title:"Tipos de datos",permalink:"/docs/es/18/Concepts/data-types"},next:{title:"Boolean",permalink:"/docs/es/18/Concepts/boolean"}},i={},d=[{value:"Paso de par\xe1metros, punteros y resultados de funciones",id:"Paso-de-par\xe1metros-punteros-y-resultados-de-funciones",level:2},{value:"Asignaci\xf3n",id:"Asignaci\xf3n",level:2},{value:"Direccionar el contenido de un BLOB",id:"Direccionar-el-contenido-de-un-BLOB",level:2}];function c(e){const o={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(o.ul,{children:["\n",(0,a.jsx)(o.li,{children:"Un campo, variable o expresi\xf3n BLOB (Binary Large OBjects) es una serie contigua de bytes que puede ser tratada como un objeto completo o cuyos bytes pueden ser direccionados individualmente. Un BLOB puede estar vac\xedo (longitud nula) o contener hasta 2147483647 bytes (2 GB)."}),"\n"]}),"\n",(0,a.jsxs)(o.blockquote,{children:["\n",(0,a.jsx)(o.p,{children:"Por defecto, 4D define el tama\xf1o m\xe1ximo de los blob en 2GB, pero este l\xedmite de tama\xf1o puede ser menor dependiendo de su sistema operativo y del espacio disponible."}),"\n"]}),"\n",(0,a.jsxs)(o.ul,{children:["\n",(0,a.jsx)(o.li,{children:"Un BLOB se carga en la memoria en su totalidad. Una variable BLOB se mantiene y existe s\xf3lo en la memoria. Un campo BLOB se carga en memoria desde el disco, como el resto del registro al que pertenece."}),"\n",(0,a.jsxs)(o.li,{children:["Al igual que los otros tipos de campo que pueden retener una gran cantidad de datos (como el tipo de campo Imagen), los campos BLOB no se duplican en la memoria cuando se modifica un registro. Por consiguiente, el resultado devuelto por los comandos ",(0,a.jsx)(o.code,{children:"Old"})," y ",(0,a.jsx)(o.code,{children:"Modified"})," no es significativo cuando se aplica a un campo BLOB."]}),"\n"]}),"\n",(0,a.jsx)(o.h2,{id:"Paso-de-par\xe1metros-punteros-y-resultados-de-funciones",children:"Paso de par\xe1metros, punteros y resultados de funciones"}),"\n",(0,a.jsx)(o.p,{children:"Los BLOBs en 4D pueden pasarse como par\xe1metros a los comandos 4D o a las rutinas de los plugins que esperan par\xe1metros BLOB. Los BLOBS tambi\xe9n pueden ser pasados como par\xe1metros a un m\xe9todo de usuario o ser devueltos como resultado de una funci\xf3n."}),"\n",(0,a.jsx)(o.p,{children:"Para pasar un BLOB a sus propios m\xe9todos, tambi\xe9n puede definir un puntero al BLOB y pasar el puntero como par\xe1metro."}),"\n",(0,a.jsx)(o.p,{children:(0,a.jsx)(o.strong,{children:"Ejemplos:"})}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-4d",children:"  ` Declarar una variable de tipo BLOB\n C_BLOB(anyBlobVar)\n  ` El BLOB se pasa como par\xe1metro a un comando 4D\n SET BLOB SIZE(anyBlobVar;1024*1024)\n  El BLOB se pasa como par\xe1metro a una rutina externa\n $errCode:=Haga algo con este BLOB(anyBlobVar)\n  ` El BLOB se pasa como par\xe1metro a un m\xe9todo que devuelve un BLOB\n C_BLOB(recuperarBlob)\n recuperarBlob:=Rellenar_Blob(cualquierBlobVar)\n  ` Se pasa un puntero al BLOB como par\xe1metro a un m\xe9todo de usuario\n COMPUTE BLOB(->anyBlobVar)\n"})}),"\n",(0,a.jsxs)(o.p,{children:[(0,a.jsx)(o.strong,{children:"Nota para los desarrolladores de plugins:"}),' un par\xe1metro BLOB se declara como "&O" (la letra "O", no el d\xedgito "0").']}),"\n",(0,a.jsx)(o.h2,{id:"Asignaci\xf3n",children:"Asignaci\xf3n"}),"\n",(0,a.jsx)(o.p,{children:"Se pueden asignar BLOBs entre s\xed."}),"\n",(0,a.jsx)(o.p,{children:(0,a.jsx)(o.strong,{children:"Ejemplo:"})}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-4d",children:"  ` Declarar dos variables de tipo BLOB\n C_BLOB(vBlobA;vBlobB)\n  ` Fijar el tama\xf1o del primer BLOB en 10K\n SET BLOB SIZE(vBlobA;10*1024)\n  ` Asignar el primer BLOB al segundo\n vBlobB:=vBlobA\n"})}),"\n",(0,a.jsx)(o.p,{children:"Sin embargo, no se puede aplicar ning\xfan operador a los BLOB."}),"\n",(0,a.jsx)(o.h2,{id:"Direccionar-el-contenido-de-un-BLOB",children:"Direccionar el contenido de un BLOB"}),"\n",(0,a.jsx)(o.p,{children:"Cada byte de un BLOB se puede direccionar individualmente utilizando los s\xedmbolos de corchetes {...}. Dentro de un BLOB, los bytes se numeran de 0 a N-1, donde N es el tama\xf1o del BLOB. Ejemplo:"}),"\n",(0,a.jsx)(o.pre,{children:(0,a.jsx)(o.code,{className:"language-4d",children:"  ` Declarar una variable de tipo BLOB\n C_BLOB(vBlob)\n  ` Fijar el tama\xf1o del BLOB en 256 bytes\n SET BLOB SIZE(vBlob;256)\n  ` El bucle siguiente inicializa los 256 bytes del BLOB en cero\n For(vByte;0;BLOB size(vBlob)-1)\n    vBlob{vByte}:=0\n End for\n"})}),"\n",(0,a.jsx)(o.p,{children:"Como se pueden direccionar todos los bytes de un BLOB de forma individual, se puede almacenar lo que se quiera en un campo o variable BLOB."})]})}function u(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,a.jsx)(o,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},221020:(e,o,n)=>{var a=n(296540),s=Symbol.for("react.element"),r=Symbol.for("react.fragment"),t=Object.prototype.hasOwnProperty,l=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function d(e,o,n){var a,r={},d=null,c=null;for(a in void 0!==n&&(d=""+n),void 0!==o.key&&(d=""+o.key),void 0!==o.ref&&(c=o.ref),o)t.call(o,a)&&!i.hasOwnProperty(a)&&(r[a]=o[a]);if(e&&e.defaultProps)for(a in o=e.defaultProps)void 0===r[a]&&(r[a]=o[a]);return{$$typeof:s,type:e,key:d,ref:c,props:r,_owner:l.current}}o.Fragment=r,o.jsx=d,o.jsxs=d},474848:(e,o,n)=>{e.exports=n(221020)},28453:(e,o,n)=>{n.d(o,{R:()=>t,x:()=>l});var a=n(296540);const s={},r=a.createContext(s);function t(e){const o=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),a.createElement(r.Provider,{value:o},e.children)}}}]);