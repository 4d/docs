/*! For license information please see affdb90a.8c04ead9.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[99954],{749492:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var o=s(474848),r=s(28453);const t={id:"control-flow",title:"Condiciones y bucles"},c=void 0,a={id:"Concepts/control-flow",title:"Condiciones y bucles",description:"Independientemente de la simplicidad o la complejidad de un m\xe9todo, siempre utilizar\xe1 uno o varios de los tres tipos de estructuras de programaci\xf3n. Las estructuras de programaci\xf3n determinan el flujo de ejecuci\xf3n, si se ejecutan y el orden de las l\xedneas de instrucciones dentro de un m\xe9todo. Hay tres tipos de estructuras:",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-19/Concepts/flow-control.md",sourceDirName:"Concepts",slug:"/Concepts/control-flow",permalink:"/docs/es/19/Concepts/control-flow",draft:!1,unlisted:!1,editUrl:"https://github.com/4d/docs/issues/new?title=Comment%20on%20Concepts%2Fflow-control.md%20(19)&body=Please%20enter%20your%20comment%3A",tags:[],version:"19",frontMatter:{id:"control-flow",title:"Condiciones y bucles"},sidebar:"docs",previous:{title:"Clases",permalink:"/docs/es/19/Concepts/classes"},next:{title:"Estructuras condicionales",permalink:"/docs/es/19/Concepts/branching"}},i={},d=[];function l(e){const n={a:"a",br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Independientemente de la simplicidad o la complejidad de un m\xe9todo, siempre utilizar\xe1 uno o varios de los tres tipos de estructuras de programaci\xf3n. Las estructuras de programaci\xf3n determinan el flujo de ejecuci\xf3n, si se ejecutan y el orden de las l\xedneas de instrucciones dentro de un m\xe9todo. Hay tres tipos de estructuras:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Secuencial"}),": una estructura secuencial es una estructura simple y lineal. Una secuencia es una serie de sentencias que 4D ejecuta una tras otra, de la primera a la \xfaltima. Una instrucci\xf3n de una l\xednea, utilizada frecuentemente para los m\xe9todos de los objetos, es el caso m\xe1s simple de una estructura secuencial. Por ejemplo: ",(0,o.jsx)(n.code,{children:"[People]lastName:=Uppercase([People]lastName)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/es/19/Concepts/branching",children:"Branching"})}),": una estructura de bifurcaci\xf3n permite que los m\xe9todos prueben una condici\xf3n y tomen caminos alternativos, dependiendo del resultado. La condici\xf3n es una expresi\xf3n booleana, una expresi\xf3n que eval\xfaa TRUE o FALSE. Una estructura condicional es la estructura ",(0,o.jsx)(n.code,{children:"If...Else...End if"}),", que dirige el flujo del programa a lo largo de uno de los dos caminos. The other branching structure is the ",(0,o.jsx)(n.code,{children:"Case of... Else...End case"})," structure, which directs program flow to one of many paths."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/es/19/Concepts/looping",children:"Bucle"})}),": cuando se escriben m\xe9todos, es muy com\xfan encontrarse con que se necesita que una secuencia de sentencias se repita un n\xfamero de veces. Para hacer frente a esta necesidad, el lenguaje 4D ofrece las siguientes estructuras de bucle:\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"While...End while"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Repeat...Until"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"For...End for"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"For each...End for each"}),(0,o.jsx)(n.br,{})," Los bucles se controlan de dos maneras: o bien hacen un bucle hasta que se cumpla una condici\xf3n, o bien hacen un bucle un n\xfamero determinado de veces. Cada estructura de bucle puede utilizarse de cualquier manera, pero los bucles ",(0,o.jsx)(n.code,{children:"While"})," y los bucles ",(0,o.jsx)(n.code,{children:"Repeat"})," son m\xe1s apropiados para repetir hasta que se cumpla una condici\xf3n, y los bucles ",(0,o.jsx)(n.code,{children:"For"})," son m\xe1s apropiados para hacer un bucle un n\xfamero determinado de veces. ",(0,o.jsx)(n.code,{children:"For each...End for each"})," permite la mezcla en ambos sentidos y est\xe1 dise\xf1ado para realizar bucles dentro de objetos y colecciones."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Nota:"}),' 4D permite anidar estructuras de programaci\xf3n hasta una "profundidad" de 512 niveles.']})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},221020:(e,n,s)=>{var o=s(296540),r=Symbol.for("react.element"),t=Symbol.for("react.fragment"),c=Object.prototype.hasOwnProperty,a=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,s){var o,t={},d=null,l=null;for(o in void 0!==s&&(d=""+s),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(l=n.ref),n)c.call(n,o)&&!i.hasOwnProperty(o)&&(t[o]=n[o]);if(e&&e.defaultProps)for(o in n=e.defaultProps)void 0===t[o]&&(t[o]=n[o]);return{$$typeof:r,type:e,key:d,ref:l,props:t,_owner:a.current}}n.Fragment=t,n.jsx=d,n.jsxs=d},474848:(e,n,s)=>{e.exports=s(221020)},28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var o=s(296540);const r={},t=o.createContext(r);function c(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);