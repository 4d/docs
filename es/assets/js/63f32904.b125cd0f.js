"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[77556],{353579:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var o=s(474848),c=s(28453);const r={id:"control-flow",title:"Condiciones y bucles"},t=void 0,a={id:"Concepts/control-flow",title:"Condiciones y bucles",description:"Independientemente de la simplicidad o la complejidad de un m\xe9todo, siempre utilizar\xe1 uno o varios de los tres tipos de estructuras de programaci\xf3n. Las estructuras de programaci\xf3n determinan el flujo de ejecuci\xf3n, si se ejecutan y el orden de las l\xedneas de instrucciones dentro de un m\xe9todo. Hay tres tipos de estructuras:",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-18/Concepts/flow-control.md",sourceDirName:"Concepts",slug:"/Concepts/control-flow",permalink:"/docs/es/18/Concepts/control-flow",draft:!1,unlisted:!1,editUrl:"https://github.com/4d/docs/issues/new?title=Comment%20on%20Concepts%2Fflow-control.md%20(18)&body=Please%20enter%20your%20comment%3A",tags:[],version:"18",frontMatter:{id:"control-flow",title:"Condiciones y bucles"},sidebar:"docs",previous:{title:"Objetos y colecciones compartidos",permalink:"/docs/es/18/Concepts/shared"},next:{title:"Estructuras condicionales",permalink:"/docs/es/18/Concepts/branching"}},i={},d=[];function l(e){const n={a:"a",br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Independientemente de la simplicidad o la complejidad de un m\xe9todo, siempre utilizar\xe1 uno o varios de los tres tipos de estructuras de programaci\xf3n. Las estructuras de programaci\xf3n determinan el flujo de ejecuci\xf3n, si se ejecutan y el orden de las l\xedneas de instrucciones dentro de un m\xe9todo. Hay tres tipos de estructuras:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Secuencial"}),": una estructura secuencial es una estructura simple y lineal. Una secuencia es una serie de sentencias que 4D ejecuta una tras otra, de la primera a la \xfaltima. Una instrucci\xf3n de una l\xednea, utilizada frecuentemente para los m\xe9todos de los objetos, es el caso m\xe1s simple de una estructura secuencial. Por ejemplo: ",(0,o.jsx)(n.code,{children:"[People]lastName:=Uppercase([People]lastName)"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/es/18/Concepts/branching",children:"Branching"})}),": una estructura de bifurcaci\xf3n permite que los m\xe9todos prueben una condici\xf3n y tomen caminos alternativos, dependiendo del resultado. La condici\xf3n es una expresi\xf3n booleana, una expresi\xf3n que eval\xfaa TRUE o FALSE. Una estructura condicional es la estructura ",(0,o.jsx)(n.code,{children:"If...Else...End if"}),", que dirige el flujo del programa a lo largo de uno de los dos caminos. The other branching structure is the ",(0,o.jsx)(n.code,{children:"Case of... Else...End case"})," structure, which directs program flow to one of many paths."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/es/18/Concepts/looping",children:"Bucle"})}),": cuando se escriben m\xe9todos, es muy com\xfan encontrarse con que se necesita que una secuencia de sentencias se repita un n\xfamero de veces. Para hacer frente a esta necesidad, el lenguaje 4D ofrece las siguientes estructuras de bucle:\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"While...End while"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Repeat...Until"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"For...End for"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"For each...End for each"}),(0,o.jsx)(n.br,{})," Los bucles se controlan de dos maneras: o bien hacen un bucle hasta que se cumpla una condici\xf3n, o bien hacen un bucle un n\xfamero determinado de veces. Cada estructura de bucle puede utilizarse de cualquier manera, pero los bucles ",(0,o.jsx)(n.code,{children:"While"})," y los bucles ",(0,o.jsx)(n.code,{children:"Repeat"})," son m\xe1s apropiados para repetir hasta que se cumpla una condici\xf3n, y los bucles ",(0,o.jsx)(n.code,{children:"For"})," son m\xe1s apropiados para hacer un bucle un n\xfamero determinado de veces. ",(0,o.jsx)(n.code,{children:"For each...End for each"})," permite la mezcla en ambos sentidos y est\xe1 dise\xf1ado para realizar bucles dentro de objetos y colecciones."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Nota:"}),' 4D permite anidar estructuras de programaci\xf3n hasta una "profundidad" de 512 niveles.']})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var o=s(296540);const c={},r=o.createContext(c);function t(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);