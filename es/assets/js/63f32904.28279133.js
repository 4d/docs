"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["16203"],{964887:function(e,n,s){s.r(n),s.d(n,{metadata:()=>o,contentTitle:()=>a,default:()=>u,assets:()=>i,toc:()=>d,frontMatter:()=>t});var o=JSON.parse('{"id":"Concepts/control-flow","title":"Condiciones y bucles","description":"Independientemente de la simplicidad o la complejidad de un m\xe9todo, siempre utilizar\xe1 uno o varios de los tres tipos de estructuras de programaci\xf3n. Las estructuras de programaci\xf3n determinan el flujo de ejecuci\xf3n, si se ejecutan y el orden de las l\xedneas de instrucciones dentro de un m\xe9todo. Hay tres tipos de estructuras:","source":"@site/i18n/es/docusaurus-plugin-content-docs/version-18/Concepts/flow-control.md","sourceDirName":"Concepts","slug":"/Concepts/control-flow","permalink":"/docs/es/18/Concepts/control-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/4d/docs/issues/new?title=Comment%20on%20Concepts%2Fflow-control.md%20(18)&body=Please%20enter%20your%20comment%3A","tags":[],"version":"18","frontMatter":{"id":"control-flow","title":"Condiciones y bucles"},"sidebar":"docs","previous":{"title":"Objetos y colecciones compartidos","permalink":"/docs/es/18/Concepts/shared"},"next":{"title":"Estructuras condicionales","permalink":"/docs/es/18/Concepts/branching"}}'),r=s("785893"),c=s("250065");let t={id:"control-flow",title:"Condiciones y bucles"},a=void 0,i={},d=[];function l(e){let n={a:"a",br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,c.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Independientemente de la simplicidad o la complejidad de un m\xe9todo, siempre utilizar\xe1 uno o varios de los tres tipos de estructuras de programaci\xf3n. Las estructuras de programaci\xf3n determinan el flujo de ejecuci\xf3n, si se ejecutan y el orden de las l\xedneas de instrucciones dentro de un m\xe9todo. Hay tres tipos de estructuras:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secuencial"}),": una estructura secuencial es una estructura simple y lineal. Una secuencia es una serie de sentencias que 4D ejecuta una tras otra, de la primera a la \xfaltima. Una instrucci\xf3n de una l\xednea, utilizada frecuentemente para los m\xe9todos de los objetos, es el caso m\xe1s simple de una estructura secuencial. Por ejemplo: ",(0,r.jsx)(n.code,{children:"[People]lastName:=Uppercase([People]lastName)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/es/18/Concepts/branching",children:"Branching"})}),": una estructura de bifurcaci\xf3n permite que los m\xe9todos prueben una condici\xf3n y tomen caminos alternativos, dependiendo del resultado. La condici\xf3n es una expresi\xf3n booleana, una expresi\xf3n que eval\xfaa TRUE o FALSE. Una estructura condicional es la estructura ",(0,r.jsx)(n.code,{children:"If...Else...End if"}),", que dirige el flujo del programa a lo largo de uno de los dos caminos. The other branching structure is the ",(0,r.jsx)(n.code,{children:"Case of... Else...End case"})," structure, which directs program flow to one of many paths."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/es/18/Concepts/looping",children:"Bucle"})}),": cuando se escriben m\xe9todos, es muy com\xfan encontrarse con que se necesita que una secuencia de sentencias se repita un n\xfamero de veces. Para hacer frente a esta necesidad, el lenguaje 4D ofrece las siguientes estructuras de bucle:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"While...End while"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Repeat...Until"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"For...End for"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"For each...End for each"}),(0,r.jsx)(n.br,{})," Los bucles se controlan de dos maneras: o bien hacen un bucle hasta que se cumpla una condici\xf3n, o bien hacen un bucle un n\xfamero determinado de veces. Cada estructura de bucle puede utilizarse de cualquier manera, pero los bucles ",(0,r.jsx)(n.code,{children:"While"})," y los bucles ",(0,r.jsx)(n.code,{children:"Repeat"})," son m\xe1s apropiados para repetir hasta que se cumpla una condici\xf3n, y los bucles ",(0,r.jsx)(n.code,{children:"For"})," son m\xe1s apropiados para hacer un bucle un n\xfamero determinado de veces. ",(0,r.jsx)(n.code,{children:"For each...End for each"})," permite la mezcla en ambos sentidos y est\xe1 dise\xf1ado para realizar bucles dentro de objetos y colecciones."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nota:"}),' 4D permite anidar estructuras de programaci\xf3n hasta una "profundidad" de 512 niveles.']})]})}function u(e={}){let{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return a},a:function(){return t}});var o=s(667294);let r={},c=o.createContext(r);function t(e){let n=o.useContext(c);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(c.Provider,{value:n},e.children)}}}]);