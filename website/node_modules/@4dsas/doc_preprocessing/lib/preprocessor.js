var fs = require('fs');
var path = require('path')
const { PreprocessorInstructor, TYPE} = require("./preprocessorInstruction")
const {PreprocessorRef, REFManager} = require("./preprocessorRef")
const log = require('./log')

function trimFirstLineBreak(inText) {
    let text = ""
    let firstIndex = 0
    const lastIndex = inText.length
    if(inText.length > 0) {
        if(inText[0] === '\r') {
            firstIndex++
            if(inText[1] === '\n') {
                firstIndex++
            }
        }
        else if(inText[0] === '\n') {
            firstIndex++
        }
    }

    if(firstIndex < lastIndex) {
        text = inText.substr(firstIndex, lastIndex - firstIndex)
    }

    return text
}


function getFileList(dir, callback, parent) {
    const files = fs.readdirSync(dir);
    parent = parent || dir;
    files.forEach(function(file) {
      if (fs.statSync(dir + file).isDirectory()) {
        callback((dir + file + '/').replace(parent, ""), false)
        getFileList(dir + file + '/', callback, parent);
      }
      else {
        callback((dir + file).replace(parent, ""), true)
      }
    });
  }

class Preprocessing {
    constructor(path, destination, inConfigFile) {
        this._path = path
        this._destination = destination
        this._refManager = new REFManager()
        this._configFile = inConfigFile;
    }

    _convertID2Args(inKeywords) {
        let i = 1
        let argument = ""
        while(i < inKeywords.length) {
            argument += " " + inKeywords[i]
            i++;
        }
        return argument.trim().split(";")
    }

    _collectFile(inCurrentPath) {
        const content = fs.readFileSync(inCurrentPath, 'utf8');
        const re = /(<!--)(.*?)(-->)/g
        let stack = []
        let match
         while ((match = re.exec(content)) != null) {

            var keywords = match[2].trim().split(" ")
            switch(keywords[0]) {
                case TYPE.REF:
                    if(keywords.length > 1) {
                        let item = new PreprocessorRef()
                        item.start = match.index + match[0].length
                        item.ID = this._convertID2Args(keywords)[0]
                        item.filePath = inCurrentPath;
                        stack.push(item)
                    }
                    else
                    {
                        log.show(log.MESSAGE.ERROR, "Missing id for reference")
                    }
                break
                case "END":
                    if(stack.length > 0) {

                        let item = stack.pop()
                        if(item.getType() === TYPE.REF) {
                            item.end = match.index
                            item.resolve(content)
                            this._refManager.push(item)
                        }
                    }else {
                        log.show(log.MESSAGE.ERROR, "Too many 'END' in file " + inCurrentPath)
                    }
                break
            }
        }
    }

    collect() {

        getFileList(this._path, (file, isFile) => {
            if(isFile) {
                const currentPath = this._path + file
                const extension = path.extname(file)
                if(extension === ".md") {
                    this._collectFile(currentPath);
                }
            }
        })

        if(fs.existsSync(this._configFile)) {
            this._collectFile(this._configFile);
        }
        
    }
    
    _resolveInclude(inContent, inPath, listArguments) {
        let re = /(<!--)(.*?)(-->)([\r]?[\n])?/g
        let match
        let startIndex = 0
        let currentContent = ""

        while ((match = re.exec(inContent)) != null) {
            currentContent += inContent.substr(startIndex, match.index - startIndex)
            let keywords = match[2].trim().split(" ")
            switch(keywords[0]) {
                case TYPE.INCLUDE:
                    if(keywords.length > 1)
                    {
                        let args = this._convertID2Args(keywords)
                        let arg = ""
                        if(args[0].length > 1 && args[0].charAt(0) == '$') {
                            let index = parseInt(args[0].substring(1)) - 1
                            if(index < listArguments.length && index >= 0) {
                                args[0] = listArguments[index]
                                arg = args[0]
                            }
                            else { //The include waits for an invalid argument
                                break
                            }
                        }
                        else {
                            arg = args[0]
                        }
                        const value = this._refManager.getContentFromID(arg)
                        if(value.error === true) {
                            const lineEnding = match[4] != undefined ? match[4] : ""
                            let c = trimFirstLineBreak(value.content) + lineEnding
                            currentContent += this._resolveInclude(c, inPath, args.slice(1))
                        }
                        else {
                            log.show(log.MESSAGE.WARNING, "The include \'" + args[0] + "\' in path " + inPath + " has an invalid reference")
                        }
                    }
                    break
            }
            startIndex = match.index + match[0].length
        }
        currentContent += inContent.substr(startIndex, inContent.length - startIndex)
        return currentContent
    }

    resolve(inPath) {
        const content = fs.readFileSync(inPath, 'utf8');
        return this._resolveInclude(content, inPath, [])
    }

    write(inPath, newContent) {
        fs.mkdirSync(path.dirname(inPath), {recursive: true})
        fs.writeFileSync(inPath, newContent)
    }

    copy(inPath, toPath) {
        fs.mkdirSync(path.dirname(toPath), {recursive: true})
        fs.copyFileSync(inPath, toPath)
    }


    run() {
        this.collect()

        getFileList(this._path, (file, isFile) => {
            if(!isFile) return;
            const currentPath = this._path + file
            const destination = this._destination + file
            const extension = path.extname(file)
            if(extension === ".md") {
                const content = this.resolve(currentPath)
                this.write(destination, content)
            }
            else {
                try {
                   if(new Date(fs.statSync(destination).mtime).getTime() !== new Date(fs.statSync(currentPath).mtime).getTime()) {
                        this.copy(currentPath, destination)
                    }
                }
                catch(error) {
                    this.copy(currentPath, destination)
                }
            }
        });

        getFileList(this._destination, (file, isFile) => {
            const currentPath = this._path + file
            const destination = this._destination + file
            if(isFile) {
                if(!fs.existsSync(currentPath)) {
                    fs.unlinkSync(destination)
                }
            }
            else {
                if(!fs.existsSync(currentPath)) {
                    const deleteFolderRecursive = function(inPath) {
                        if (fs.existsSync(inPath)) {
                          fs.readdirSync(inPath).forEach((file, index) => {
                            const curPath = path.join(inPath, file);
                            if (fs.lstatSync(curPath).isDirectory()) { // recurse
                              deleteFolderRecursive(curPath);
                            } else { // delete file
                              fs.unlinkSync(curPath);
                            }
                          });
                          fs.rmdirSync(inPath);
                        }
                      };
                    deleteFolderRecursive(destination)
                }
            }
        });
        
    }
}

exports.Preprocessing = Preprocessing