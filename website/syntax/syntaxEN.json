{
	"4D": {
		"Blob": {
			"new()": {
				"Syntax": "**4D.Blob.new()** : 4D.Blob<br/>**4D.Blob.new**( *blobScal* : Blob ) : 4D.Blob<br/>**4D.Blob.new**( *blobObj* : 4D.Blob ) : 4D.Blob",
				"Params": [
					[
						"blob",
						"Blob or 4D.Blob",
						"->",
						"Blob to copy"
					],
					[
						"Result",
						"4D.Blob",
						"<-",
						"New 4D.Blob"
					]
				],
				"Summary": "creates a new `4D.Blob` object optionally encapsulating a copy of the data from another blob (scalar blob or `4D.Blob`)."
			}
		},
		"MailAttachment": {
			"new()": {
				"Syntax": "**4D.MailAttachment.new**( *file* : 4D.File { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br>**4D.MailAttachment.new**( *zipFile* : 4D.ZipFile { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br>**4D.MailAttachment.new**( *blob* : 4D.Blob { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br>**4D.MailAttachment.new**( *path* : Text { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment",
				"Params": [
					[
						"file",
						"4D.File",
						"->",
						"Attachment file"
					],
					[
						"zipFile",
						"4D.ZipFile",
						"->",
						"Attachment Zipfile"
					],
					[
						"blob",
						"4D.Blob",
						"->",
						"BLOB containing the attachment"
					],
					[
						"path",
						"Text",
						"->",
						"Path of the attachment file"
					],
					[
						"name",
						"Text",
						"->",
						"Name + extension used by the mail client to designate the attachment"
					],
					[
						"cid",
						"Text",
						"->",
						"ID of attachment (HTML messages only), or \" \" if no cid is required"
					],
					[
						"type",
						"Text",
						"->",
						"Value of the content-type header"
					],
					[
						"disposition",
						"Text",
						"->",
						"Value of the content-disposition header: \"inline\" or \"attachment\"."
					],
					[
						"Result",
						"4D.MailAttachment",
						"<-",
						"Attachment object"
					]
				],
				"Summary": "creates and returns a new object of the `4D.MailAttachment` type"
			}
		},
		"CryptoKey": {
			"new()": {
				"Syntax": "**4D.CryptoKey.new**( *settings* : Object ) : 4D.CryptoKey",
				"Params": [
					[
						"settings",
						"Object",
						"->",
						"Settings to generate or load a key pair"
					],
					[
						"result",
						"4D.CryptoKey",
						"<-",
						"Object encapsulating an encryption key pair"
					]
				],
				"Summary": "creates a new `4D.CryptoKey` object encapsulating an encryption key pair"
			}
		},
		"File": {
			"new()": {
				"Syntax": "**4D.File.new** ( *path* : Text { ; *pathType* : Integer }{ ; *\\** } ) : 4D.File<br>**4D.File.new** ( *fileConstant* : Integer { ; *\\** } ) : 4D.File",
				"Summary": "creates and returns a new object of the `4D.File` type"
			}
		},
		"Folder": {
			"new()": {
				"Syntax": "**4D.Folder.new** ( *path* : Text { ; *pathType* : Integer }{ ; *\\** } ) : 4D.Folder<br>**4D.Folder.new** ( *folderConstant* : Integer { ; *\\** } ) : 4D.Folder",
				"Summary": "creates and returns a new object of the `4D.Folder` type"
			}
		},
		"IMAPTransporter": {
			"new()": {
				"Syntax": "**4D.IMAPTransporter.new**( *server* : Object ) : 4D.IMAPTransporter",
				"Params": [
					[
						"server",
						"Object",
						"->",
						"Mail server information"
					],
					[
						"Result",
						"4D.IMAPTransporter",
						"<-",
						"IMAP transporter object"
					]
				],
				"Summary": "creates and returns a new object of the `4D.IMAPTransporter` type"
			}
		},
		"POP3Transporter": {
			"new()": {
				"Syntax": "**4D.POP3Transporter.new**( *server* : Object ) : 4D.POP3Transporter",
				"Params": [
					[
						"server",
						"Object",
						"->",
						"Mail server information"
					],
					[
						"Result",
						"4D.POP3Transporter",
						"<-",
						"POP3 transporter object"
					]
				],
				"Summary": "creates and returns a new object of the `4D.POP3Transporter` type"
			}
		},
		"SMTPTransporter": {
			"new()": {
				"Syntax": "**4D.SMTPTransporter.new**( *server* : Object ) : 4D.SMTPTransporter",
				"Params": [
					[
						"server",
						"Object",
						"->",
						"Mail server information"
					],
					[
						"Result",
						"4D.SMTPTransporter",
						"<-",
						"SMTP transporter object"
					]
				],
				"Summary": "creates and returns a new object of the `4D.SMTPTransporter` type"
			}
		}
	},
	"Blob": {
		"size": {
			"Syntax": "**.size** : Real",
			"Summary": "returns the size of a `4D.Blob`, expressed in bytes."
		},
		"slice()": {
			"Syntax": "**.slice()** : 4D.Blob<br/>**.slice**( *start* : Real ) : 4D.Blob<br/>**.slice**( *start* : Real; *end* : Real ) : 4D.Blob",
			"Params": [
				[
					"start",
					"Real",
					"->",
					"index of the first byte to include in the new `4D.Blob`."
				],
				[
					"end",
					"Real",
					"->",
					"index of the first byte that will not be included in the new `4D.Blob`"
				],
				[
					"Result",
					"4D.Blob",
					"<-",
					"New `4D.Blob`"
				]
			],
			"Summary": "creates and returns a `4D.Blob ` that references data from a subset of the blob on which it's called. The original blob is not altered."
		}
	},
	"_command_": {
		"Formula": {
			"Syntax": "**Formula** ( *formulaExp* : Expression ) : 4D.Function",
			"Params": [
				[
					"formulaExp",
					"Expression",
					"->",
					"Formula to be returned as object"
				],
				[
					"Result",
					"4D.Function",
					"<-",
					"Native function encapsulating the formula"
				]
			],
			"Summary": "creates a `4D Function` object based upon the *formulaExp* expression"
		},
		"Formula from string": {
			"Syntax": "**Formula from string**( *formulaString* : Text ) : 4D.Function",
			"Params": [
				[
					"formulaString",
					"Text",
					"->",
					"Text formula to be returned as object"
				],
				[
					"Result",
					"4D.Function",
					"<-",
					"Native object encapsulating the formula"
				]
			],
			"Summary": "creates a 4D.Function object based upon the *formulaString*"
		},
		"MAIL_New_attachment": {
			"Syntax": "**MAIL New attachment**( *file* : 4D.File { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br>**MAIL New attachment**( *zipFile* : 4D.ZipFile { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br>**MAIL New attachment**( *blob* : 4D.Blob { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment<br>**MAIL New attachment**( *path* : Text { ; *name* : Text {; *cid* : Text{ ; *type* : Text { ; *disposition* :Text } } } } ) : 4D.MailAttachment",
			"Params": [
				[
					"file",
					"4D.File",
					"->",
					"Attachment file"
				],
				[
					"zipFile",
					"4D.ZipFile",
					"->",
					"Attachment Zipfile"
				],
				[
					"blob",
					"4D.Blob",
					"->",
					"BLOB containing the attachment"
				],
				[
					"path",
					"Text",
					"->",
					"Path of the attachment file"
				],
				[
					"name",
					"Text",
					"->",
					"Name + extension used by the mail client to designate the attachment"
				],
				[
					"cid",
					"Text",
					"->",
					"ID of attachment (HTML messages only), or \" \" if no cid is required"
				],
				[
					"type",
					"Text",
					"->",
					"Value of the content-type header"
				],
				[
					"disposition",
					"Text",
					"->",
					"Value of the content-disposition header: \"inline\" or \"attachment\"."
				],
				[
					"Result",
					"4D.MailAttachment",
					"<-",
					"Attachment object"
				]
			],
			"Summary": "allows you to create an attachment object that you can add to an Email object"
		},
		"New collection": {
			"Syntax": "**New collection** {( *...value* : any )} : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Date, Time, Boolean, Object, Collection, Picture, Pointer",
					"->",
					"Collection's value(s)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"New collection"
				]
			],
			"Summary": "creates a new empty or prefilled collection"
		},
		"New shared collection": {
			"Syntax": "**New shared collection** {( *...value* : any )} : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Date, Time, Boolean, Shared object, Shared collection",
					"->",
					"Shared collection's value(s)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"New shared collection"
				]
			],
			"Summary": "creates a new empty or prefilled shared collection"
		},
		"ds": {
			"Syntax": "**ds** { ( *localID* : Text ) } : cs.DataStore",
			"Params": [
				[
					"localID",
					"Text",
					"->",
					"Local ID of the remote datastore to return"
				],
				[
					"Result",
					"cs.DataStore",
					"<-",
					"Reference to the datastore"
				]
			],
			"Summary": "returns a reference to the datastore matching the current 4D database or the database designated by *localID*"
		},
		"Open datastore": {
			"Syntax": "**Open datastore**( *connectionInfo* : Object ; *localID* : Text ) : cs.DataStore",
			"Params": [
				[
					"connectionInfo",
					"Object",
					"->",
					"Connection properties used to reach the remote datastore"
				],
				[
					"localID",
					"Text",
					"->",
					"Id to assign to the opened datastore on the local application (mandatory)"
				],
				[
					"Result",
					"cs.DataStore",
					"<-",
					"Datastore object"
				]
			],
			"Summary": "connects the application to the 4D database identified by the *connectionInfo* parameter"
		},
		"MAIL_Convert_from_MIME": {
			"Syntax": "**MAIL Convert from MIME**( *mime* : Blob ) : Object<br>**MAIL Convert from MIME**( *mime* : Text ) : Object",
			"Params": [
				[
					"mime",
					"Blob, Text",
					"->",
					"Email in MIME"
				],
				[
					"Result",
					"Object",
					"<-",
					"Email object"
				]
			],
			"Summary": "converts a MIME document into a valid email object"
		},
		"MAIL_Convert_to_MIME": {
			"Syntax": "**MAIL Convert to MIME**( *mail* : Object { ; *options* : Object } ) : Text",
			"Params": [
				[
					"mail",
					"Object",
					"->",
					"Email object"
				],
				[
					"options",
					"Object",
					"->",
					"Charset and encoding mail options"
				],
				[
					"Result",
					"Text",
					"<-",
					"Email object converted to MIME"
				]
			],
			"Summary": "converts an email object into MIME text"
		},
		"Create entity selection": {
			"Syntax": "**Create entity selection** ( *dsTable* : Table { ; *settings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"dsTable",
					"Table",
					"->",
					"Table in the 4D database whose current selection will be used to build the entity selection"
				],
				[
					"settings",
					"Object",
					"->",
					"Build option: context"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"Entity selection matching the dataclass related to the given table"
				]
			]
		},
		"File": {
			"Syntax": "**File** ( *path* : Text { ; *pathType* : Integer }{ ; *\\** } ) : 4D.File<br>**File** ( *fileConstant* : Integer { ; *\\** } ) : 4D.File",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"File path"
				],
				[
					"fileConstant",
					"Integer",
					"->",
					"4D file constant"
				],
				[
					"pathType",
					"Integer",
					"->",
					"`fk posix path` (default) or `fk platform path`"
				],
				[
					"*",
					"",
					"->",
					"* to return file of host database"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"New file object"
				]
			],
			"Summary": "creates and returns a new object of the `4D.File` type"
		},
		"Folder": {
			"Syntax": "**Folder** ( *path* : Text { ; *pathType* : Integer }{ ; *\\** } ) : 4D.Folder<br>**Folder** ( *folderConstant* : Integer { ; *\\** } ) : 4D.Folder",
			"Summary": "creates and returns a new object of the `4D.Folder` type"
		},
		"IMAP New transporter": {
			"Syntax": "**IMAP New transporter**( *server* : Object ) : 4D.IMAPTransporter",
			"Summary": "configures a new IMAP connection"
		},
		"POP3 New transporter": {
			"Syntax": "**POP3 New transporter**( *server* : Object ) : 4D.POP3Transporter",
			"Summary": "configures a new POP3 connection"
		},
		"Session": {
			"Syntax": "**Session** : 4D.Session",
			"Params": [
				[
					"Result",
					"4D.Session",
					"<-",
					"Session object"
				]
			],
			"Summary": "returns the `Session` object corresponding to the current scalable user web session"
		},
		"New signal": {
			"Syntax": "**New signal** { ( *description* : Text ) } : 4D.Signal",
			"Summary": "creates a `4D.Signal` object"
		},
		"SMTP New transporter": {
			"Syntax": "**SMTP New transporter**( *server* : Object ) : 4D.SMTPTransporter",
			"Params": [
				[
					"server",
					"Object",
					"->",
					"Mail server information"
				],
				[
					"Result",
					"4D.SMTPTransporter",
					"<-",
					"SMTP transporter object"
				]
			],
			"Summary": "configures a new SMTP connection"
		},
		"WEB Server": {
			"Syntax": "**WEB Server** : 4D.WebServer<br>**WEB Server**( *option* : Integer ) : 4D.WebServer",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Web server to get (default if omitted = `Web server database`)",
					""
				],
				[
					"Result",
					"4D.WebServer",
					"<-",
					"Web server object"
				]
			],
			"Summary": "returns the default Web server object, or the Web server object defined through the *option* parameter"
		},
		"WEB Server list": {
			"Syntax": "**WEB Server list** : Collection",
			"Params": [
				[
					"Result",
					"Collection",
					"<-",
					"Collection of the available Web server objects"
				]
			],
			"Summary": "returns a collection of all Web server objects available in the 4D application"
		},
		"ZIP Create archive": {
			"Syntax": "**ZIP Create archive** ( *fileToZip* : 4D.File ; *destinationFile* : 4D.File ) : Object<br>**ZIP Create archive** ( *folderToZip* : 4D.Folder ; *destinationFile* : 4D.File { ; *options* : Integer }) : Object<br>**ZIP Create archive** ( *zipStructure* : Object ; *destinationFile* : 4D.File ) : Object",
			"Params": [
				[
					"fileToZip",
					"4D.File",
					"->",
					"File or Folder object to compress"
				],
				[
					"folderToZip",
					"4D.Folder",
					"->",
					"File or Folder object to compress"
				],
				[
					"zipStructure",
					"Object",
					"->",
					"File or Folder object to compress"
				],
				[
					"destinationFile",
					"4D.File",
					"->",
					"Destination file for the archive"
				],
				[
					"options",
					"Integer",
					"->",
					"*folderToZip* option: `ZIP Without enclosing folder`"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status object"
				]
			],
			"Summary": "creates a compressed ZIP archive object and returns the status of the operation"
		},
		"ZIP Read archive": {
			"Syntax": "**ZIP Read archive** ( *zipFile* : 4D.File { ; *password* : Text }) : 4D.ZipArchive",
			"Params": [
				[
					"zipFile",
					"4D.File",
					"->",
					"Zip archive file"
				],
				[
					"password",
					"Text",
					"->",
					"ZIP archive password if any"
				],
				[
					"Result",
					"4D.ZipArchive",
					"<-",
					"Archive object"
				]
			],
			"Summary": "retrieves the contents of *zipFile* and returns it as a `4D.ZipArchive` object"
		}
	},
	"Formula": {
		"apply()": {
			"Syntax": "**.apply**() : any<br>**.apply**( *thisObj* : Object { ; *formulaParams* : Collection } ) : any",
			"Params": [
				[
					"thisObj",
					"Object",
					"->",
					"Object to be returned by the This command in the formula"
				],
				[
					"formulaParams",
					"Collection",
					"->",
					"Collection of values to be passed as $1...$n when `formula` is executed"
				],
				[
					"Result",
					"any",
					"<-",
					"Value from formula execution"
				]
			],
			"Summary": "executes the `formula` object to which it is applied and returns the resulting value"
		},
		"call()": {
			"Syntax": "**.call**() : any<br>**.call**( *thisObj* : Object { ; ...*params* : any } ) : any",
			"Params": [
				[
					"thisObj",
					"Object",
					"->",
					"Object to be returned by the This command in the formula"
				],
				[
					"params",
					"any",
					"->",
					"Value(s) to be passed as $1...$n when formula is executed"
				],
				[
					"Result",
					"any",
					"<-",
					"Value from formula execution"
				]
			],
			"Summary": "executes the `formula` object to which it is applied and returns the resulting value"
		},
		"source": {
			"Syntax": "**.source** : Text",
			"Summary": "contains the source expression of the `formula` as text"
		}
	},
	"MailAttachment": {
		"cid": {
			"Syntax": "**.cid** : Text",
			"Summary": "the ID of the attachment"
		},
		"disposition": {
			"Syntax": "**.disposition** : Text",
			"Summary": "the value of the `Content-Disposition` header"
		},
		"getContent()": {
			"Syntax": "**.getContent()** : 4D.Blob",
			"Params": [
				[
					"Result",
					"4D.Blob",
					"<-",
					"Content of the attachment"
				]
			],
			"Summary": "returns the contents of the attachment object in a `4D.Blob` object"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "the name and extension of the attachment"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "the POSIX path of the attachment file, if it exists"
		},
		"platformPath": {
			"Syntax": "**.platformPath** : Text",
			"Summary": "the path of the attachment file expressed with the current platform syntax"
		},
		"type": {
			"Syntax": "**.type** : Text",
			"Summary": "the `content-type` of the attachment file"
		}
	},
	"Class": {
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "contains the name of the `4D.Class` object"
		},
		"new()": {
			"Syntax": "**.new**( *param* : any { *;...paramN* } ) : 4D.Class",
			"Params": [
				[
					"param",
					"any",
					"->",
					"Parameter(s) to pass to the constructor function"
				],
				[
					"Result",
					"4D.Class",
					"<-",
					"New object of the class"
				]
			],
			"Summary": "creates and returns a `cs.className` object which is a new instance of the class on which it is called"
		},
		"superclass": {
			"Syntax": "**.superclass** : 4D.Class",
			"Summary": "returns the parent class of the class"
		}
	},
	"Collection": {
		"average()": {
			"Syntax": "**.average**( {*propertyPath* : Text } ) : Real",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path to be used for calculation"
				],
				[
					"Result",
					"Real, Undefined",
					"<-",
					"Arithmetic mean (average) of collection values"
				]
			],
			"Summary": "returns the arithmetic mean (average) of defined values in the collection instance"
		},
		"clear()": {
			"Syntax": "**.clear()** : Collection",
			"Params": [
				[
					"Result",
					"Collection",
					"<-",
					"Original collection with all elements removed"
				]
			],
			"Summary": "removes all elements from the collection instance and returns an empty collection"
		},
		"combine()": {
			"Syntax": "**.combine**( *col2* : Collection {; *index* : Integer } ) : Collection",
			"Params": [
				[
					"col2",
					"Collection",
					"->",
					"Collection to combine"
				],
				[
					"index",
					"Integer",
					"->",
					"Position to which insert elements to combine in collection (default=length+1)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Original collection containing combined element(s)"
				]
			],
			"Summary": "inserts *col2* elements at the end or at the specified *index* position in the collection instance and returns the edited collection"
		},
		"concat()": {
			"Syntax": "**.concat**( *value* : any { *;...valueN* } ) : Collection",
			"Params": [
				[
					"value",
					"Number, Text, Object, Collection, Date, Time, Boolean, Picture",
					"->",
					"Value(s) to concatenate. If *value* is a collection, all collection elements are added to the original collection"
				],
				[
					"Result",
					"Collection",
					"<-",
					"New collection with value(s) added to the original collection"
				]
			],
			"Summary": "returns a new collection containing the elements of the original collection with all elements of the *value* parameter added to the end"
		},
		"copy()": {
			"Syntax": "**.copy**() : Collection<br>**.copy**( *option* : Integer ) : Collection<br>**.copy**( *option* : Integer ; *groupWithCol* : Collection ) : Collection<br>**.copy**( *option* : Integer ; *groupWithObj* : Object ) : Collection",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"`ck resolve pointers`: resolve pointers before copying,<br>`ck shared`: return a shared collection"
				],
				[
					"groupWithCol",
					"Collection",
					"->",
					"Shared collection to be grouped with the resulting collection"
				],
				[
					"groupWithObj",
					"Object",
					"->",
					"Shared object to be grouped with the resulting collection"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Deep copy of the original collection"
				]
			],
			"Summary": "returns a deep copy of the collection instance"
		},
		"count()": {
			"Syntax": "**.count**( { *propertyPath* : Text } ) : Real",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path to be used for calculation"
				],
				[
					"Result",
					"Real",
					"<-",
					"Number of elements in the collection"
				]
			],
			"Summary": "returns the number of non-null elements in the collection"
		},
		"countValues()": {
			"Syntax": "**.countValues**( *value* : any {; *propertyPath* : Text } ) : Real",
			"Params": [
				[
					"value",
					"Text, Number, Boolean, Date, Object, Collection",
					"->",
					"Value to count"
				],
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path to be used for calculation"
				],
				[
					"Result",
					"Real",
					"<-",
					"Number of occurrences of the value"
				]
			],
			"Summary": "returns the number of times value is found in the collection"
		},
		"distinct()": {
			"Syntax": "**.distinct**( {*option* : Integer} ) : Collection<br>**.distinct**( *propertyPath* : Text {; *option* : Integer } ) : Collection",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"`ck diacritical`: diacritical evaluation (\"A\" # \"a\" for example)"
				],
				[
					"propertyPath",
					"Text",
					"->",
					"Path of attribute whose distinct values you want to get"
				],
				[
					"Result",
					"Collection",
					"<-",
					"New collection with only distinct values"
				]
			],
			"Summary": "returns a collection containing only distinct (different) values from the original collection"
		},
		"equal()": {
			"Syntax": "**.equal**( *collection2* : Collection {; *option* : Integer } ) : Boolean",
			"Params": [
				[
					"collection2",
					"Collection",
					"->",
					"Collection to compare"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck diacritical`: diacritical evaluation (\"A\" # \"a\" for example)"
				],
				[
					"Result",
					"Boolean",
					"<-",
					"True if collections are identical, false otherwise"
				]
			],
			"Summary": "compares the collection with collection2"
		},
		"every()": {
			"Syntax": "**.every**( *methodName* : Text { ;*...param* : any } ) : Boolean<br>**.every**( *startFrom* : Integer ; *methodName* : Text { ;*...param* : any } ) : Boolean",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the test at"
				],
				[
					"methodName",
					"Text",
					"->",
					"Name of the method to call for the test"
				],
				[
					"param",
					"Mixed",
					"->",
					"Parameter(s) to pass to methodName"
				],
				[
					"Result",
					"Boolean",
					"<-",
					"True if all elements successfully passed the test"
				]
			],
			"Summary": "returns **true** if all elements in the collection successfully passed a test implemented in the provided *methodName* method"
		},
		"extract()": {
			"Syntax": "**.extract**( *propertyPath* : Text { ; *option* : Integer } ) : Collection<br>**.extract**( *propertyPath* : Text ;  *targetPath* : Text  { ;...*propertyPathN* : Text ;... *targetPathN* : Text } ) : Collection",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path whose values must be extracted to the new collection"
				],
				[
					"targetpath",
					"Text",
					"->",
					"Target property path or property name"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck keep null`: include null properties in the returned collection (ignored by default). Parameter ignored if *targetPath* passed."
				],
				[
					"Result",
					"Collection",
					"<-",
					"New collection containing extracted values"
				]
			],
			"Summary": "creates and returns a new collection containing *propertyPath* values extracted from the original collection of objects"
		},
		"fill()": {
			"Syntax": "**.fill**( *value* : any ) : Collection<br>**.fill**( *value* : any ;  *startFrom*  : Integer { ; *end* : Integer } ) : Collection",
			"Params": [
				[
					"value",
					"number, Text, Collection, Object, Date, Boolean",
					"->",
					"Filling value"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Start index (included)"
				],
				[
					"end",
					"Integer",
					"->",
					"End index (not included)"
				],
				[
					"Result",
					"collection",
					"<-",
					"Original collection with filled values"
				]
			],
			"Summary": "fills the collection with the specified *value*, optionally from *startFrom* index to *end* index, and returns the resulting collection"
		},
		"filter()": {
			"Syntax": "**.filter**( *methodName* : Text { ; *...param* : any } ) : Collection",
			"Params": [
				[
					"methodName",
					"Text",
					"->",
					"Name of the function to call to filter the collection"
				],
				[
					"param",
					"Mixed",
					"->",
					"Parameter(s) to pass to *methodName*"
				],
				[
					"Result",
					"Collection",
					"<-",
					"New collection containing filtered elements (shallow copy)"
				]
			],
			"Summary": "returns a new collection containing all elements of the original collection for which *methodName* method result is **true**"
		},
		"find()": {
			"Syntax": "**.find**( *methodName* : Text { ; *...param* : any } ) : any<br>**.find**( *startFrom* : Integer ; *methodName* : Text { ; *...param* : any } ) : any",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the search at"
				],
				[
					"methodName",
					"Text",
					"->",
					"Name of the function to call for the find"
				],
				[
					"param",
					"any",
					"->",
					"Parameter(s) to pass to *methodName*"
				],
				[
					"Result",
					"any",
					"<-",
					"First value found, or Undefined if not found"
				]
			],
			"Summary": "returns the first value in the collection for which *methodName*, applied on each element, returns **true**"
		},
		"findIndex()": {
			"Syntax": "**.findIndex**( *methodName* : Text { ; *...param* : any } ) : Integer<br>**.findIndex**( *startFrom* : Integer ; *methodName* : Text { ; *...param* : any } ) : Integer",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the search at"
				],
				[
					"methodName",
					"Text",
					"->",
					"Name of the function to call for the find"
				],
				[
					"param",
					"any",
					"->",
					"Parameter(s) to pass to *methodName*"
				],
				[
					"Result",
					"Integer",
					"<-",
					"Index of first value found, or -1 if not found"
				]
			],
			"Summary": "returns the index, in the collection, of the first value for which *methodName*, applied on each element, returns **true**"
		},
		"indexOf()": {
			"Syntax": "**.indexOf**(  *toSearch* : expression { ; *startFrom* : Integer } ) : Integer",
			"Params": [
				[
					"toSearch",
					"expression",
					"->",
					"Expression to search in the collection"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the search at"
				],
				[
					"Result",
					"Integer",
					"<-",
					"Index of the first occurrence of toSearch in the collection, -1 if not found"
				]
			],
			"Summary": "searches the *toSearch* expression among collection elements and returns the index of the first found occurrence, or -1 if it was not found"
		},
		"indices()": {
			"Syntax": "**.indices**(  *queryString* : Text { ; *...value* : any } ) : Collection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Search criteria"
				],
				[
					"value",
					"any",
					"->",
					"Value(s) to compare when using placeholder(s)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Element index(es) matching queryString in the collection"
				]
			],
			"Summary": "returns indexes, in the original collection, of object collection elements that match the *queryString* search conditions"
		},
		"insert()": {
			"Syntax": "**.insert**( *index* : Integer ; *element* : any ) : Collection",
			"Params": [
				[
					"index",
					"Integer",
					"->",
					"Where to insert the element"
				],
				[
					"element",
					"any",
					"->",
					"Element to insert in the collection"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Original collection containing inserted element"
				]
			],
			"Summary": "inserts *element* at the specified *index* position in the collection instance and returns the edited collection"
		},
		"join()": {
			"Syntax": "**.join**( *delimiter* : Text { ; *option* : Integer } ) : Text",
			"Params": [
				[
					"delimiter",
					"Text",
					"->",
					"Separator to use between elements"
				],
				[
					"option",
					"Integer",
					"->",
					"`ck ignore null or empty`: ignore null and empty strings in the result"
				],
				[
					"Result",
					"Text",
					"<-",
					"String containing all elements of the collection, separated by delimiter"
				]
			],
			"Summary": "converts all elements of the collection to strings and concatenates them using the specified *delimiter* string as separator"
		},
		"lastIndexOf()": {
			"Syntax": "**.lastIndexOf**( *toSearch* : expression { ; *startFrom* : Integer } ) : Integer",
			"Params": [
				[
					"toSearch",
					"expression",
					"->",
					"The element that is to be searched for within the collection"
				],
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the search at"
				],
				[
					"Result",
					"Integer",
					"<-",
					"Index of last occurrence of toSearch in the collection, -1 if not found"
				]
			],
			"Summary": "searches the *toSearch* expression among collection elements and returns the index of the last occurrence"
		},
		"length": {
			"Syntax": "**.length** : Integer",
			"Summary": "returns the number of elements in the collection"
		},
		"map()": {
			"Syntax": "**.map**( *methodName* : Text { ; *...param* : any } ) : Collection",
			"Params": [
				[
					"methodName",
					"Text",
					"->",
					"Name of method used to transform the collection elements"
				],
				[
					"param",
					"any",
					"->",
					"Parameter(s) for the method"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of transformed values"
				]
			],
			"Summary": "creates a new collection based upon the result of the call of the *methodName* method on each element of the original collection"
		},
		"max()": {
			"Syntax": "**.max**( { *propertyPath* : Text } ) : any",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path to be used for evaluation"
				],
				[
					"Result",
					"Boolean, Text, Number, Collection, Object, Date",
					"<-",
					"Maximum value in the collection"
				]
			],
			"Summary": "returns the element with the highest value in the collection"
		},
		"min()": {
			"Syntax": "**.min**( { *propertyPath* : Text } ) : any",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path to be used for evaluation"
				],
				[
					"Result",
					"Boolean, Text, Number, Collection, Object, Date",
					"<-",
					"Minimum value in the collection"
				]
			],
			"Summary": "returns the element with the smallest value in the collection"
		},
		"orderBy()": {
			"Syntax": "**.orderBy**( ) : Collection<br>**.orderBy**( *pathStrings* : Text ) : Collection<br>**.orderBy**( *pathObjects* : Collection ) : Collection<br>**.orderBy**( *ascOrDesc* : Integer ) : Collection",
			"Params": [
				[],
				[
					"pathStrings",
					"Text",
					"->",
					"Property path(s) on which to order the collection"
				],
				[
					"pathObjects",
					"Collection",
					"->",
					"Collection of criteria objects"
				],
				[
					"ascOrDesc",
					"Integer",
					"->",
					"`ck ascending` or `ck descending` (scalar values)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Ordered copy of the collection (shallow copy)"
				]
			],
			"Summary": "returns a new collection containing all elements of the collection in the specified order"
		},
		"orderByMethod()": {
			"Syntax": "**.orderByMethod**( *methodName* : Text { ; ...*extraParam* : expression } ) : Collection",
			"Params": [
				[
					"methodName",
					"Text",
					"->",
					"Name of method used to specify the sorting order"
				],
				[
					"extraParam",
					"expression",
					"->",
					"Parameter(s) for the method"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Sorted copy of the collection (shallow copy)"
				]
			],
			"Summary": "returns a new collection containing all elements of the collection in the order defined through the *methodName* method"
		},
		"pop()": {
			"Syntax": "**.pop()** : any",
			"Params": [
				[
					"Result",
					"any",
					"<-",
					"Last element of collection"
				]
			],
			"Summary": "removes the last element from the collection and returns it as the function result"
		},
		"push()": {
			"Syntax": "**.push**( *element* : any { ;...*elementN* } ) : Collection",
			"Params": [
				[
					"element",
					"Mixed",
					"->",
					"Element(s) to add to the collection"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Original collection containing added elements"
				]
			],
			"Summary": "appends one or more *element*(s) to the end of the collection instance and returns the edited collection"
		},
		"query()": {
			"Syntax": "**.query**( *queryString* : Text ; *...value* : any ) : Collection<br>**.query**( *queryString* : Text ; *querySettings* : Object ) : Collection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Search criteria"
				],
				[
					"value",
					"Mixed",
					"->",
					"Value(s) to compare when using placeholder(s)"
				],
				[
					"querySettings",
					"Object",
					"->",
					"Query options: parameters, attributes"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Element(s) matching queryString in the collection"
				]
			],
			"Summary": "returns all elements of a collection of objects that match the search conditions"
		},
		"reduce()": {
			"Syntax": "**.reduce**( *methodName* : Text ) : any <br>**.reduce**( *methodName* : Text ; *initValue* : any { ; *...param* : expression } ) : any",
			"Params": [
				[
					"methodName",
					"Text",
					"->",
					"Name of the function to call to process collection elements"
				],
				[
					"initValue",
					"Text, Number, Object, Collection, Date, Boolean",
					"->",
					"Value to use as the first argument to the first call of *methodName*"
				],
				[
					"param",
					"expression",
					"->",
					"Parameter(s) to pass to *methodName*"
				],
				[
					"Result",
					"Text, Number, Object, Collection, Date, Boolean",
					"<-",
					"Result of the accumulator value"
				]
			],
			"Summary": "applies the *methodName* callback method against an accumulator and each element in the collection (from left to right) to reduce it to a single value"
		},
		"remove()": {
			"Syntax": "**.remove**( *index* : Integer { ; *howMany* : Integer } ) : Collection",
			"Params": [
				[
					"index",
					"Integer",
					"->",
					"Element at which to start removal"
				],
				[
					"howMany",
					"Integer",
					"->",
					"Number of elements to remove, or 1 element if omitted"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Original collection without removed element(s)"
				]
			],
			"Summary": "removes one or more element(s) from the specified *index* position in the collection and returns the edited collection"
		},
		"resize()": {
			"Syntax": "**.resize**( *size* : Integer { ; *defaultValue* : any } ) : Collection",
			"Params": [
				[
					"size",
					"Integer",
					"->",
					"New size of the collection"
				],
				[
					"defaultValue",
					"Number, Text, Object, Collection, Date, Boolean",
					"->",
					"Default value to fill new elements"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Resized original collection"
				]
			],
			"Summary": "sets the collection length to the specified new size and returns the resized collection"
		},
		"reverse()": {
			"Syntax": "**.reverse( )** : Collection",
			"Params": [
				[
					"Result",
					"Collection",
					"<-",
					"Inverted copy of the collection"
				]
			],
			"Summary": "returns a deep copy of the collection with all its elements in reverse order"
		},
		"shift()": {
			"Syntax": "**.shift()** : any",
			"Params": [
				[
					"Result",
					"any",
					"<-",
					"First element of collection"
				]
			],
			"Summary": "removes the first element of the collection and returns it as the function result"
		},
		"slice()": {
			"Syntax": "**.slice**( *startFrom* : Integer { ; *end* : Integer } ) : Collection",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the search at (included)"
				],
				[
					"end",
					"Integer",
					"->",
					"End index (not included)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"New collection containing sliced elements (shallow copy)"
				]
			],
			"Summary": "returns a portion of a collection into a new collection"
		},
		"some()": {
			"Syntax": "**.some**( *methodName* : Text { ; *...param* : any } ) : Boolean<br>**.some**( *startFrom* : Integer ; *methodName* : Text { ; *...param* : any } ) : Boolean",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the test at"
				],
				[
					"methodName",
					"Text",
					"->",
					"Name of the method to call for the test"
				],
				[
					"param",
					"Mixed",
					"->",
					"Parameter(s) to pass to *methodName*"
				],
				[
					"Result",
					"Boolean",
					"<-",
					"True if at least one element successfully passed the test"
				]
			],
			"Summary": "returns true if at least one element in the collection successfully passed a test"
		},
		"sort()": {
			"Syntax": "**.sort**( *methodName* : Text { ; *...extraParam* : any } ) : Collection",
			"Params": [
				[
					"methodName",
					"Text",
					"->",
					"Name of method used to specify the sorting order"
				],
				[
					"extraParam",
					"any",
					"->",
					"Parameter(s) for the method"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Original collection sorted"
				]
			],
			"Summary": "sorts the elements of the original collection"
		},
		"sum()": {
			"Syntax": "**.sum**( { *propertyPath* : Text } ) : Real",
			"Params": [
				[
					"propertyPath",
					"Text",
					"->",
					"Object property path to be used for calculation"
				],
				[
					"Result",
					"Real",
					"<-",
					"Sum of collection values"
				]
			],
			"Summary": "returns the sum for all values in the collection instance"
		},
		"unshift()": {
			"Syntax": "**.unshift**( *value* : any { ;...*valueN* : any } ) : Collection",
			"Params": [
				[
					"value",
					"Text, Number, Object, Collection, Date",
					"->",
					"Value(s) to insert at the beginning of the collection"
				],
				[
					"Result",
					"Real",
					"<-",
					"Collection containing added element(s)"
				],
				[]
			],
			"Summary": "inserts the given *value*(s) at the beginning of the collection"
		}
	},
	"CryptoKey": {
		"curve": {
			"Syntax": "**.curve** : Text",
			"Summary": "normalised curve name of the key."
		},
		"decrypt()": {
			"Syntax": "**.decrypt**( *message* : Text ; *options* : Object ) : Object",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message string to be decoded using `options.encodingEncrypted` and decrypted.",
					""
				],
				[
					"options",
					"Object",
					"->",
					"Decoding options"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status"
				]
			],
			"Summary": "decrypts the *message* parameter using the **private** key"
		},
		"encrypt()": {
			"Syntax": "**.encrypt**( *message* : Text ; *options* : Object ) : Text",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message string to be encoded using `options.encodingDecrypted` and encrypted.",
					""
				],
				[
					"options",
					"Object",
					"->",
					"Encoding options"
				],
				[
					"Result",
					"Text",
					"<-",
					"Message encrypted and encoded using the `options.encodingEncrypted`"
				]
			],
			"Summary": "encrypts the *message* parameter using the **public** key"
		},
		"getPrivateKey()": {
			"Syntax": "**.getPrivateKey()** : Text",
			"Params": [
				[
					"Result",
					"Text",
					"<-",
					"Private key in PEM format"
				]
			],
			"Summary": "returns the private key of the `CryptoKey` object"
		},
		"getPublicKey()": {
			"Syntax": "**.getPublicKey( )** : Text",
			"Params": [
				[
					"Result",
					"Text",
					"<-",
					"Public key in PEM format"
				]
			],
			"Summary": "returns the public key of the `CryptoKey` object"
		},
		"pem": {
			"Syntax": "**.pem** : Text",
			"Summary": "PEM definition of an encryption key to load"
		},
		"sign()": {
			"Syntax": ".**sign** (*message* : Text ; *options* : Text) : Text",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message string to sign",
					""
				],
				[
					"options",
					"Object",
					"->",
					"Signing options"
				],
				[
					"Result",
					"Text",
					"<-",
					"Signature in Base64 or Base64URL representation, depending on \"encoding\" option"
				]
			],
			"Summary": "signs the utf8 representation of a *message* string"
		},
		"size": {
			"Syntax": "**.size** : Integer",
			"Summary": "the size of the key in bits"
		},
		"type": {
			"Syntax": "**.type** : Text",
			"Summary": "Name of the key type - \"RSA\", \"ECDSA\", \"PEM\""
		},
		"verify()": {
			"Syntax": "**.verify**( *message* : Text ; *signature* : Text ; *options* : Object) : object",
			"Params": [
				[
					"message",
					"Text",
					"->",
					"Message string that was used to produce the signature",
					""
				],
				[
					"signature",
					"Text",
					"->",
					"Signature to verify, in Base64 or Base64URL representation, depending on `options.encoding` value"
				],
				[
					"options",
					"Object",
					"->",
					"Signing options"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the verification"
				]
			],
			"Summary": "verifies the base64 signature against the utf8 representation of *message*"
		}
	},
	"DataClass": {
		"all()": {
			"Syntax": "**.all** ( { *settings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"settings",
					"Object",
					"->",
					"Build option: context"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"References on all entities related to the Dataclass"
				]
			],
			"Summary": "queries the datastore to find all the entities related to the dataclass and returns them as an entity selection"
		},
		"fromCollection()": {
			"Syntax": "**.fromCollection**( *objectCol* : Collection { ; *settings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"objectCol",
					"Collection",
					"->",
					"Collection of objects to be mapped with entities"
				],
				[
					"settings",
					"Object",
					"->",
					"Build option: context"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"Entity selection filled from the collection"
				]
			],
			"Summary": "updates or creates entities in the dataclass according to the *objectCol* collection of objects, and returns the corresponding entity selection"
		},
		"get()": {
			"Syntax": "**.get**( *primaryKey* : Integer { ; *settings* : Object } ) : 4D.Entity<br>**.get**( *primaryKey* : Text { ; *settings* : Object } ) : 4D.Entity",
			"Params": [
				[
					"primaryKey",
					"Integer OR Text",
					"->",
					"Primary key value of the entity to retrieve"
				],
				[
					"settings",
					"Object",
					"->",
					"Build option: context"
				],
				[
					"Result",
					"4D.Entity",
					"<-",
					"Entity matching the designated primary key"
				]
			],
			"Summary": "queries the dataclass to retrieve the entity matching the *primaryKey* parameter"
		},
		"getDataStore()": {
			"Syntax": "**.getDataStore()** : cs.DataStore",
			"Params": [
				[
					"Result",
					"cs.DataStore",
					"<-",
					"Datastore of the dataclass"
				]
			],
			"Summary": "returns the datastore for the specified dataclass"
		},
		"getInfo()": {
			"Syntax": "**.getInfo()** : Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Information on the dataclass"
				]
			],
			"Summary": "returns an object providing information about the dataclass"
		},
		"new()": {
			"Syntax": "**.new()** : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"New entity matching the Dataclass"
				]
			],
			"Summary": "creates in memory and returns a new blank entity related to the Dataclass"
		},
		"newSelection()": {
			"Syntax": "**.newSelection**( { *keepOrder* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"keepOrder",
					"Integer",
					"->",
					"`dk keep ordered`: creates an ordered entity selection,<br>`dk non ordered`: creates an unordered entity selection (default if omitted)"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New blank entity selection related to the dataclass"
				]
			],
			"Summary": "creates a new, blank, non-shareable entity selection, related to the dataclass, in memory"
		},
		"query()": {
			"Syntax": "**.query**( *queryString* : Text { ; *...value* : any } { ; *querySettings* : Object } ) : 4D.EntitySelection <br>**.query**( *formula* : Object { ; *querySettings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Search criteria as string"
				],
				[
					"formula",
					"Object",
					"->",
					"Search criteria as formula object"
				],
				[
					"value",
					"any",
					"->",
					"Value(s) to use for indexed placeholder(s)"
				],
				[
					"querySettings",
					"Object",
					"->",
					"Query options: parameters, attributes, args, allowFormulas, context, queryPath, queryPlan"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection made up of entities from dataclass meeting the search criteria specified in *queryString* or *formula*"
				]
			],
			"Summary": "searches for entities that meet the search criteria specified in *queryString* or *formula* and (optionally) *value*(s)"
		}
	},
	"DataStore": {
		"cancelTransaction()": {
			"Syntax": "**.cancelTransaction()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "cancels the transaction"
		},
		"encryptionStatus()": {
			"Syntax": "**.encryptionStatus()**: Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Information about the encryption of the current datastore and of each table"
				]
			],
			"Summary": "returns an object providing the encryption status for the current data file"
		},
		"getInfo()": {
			"Syntax": "**.getInfo()**: Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Datastore properties"
				]
			],
			"Summary": "returns an object providing information about the datastore"
		},
		"getRequestLog()": {
			"Syntax": "**.getRequestLog()** : Collection",
			"Params": [
				[
					"Result",
					"Collection",
					"<-",
					"Collection of objects, where each object describes a request"
				]
			],
			"Summary": "returns the ORDA requests logged in memory on the client side"
		},
		"isAdminProtected()": {
			"Syntax": "**.isAdminProtected()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if the Data Explorer access is disabled, False if it is enabled (default)"
				]
			],
			"Summary": "returns `True` if Data Explorer access has been disabled for the working session"
		},
		"makeSelectionsAlterable()": {
			"Syntax": "**.makeSelectionsAlterable()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "sets all entity selections as alterable by default in the current application datastores"
		},
		"provideDataKey()": {
			"Syntax": "**.provideDataKey**( *curPassPhrase* : Text ) : Object <br>**.provideDataKey**( *curDataKey* : Object ) : Object",
			"Params": [
				[
					"curPassPhrase",
					"Text",
					"->",
					"Current encryption passphrase"
				],
				[
					"curDataKey",
					"Object",
					"->",
					"Current data encryption key"
				],
				[
					"Result",
					"Object",
					"<-",
					"Result of the encryption key matching"
				]
			],
			"Summary": "allows providing a data encryption key for the current data file of the datastore and detects if the key matches the encrypted data"
		},
		"setAdminProtection()": {
			"Syntax": "**.setAdminProtection**( *status* : Boolean )",
			"Params": [
				[
					"status",
					"Boolean",
					"->",
					"True to disable Data Explorer access to data on the `webAdmin` port, False (default) to grant access"
				]
			],
			"Summary": "allows disabling any data access on the web admin port, including for the Data Explorer in `WebAdmin` sessions"
		},
		"startRequestLog()": {
			"Syntax": "**.startRequestLog**()<br>**.startRequestLog**( *file* : 4D.File )<br>**.startRequestLog**( *reqNum* : Integer )",
			"Params": [
				[
					"file",
					"4D.File",
					"->",
					"File object"
				],
				[
					"reqNum",
					"Integer",
					"->",
					"Number of requests to keep in memory"
				]
			],
			"Summary": "starts the logging of ORDA requests on the client side"
		},
		"startTransaction()": {
			"Syntax": "**.startTransaction()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "starts a transaction in the current process on the database matching the datastore to which it applies"
		},
		"stopRequestLog()": {
			"Syntax": "**.stopRequestLog()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "stops any logging of ORDA requests on the client side"
		},
		"validateTransaction()": {
			"Syntax": "**.validateTransaction()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "accepts the transaction"
		}
	},
	"Directory": {
		"creationDate": {
			"Syntax": "**.creationDate** : Date",
			"Summary": "the creation date of the folder"
		},
		"creationTime": {
			"Syntax": "**.creationTime** : Time",
			"Summary": "the creation time of the folder"
		},
		"exists": {
			"Syntax": "**.exists** : Boolean",
			"Summary": "true if the folder exists on disk"
		},
		"extension": {
			"Syntax": "**.extension** : Text",
			"Summary": "returns the extension of the folder name (if any)"
		},
		"fullName": {
			"Syntax": "**.fullName** : Text",
			"Summary": "returns the full name of the folder, including its extension (if any)"
		},
		"hidden": {
			"Syntax": "**.hidden** : Boolean",
			"Summary": "true if the folder is set as \"hidden\" at the system level"
		},
		"isAlias": {
			"Syntax": "**.isAlias** : Boolean",
			"Summary": "always **false** for a `Folder` object"
		},
		"isFile": {
			"Syntax": "**.isFile** : Boolean",
			"Summary": "always **false** for a folder"
		},
		"isFolder": {
			"Syntax": "**.isFolder** : Boolean",
			"Summary": "always **true** for a folder"
		},
		"isPackage": {
			"Syntax": "**.isPackage** : Boolean",
			"Summary": "true if the folder is a package on macOS  (and exists on disk)"
		},
		"modificationDate": {
			"Syntax": "**.modificationDate** : Date",
			"Summary": "the date of the folder's last modification"
		},
		"modificationTime": {
			"Syntax": "**.modificationTime** : Time",
			"Summary": "the time of the folder's last modification"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "the name of the folder, without extension (if any)"
		},
		"original": {
			"Syntax": "**.original** : 4D.Folder",
			"Summary": "the same Folder object as the folder"
		},
		"parent": {
			"Syntax": "**.parent** : 4D.Folder",
			"Summary": "the parent folder object of the folder"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "the POSIX path of the folder"
		},
		"platformPath": {
			"Syntax": "**.platformPath** : Text",
			"Summary": "the path of the folder expressed with the current platform syntax"
		},
		"copyTo()": {
			"Syntax": "**.copyTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } { ; *overwrite* : Integer } ) : 4D Folder",
			"Params": [
				[
					"destinationFolder",
					"4D.Folder",
					"->",
					"Destination folder"
				],
				[
					"newName",
					"Text",
					"->",
					"Name for the copy"
				],
				[
					"overwrite",
					"Integer",
					"->",
					"`fk overwrite` to replace existing elements"
				],
				[
					"Result",
					"4D.Folder",
					"<-",
					"Copied file or folder"
				]
			],
			"Summary": "copies the `Folder` object into the specified *destinationFolder*"
		},
		"file()": {
			"Syntax": "**.file**( *path* : Text ) : 4D.File",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"Relative POSIX file pathname"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"`File` object (null if invalid path)"
				]
			],
			"Summary": "a `File` object inside the `Folder` object and returns its reference"
		},
		"files()": {
			"Syntax": "**.files**( { *options* : Integer } ) : Collection",
			"Params": [
				[
					"options",
					"Integer",
					"->",
					"File list options"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of children file objects"
				]
			],
			"Summary": "a collection of `File` objects contained in the folder"
		},
		"folder()": {
			"Syntax": "**.folder**( *path* : Text ) : 4D.Folder",
			"Params": [
				[
					"path",
					"Text",
					"->",
					"Relative POSIX file pathname"
				],
				[
					"Result",
					"4D.Folder",
					"<-",
					"Created folder object (null if invalid *path*)"
				]
			],
			"Summary": "creates a `Folder` object inside the parent `Folder` object and returns its reference"
		},
		"folders()": {
			"Syntax": "**.folders**( { *options* : Integer } ) : Collection",
			"Params": [
				[
					"options",
					"Integer",
					"->",
					"Folder list options"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of children folder objects"
				]
			],
			"Summary": "returns a collection of `Folder` objects contained in the parent folder"
		},
		"getIcon()": {
			"Syntax": "**.getIcon**( { *size* : Integer } ) : Picture",
			"Params": [
				[
					"size",
					"Integer",
					"->",
					"Side length for the returned picture (pixels)"
				],
				[
					"Result",
					"Picture",
					"<-",
					"Icon"
				]
			],
			"Summary": "returns the icon of the folder"
		}
	},
	"Document": {
		"creationDate": {
			"Syntax": "**.creationDate** : Date",
			"Summary": "the creation date of the file"
		},
		"creationTime": {
			"Syntax": "**.creationTime** : Time",
			"Summary": "the creation  time of the file"
		},
		"exists": {
			"Syntax": "**.exists** : Boolean",
			"Summary": "true if the file exists on disk"
		},
		"extension": {
			"Syntax": "**.extension** : Text",
			"Summary": "the extension of the file name (if any)"
		},
		"fullName": {
			"Syntax": "**.fullName** : Text",
			"Summary": "the full name of the file, including its extension (if any)"
		},
		"hidden": {
			"Syntax": "**.hidden** : Boolean",
			"Summary": "true if the file is set as \"hidden\" at the system level"
		},
		"isAlias": {
			"Syntax": "**.isAlias** : Boolean",
			"Summary": "true if the file is an alias, a shortcut, or a symbolic link"
		},
		"isFile": {
			"Syntax": "**.isFile** : Boolean",
			"Summary": "always true for a file"
		},
		"isFolder": {
			"Syntax": "**.isFolder** : Boolean",
			"Summary": "always false for a file"
		},
		"isWritable": {
			"Syntax": "**.isWritable** : Boolean",
			"Summary": "true if the file exists on disk and is writable"
		},
		"modificationDate": {
			"Syntax": "**.modificationDate** : Date",
			"Summary": "the date of the file's last modification"
		},
		"modificationTime": {
			"Syntax": "**.modificationTime** : Time",
			"Summary": "the time of the file's last modification"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "the name of the file without extension (if any)"
		},
		"original": {
			"Syntax": "**.original** : 4D.File<br>**.original** : 4D.Folder",
			"Summary": "the target element for an alias, a shortcut, or a symbolic link file"
		},
		"parent": {
			"Syntax": "**.parent** : 4D.Folder",
			"Summary": "the parent folder object of the file"
		},
		"path": {
			"Syntax": "**.path** : Text",
			"Summary": "the POSIX path of the file"
		},
		"platformPath": {
			"Syntax": "**.platformPath** : Text",
			"Summary": "the path of the file expressed with the current platform syntax"
		},
		"size": {
			"Syntax": "**.size** : Real",
			"Summary": "the size of the file expressed in bytes"
		},
		"copyTo()": {
			"Syntax": "**.copyTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } { ; *overwrite* : Integer } ) : 4D.File",
			"Params": [
				[
					"destinationFolder",
					"4D.Folder",
					"->",
					"Destination folder"
				],
				[
					"newName",
					"Text",
					"->",
					"Name for the copy"
				],
				[
					"overwrite",
					"Integer",
					"->",
					"`fk overwrite` to replace existing elements"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"Copied file"
				]
			],
			"Summary": "copies the `File` object into the specified *destinationFolder*"
		},
		"getContent()": {
			"Syntax": "**.getContent( )** : 4D.Blob",
			"Params": [
				[
					"Result",
					"4D.Blob",
					"<-",
					"File content"
				]
			],
			"Summary": "returns a `4D.Blob` object containing the entire content of a file"
		},
		"getIcon()": {
			"Syntax": "**.getIcon**( { *size* : Integer } ) : Picture",
			"Params": [
				[
					"size",
					"Integer",
					"->",
					"Side length for the returned picture (pixels)"
				],
				[
					"Result",
					"Picture",
					"<-",
					"Icon"
				]
			],
			"Summary": "the icon of the file"
		},
		"getText()": {
			"Syntax": "**.getText**( { *charSetName* : Text } { ; } { *breakMode* : integer} ) : Text<br>**.getText**( { *charSetNum* : integer } { ; } { *breakMode* : integer} ) : Text",
			"Params": [
				[
					"charSetName",
					"Text",
					"->",
					"Name of character set"
				],
				[
					"charSetNum",
					"Integer",
					"->",
					"Number of character set"
				],
				[
					"breakMode",
					"Integer",
					"->",
					"Processing mode for line breaks"
				],
				[
					"Result",
					"Text",
					"<-",
					"Text from the document"
				]
			],
			"Summary": "returns the contents of the file as text"
		}
	},
	"EmailObjectClass": {
		"attachments": {
			"Syntax": "**.attachments** : Collection",
			"Summary": "collection of `4D.MailAttachment` object(s)"
		},
		"bcc": {
			"Syntax": "**.bcc** : Text<br>**.bcc** : Object<br>**.bcc** : Collection",
			"Summary": "Blind Carbon Copy (BCC) hidden email recipient addresse(s) of the email"
		},
		"bodyStructure": {
			"Syntax": "**.bodyStructure** : Object",
			"Summary": "*EmailBodyPart* object, i.e. the full MIME structure of the message body (optional)"
		},
		"bodyValues": {
			"Syntax": "**.bodyValues** : Object",
			"Summary": "*EmailBodyValue* object, containing an object for each \\<partID\\> of `bodyStructure` (optional)"
		},
		"cc": {
			"Syntax": "**.cc** : Text<br>**.cc** : Object<br>**.cc** : Collection",
			"Summary": "Carbon Copy (CC) additional email recipient addresse(s) of the email"
		},
		"comments": {
			"Syntax": "**.comments** : Text",
			"Summary": "additional comments header"
		},
		"from": {
			"Syntax": "**.from** : Text<br>**.from** : Object<br>**.from** : Collection",
			"Summary": "Originating address(es) of the email"
		},
		"headers": {
			"Syntax": "**.headers** : Collection",
			"Summary": "collection of `EmailHeader` objects, in the order they appear in the message"
		},
		"htmlBody": {
			"Syntax": "**.htmlBody** : Text",
			"Summary": "HTML representation of the email message (default charset is UTF-8) (optional, SMTP only)"
		},
		"id": {
			"Syntax": "**.id** : Text",
			"Summary": "unique ID from the IMAP server"
		},
		"inReplyTo": {
			"Syntax": "**.inReplyTo** : Text",
			"Summary": "message identifier(s) of the original message(s) to which the current message is a reply"
		},
		"keywords": {
			"Syntax": "**.keywords** : Object",
			"Summary": "set of keywords as an object, where each property name is a keyword and each value is true"
		},
		"messageId": {
			"Syntax": "**.messageId** : Text",
			"Summary": "message identifier header (\"message-id\")"
		},
		"receivedAt": {
			"Syntax": "**.receivedAt** : Text",
			"Summary": "timestamp of the email's arrival on the IMAP server in ISO 8601 UTC format (ex: 2020-09-13T16:11:53Z)"
		},
		"references": {
			"Syntax": "**.references** : Collection",
			"Summary": "Collection of all message-ids of messages in the preceding reply chain"
		},
		"replyTo": {
			"Syntax": "**.replyTo** : Text<br>**.replyTo** : Object<br>**.replyTo** : Collection",
			"Summary": "addresse(s) for responses"
		},
		"sendAt": {
			"Syntax": "**.sendAt** : Text",
			"Summary": "Email timestamp in ISO 8601 UTC format"
		},
		"sender": {
			"Syntax": "**.sender** : Text<br>**.sender** : Object<br>**.sender** : Collection",
			"Summary": "email source addresse(s) of the email"
		},
		"size": {
			"Syntax": "**.size** : Integer",
			"Summary": "size (expressed in bytes) of the Email object returned by the IMAP server"
		},
		"subject": {
			"Syntax": "**.subject** : Text",
			"Summary": "description of topic"
		},
		"textBody": {
			"Syntax": "**.textBody** : Text",
			"Summary": "Plain text representation of the email message (default charset is UTF-8) (optional, SMTP only)"
		},
		"to": {
			"Syntax": "**.to** : Text<br>**.to** : Object<br>**.to** : Collection",
			"Summary": "primary recipient addresse(s) of the email"
		}
	},
	"Entity": {
		"clone()": {
			"Syntax": "**.clone()** : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"New entity referencing the record"
				],
				[]
			],
			"Summary": "creates in memory a new entity referencing the same record as the original entity"
		},
		"diff()": {
			"Syntax": "**.diff**( *entityToCompare* : 4D.Entity { ; *attributesToCompare* : Collection } ) : Collection",
			"Params": [
				[
					"entityToCompare",
					"4D.Entity",
					"->",
					"Entity to be compared with the original entity",
					""
				],
				[
					"attributesToCompare",
					"Collection",
					"->",
					"Name of attributes to be compared"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Differences between the entities"
				]
			],
			"Summary": "compares the contents of two entities and returns their differences"
		},
		"drop()": {
			"Syntax": "**.drop**( {*mode* : Integer} ) : Object",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk force drop if stamp changed`: Forces the drop even if the stamp has changed"
				],
				[
					"Result",
					"Object",
					"<-",
					"Result of drop operation"
				]
			],
			"Summary": "deletes the data contained in the entity from the datastore"
		},
		"first()": {
			"Syntax": "**.first()**: 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"Reference to first entity of an entity selection (Null if not found)"
				]
			],
			"Summary": "returns a reference to the entity in first position of the entity selection which the entity belongs to"
		},
		"fromObject()": {
			"Syntax": "**.fromObject**( *filler* : Object )",
			"Params": [
				[
					"filler",
					"Object",
					"->",
					"Object from which to fill the entity"
				]
			],
			"Summary": "fills an entity with the *filler* content"
		},
		"getDataClass()": {
			"Syntax": "**.getDataClass()** : 4D.DataClass",
			"Params": [
				[
					"Result",
					"4D.DataClass",
					"<-",
					"DataClass object to which the entity belongs"
				]
			],
			"Summary": "returns the dataclass of the entity"
		},
		"getKey()": {
			"Syntax": "**.getKey**( { *mode* : Integer } ) : Text<br>**.getKey**( { *mode* : Integer } ) : Integer",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk key as string`: primary key is returned as a string, no matter the primary key type"
				],
				[
					"Result",
					"Text",
					"<-",
					"Value of the text primary key of the entity"
				],
				[
					"Result",
					"Integer",
					"<-",
					"Value of the numeric primary key of the entity"
				]
			],
			"Summary": "returns the primary key value of the entity"
		},
		"getSelection()": {
			"Syntax": "**.getSelection()**: 4D.EntitySelection",
			"Params": [
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"Entity selection to which the entity belongs (Null if not found)"
				]
			],
			"Summary": "returns the entity selection which the entity belongs to"
		},
		"getStamp()": {
			"Syntax": "**.getStamp()** : Integer",
			"Params": [
				[
					"Result",
					"Integer",
					"<-",
					"Stamp of the entity (0 if entity has just been created)"
				]
			],
			"Summary": "returns the current value of the stamp of the entity"
		},
		"indexOf()": {
			"Syntax": "**.indexOf**( { *entitySelection* : 4D.EntitySelection } ) : Integer",
			"Params": [
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Position of the entity is given according to this entity selection"
				],
				[
					"Result",
					"Integer",
					"<-",
					"Position of the entity in an entity selection"
				]
			],
			"Summary": "returns the position of the entity in an entity selection"
		},
		"isNew()": {
			"Syntax": "**.isNew()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if entity has just been created and not yet saved. Otherwise, False."
				]
			],
			"Summary": "returns True if the entity to which it is applied has just been created and has not yet been saved in the datastore"
		},
		"last()": {
			"Syntax": "**.last()** : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"Reference to last entity of an entity selection (Null if not found)"
				]
			],
			"Summary": "returns a reference to the entity in last position of the entity selection which the entity belongs to"
		},
		"lock()": {
			"Syntax": "**.lock**( { *mode* : Integer } ) : Object",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk reload if stamp changed`: Reload before locking if stamp changed"
				],
				[
					"Result",
					"Object",
					"<-",
					"Result of lock operation"
				]
			],
			"Summary": "puts a pessimistic lock on the record referenced by the entity"
		},
		"next()": {
			"Syntax": "**.next()** : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"Reference to next entity in the entity selection (Null if not found)"
				]
			],
			"Summary": "returns a reference to the next entity in the entity selection which the entity belongs to"
		},
		"previous()": {
			"Syntax": "**.previous()**  : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"Reference to previous entity in the entity selection (Null if not found)"
				]
			],
			"Summary": "returns a reference to the previous entity in the entity selection which the entity belongs to"
		},
		"reload()": {
			"Syntax": "**.reload()** : Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Status object"
				]
			],
			"Summary": "reloads the content of the entity in memory"
		},
		"save()": {
			"Syntax": "**.save**( { *mode* : Integer } ) : Object",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk auto merge`: Enables the automatic merge mode"
				],
				[
					"Result",
					"Object",
					"<-",
					"Result of save operation"
				]
			],
			"Summary": "saves the changes made to the entity"
		},
		"toObject()": {
			"Syntax": "**.toObject**() : Object<br>**.toObject**( *filterString* : Text { ; *options* : Integer}  ) : Object<br>**.toObject**( *filterCol* : Collection { ; *options* : Integer } ) : Object",
			"Params": [
				[
					"filterString",
					"Text",
					"->",
					"Attribute(s) to extract (comma-separated string)",
					""
				],
				[
					"filterCol",
					"Collection",
					"->",
					"Collection of attribute(s) to extract",
					""
				],
				[
					"options",
					"Integer",
					"->",
					"`dk with primary key`: adds the \\_KEY property;<br>`dk with stamp`: adds the \\_STAMP property"
				],
				[
					"Result",
					"Object",
					"<-",
					"Object built from the entity"
				]
			],
			"Summary": "returns an object which has been built from the entity"
		},
		"touched()": {
			"Syntax": "**.touched()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if at least one entity attribute has been modified and not yet saved, else False"
				]
			],
			"Summary": "tests whether or not an entity attribute has been modified since the entity was loaded into memory or saved"
		},
		"touchedAttributes()": {
			"Syntax": "**.touchedAttributes()** : Collection",
			"Params": [
				[
					"Result",
					"Collection",
					"<-",
					"Names of touched attributes, or empty collection"
				]
			],
			"Summary": "returns the names of the attributes that have been modified since the entity was loaded into memory"
		},
		"unlock()": {
			"Syntax": "**.unlock()** : Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Status object"
				]
			],
			"Summary": "removes the pessimistic lock on the record matching the entity"
		}
	},
	"EntitySelection": {
		"add()": {
			"Syntax": "**.add**( *entity* : 4D.Entity ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entity to be added to the entity selection"
				],
				[
					"Result",
					"4D.EntitySelection",
					"->",
					"Entity selection including the added *entity*"
				]
			],
			"Summary": "adds the specified *entity* to the entity selection and returns the modified entity selection"
		},
		"and()": {
			"Syntax": "**.and**( *entity* : 4D.Entity ) : 4D.EntitySelection<br>**.and**( *entitySelection* : 4D.EntitySelection ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entity to intersect with"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection to intersect with",
					""
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection with the result of intersection with logical AND operator"
				]
			],
			"Summary": "combines the entity selection with an *entity* or *entitySelection* parameter using the logical AND operator"
		},
		"average()": {
			"Syntax": "**.average**( *attributePath* : Text ) : Real",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Attribute path to be used for calculation"
				],
				[
					"Result",
					"Real",
					"<-",
					"Arithmetic mean (average) of entity attribute values (Undefined if empty entity selection)"
				]
			],
			"Summary": "returns the arithmetic mean (average) of all the non-null values of *attributePath* in the entity selection"
		},
		"contains()": {
			"Syntax": "**.contains**( *entity* : 4D.Entity ) : Boolean",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entity to evaluate"
				],
				[
					"Result",
					"Boolean",
					"<-",
					"True if the entity belongs to the entity selection, else False"
				]
			],
			"Summary": "returns true if entity reference belongs to the entity selection"
		},
		"count()": {
			"Syntax": "**.count**( *attributePath* : Text ) : Real",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Path of the attribute to be used for calculation"
				],
				[
					"Result",
					"Real",
					"<-",
					"Number of non null *attributePath* values in the entity selection"
				]
			],
			"Summary": "returns the number of entities in the entity selection with a non-null value in *attributePath*"
		},
		"copy()": {
			"Syntax": "**.copy**( { *option* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"`ck shared`: return a shareable entity selection"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"Copy of the entity selection"
				]
			],
			"Summary": "returns a copy of the original entity selection"
		},
		"distinct()": {
			"Syntax": "**.distinct**( *attributePath* : Text { ; *option* : Integer } ) : Collection",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Path of attribute whose distinct values you want to get",
					""
				],
				[
					"option",
					"Integer",
					"->",
					"`dk diacritical`: diacritical evaluation (\"A\" # \"a\" for example)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection with only distinct values"
				]
			],
			"Summary": "returns a collection containing only distinct (different) values from the *attributePath* in the entity selection"
		},
		"drop()": {
			"Syntax": "**.drop**( { *mode* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"mode",
					"Integer",
					"->",
					"`dk stop dropping on first error`: stops method execution on first non-droppable entity"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"Empty entity selection if successful, else entity selection containing non-droppable entity(ies)"
				],
				[]
			],
			"Summary": "removes the entities belonging to the entity selection from the table related to its dataclass within the datastore"
		},
		"extract()": {
			"Syntax": "**.extract**( *attributePath* : Text { ; *option* : Integer } ) : Collection<br>**.extract**( *attributePath* { ; *targetPath* } { ; *...attributePathN* : Text ; *targetPathN* : Text } ) : Collection",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Attribute path whose values must be extracted to the new collection"
				],
				[
					"targetPath",
					"Text",
					"->",
					"Target attribute path or attribute name",
					""
				],
				[
					"option",
					"Integer",
					"->",
					"`ck keep null`: include null attributes in the returned collection (ignored by default)"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection containing extracted values"
				]
			],
			"Summary": "returns a collection containing *attributePath* values extracted from the entity selection"
		},
		"first()": {
			"Syntax": "**.first()** : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"Reference to the first entity of the entity selection (Null if selection is empty)"
				]
			],
			"Summary": "returns a reference to the entity in the first position of the entity selection"
		},
		"getDataClass()": {
			"Syntax": "**.getDataClass()** : 4D.DataClass",
			"Params": [
				[
					"Result",
					"4D.DataClass",
					"<-",
					"Dataclass object to which the entity selection belongs"
				]
			],
			"Summary": "returns the dataclass of the entity selection"
		},
		"isAlterable()": {
			"Syntax": "**.isAlterable()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if the entity selection is alterable, False otherwise"
				]
			],
			"Summary": "returns True if the entity selection is alterable"
		},
		"isOrdered()": {
			"Syntax": "**.isOrdered()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if the entity selection is ordered, False otherwise"
				]
			],
			"Summary": "returns True if the entity selection is ordered"
		},
		"last()": {
			"Syntax": "**.last()** : 4D.Entity",
			"Params": [
				[
					"Result",
					"4D.Entity",
					"<-",
					"Reference to the last entity of the entity selection (Null if empty entity selection)"
				]
			],
			"Summary": "returns a reference to the entity in last position of the entity selection"
		},
		"length": {
			"Syntax": "**.length** : Integer",
			"Summary": "returns the number of entities in the entity selection"
		},
		"max()": {
			"Syntax": "**.max**( *attributePath* : Text ) : any",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Path of the attribute to be used for calculation"
				],
				[
					"Result",
					"any",
					"<-",
					"Highest value of attribute"
				]
			],
			"Summary": "returns the highest (or maximum) value among all the values of *attributePath* in the entity selection"
		},
		"min()": {
			"Syntax": "**.min**( *attributePath* : Text ) : any",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Path of the attribute to be used for calculation"
				],
				[
					"Result",
					"any",
					"<-",
					"Lowest value of attribute"
				]
			],
			"Summary": "returns the lowest (or minimum) value among all the values of attributePath in the entity selection"
		},
		"minus()": {
			"Syntax": "**.minus**( *entity* : 4D.Entity ) : 4D.EntitySelection<br>**.minus**( *entitySelection* : 4D.EntitySelection ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entity to substract"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection to substract"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection or a new reference on the existing entity selection"
				]
			],
			"Summary": "excludes from the entity selection to which it is applied the *entity* or the entities of *entitySelection* and returns the resulting entity selection"
		},
		"or()": {
			"Syntax": "**.or**( *entity* : 4D.Entity ) : 4D.EntitySelection<br>**.or**( *entitySelection* : 4D.EntitySelection ) : 4D.EntitySelection",
			"Params": [
				[
					"entity",
					"4D.Entity",
					"->",
					"Entity to intersect with"
				],
				[
					"entitySelection",
					"4D.EntitySelection",
					"->",
					"Entity selection to intersect with"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection or new reference to the original entity selection"
				]
			],
			"Summary": "combines the entity selection with the *entity* or *entitySelection* parameter using the logical (not exclusive) OR operator"
		},
		"orderBy()": {
			"Syntax": "**.orderBy**( *pathString* : Text ) : 4D.EntitySelection<br>**.orderBy**( *pathObjects* : Collection ) : 4D.EntitySelection",
			"Params": [
				[
					"pathString",
					"Text",
					"->",
					"Attribute path(s) and sorting instruction(s) for the entity selection",
					""
				],
				[
					"pathObjects",
					"Collection",
					"->",
					"Collection of criteria objects",
					""
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection in the specified order"
				]
			],
			"Summary": "returns a new ordered entity selection containing all entities of the entity selection in the order specified by *pathString* or *pathObjects* criteria"
		},
		"orderByFormula()": {
			"Syntax": "**.orderByFormula**( *formulaString* : Text { ; *sortOrder* : Integer } { ; *settings* : Object} ) : 4D.EntitySelection<br>**.orderByFormula**( *formulaObj* : Object { ; *sortOrder* : Integer } { ; *settings* : Object} ) : 4D.EntitySelection",
			"Params": [
				[
					"formulaString",
					"Text",
					"->",
					"Formula string",
					""
				],
				[
					"formulaObj",
					"Object",
					"->",
					"Formula object",
					""
				],
				[
					"sortOrder",
					"Integer",
					"->",
					"`dk ascending` (default) or `dk descending`",
					""
				],
				[
					"settings",
					"Object",
					"->",
					"Parameter(s) for the formula"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New ordered entity selection"
				]
			],
			"Summary": "returns a new, ordered entity selection"
		},
		"query()": {
			"Syntax": "**.query**( *queryString* : Text { ; *...value* : any } { ; *querySettings* : Object } ) : 4D.EntitySelection <br>**.query**( *formula* : Object { ; *querySettings* : Object } ) : 4D.EntitySelection",
			"Params": [
				[
					"queryString",
					"Text",
					"->",
					"Search criteria as string"
				],
				[
					"formula",
					"Object",
					"->",
					"Search criteria as formula object"
				],
				[
					"value",
					"any",
					"->",
					"Value(s) to use for indexed placeholder(s)"
				],
				[
					"querySettings",
					"Object",
					"->",
					"Query options: parameters, attributes, args, allowFormulas, context, queryPath, queryPlan"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection made up of entities from entity selection meeting the search criteria specified in *queryString* or *formula*"
				]
			],
			"Summary": "searches for entities that meet the search criteria specified in *queryString* or *formula* and (optionally) *value*(s) among all the entities in the entity selection"
		},
		"queryPath": {
			"Syntax": "**.queryPath** : Text",
			"Summary": "contains a detailed description of the query as it was actually performed by 4D"
		},
		"queryPlan": {
			"Syntax": "**.queryPlan** : Text",
			"Summary": "contains a detailed description of the query just before it is executed (i.e., the planned query)"
		},
		"refresh()": {
			"Syntax": "**.refresh()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "immediately \"invalidates\" the entity selection data in the local ORDA cache"
		},
		"slice()": {
			"Syntax": "**.slice**( *startFrom* : Integer { ; *end* : Integer } ) : 4D.EntitySelection",
			"Params": [
				[
					"startFrom",
					"Integer",
					"->",
					"Index to start the operation at (included)"
				],
				[
					"end",
					"Integer",
					"->",
					"End index (not included)"
				],
				[
					"Result",
					"4D.EntitySelection",
					"<-",
					"New entity selection containing sliced entities (shallow copy)"
				]
			],
			"Summary": "returns a portion of an entity selection into a new entity selection"
		},
		"sum()": {
			"Syntax": "**.sum**( *attributePath* : Text ) : Real",
			"Params": [
				[
					"attributePath",
					"Text",
					"->",
					"Path of the attribute to be used for calculation"
				],
				[
					"Result",
					"Real",
					"<-",
					"Sum of entity selection values"
				]
			],
			"Summary": "returns the sum for all *attributePath* values in the entity selection"
		},
		"toCollection()": {
			"Syntax": "**.toCollection**( { *options* : Integer { ; *begin* : Integer { ; *howMany* : Integer } } ) : *Collection*<br>**.toCollection**( *filterString* : Text {; *options* : Integer { ; *begin* : Integer { ; *howMany* : Integer }}} ) : *Collection*<br>**.toCollection**( *filterCol* : Collection {; *options* : Integer { ; *begin* : Integer { ; *howMany* : Integer }}} ) : *Collection*",
			"Params": [
				[
					"filterString",
					"Text",
					"->",
					"String with entity attribute path(s) to extract",
					""
				],
				[
					"filterCol",
					"Collection",
					"->",
					"Collection of entity attribute path(s) to extract",
					""
				],
				[
					"options",
					"Integer",
					"->",
					"`dk with primary key`: adds the primary key<br>`dk with stamp`: adds the stamp",
					""
				],
				[
					"begin",
					"Integer",
					"->",
					"Designates the starting index",
					""
				],
				[
					"howMany",
					"Integer",
					"->",
					"Number of entities to extract"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of objects containing attributes and values of entity selection"
				]
			],
			"Summary": "creates and returns a collection where each element is an object containing a set of properties and values"
		}
	},
	"File": {
		"create()": {
			"Syntax": "**.create()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if the file was created successfully, false otherwise"
				]
			],
			"Summary": "creates a file on disk according to the properties of the `File` object"
		},
		"createAlias()": {
			"Syntax": "**.createAlias**( *destinationFolder* : 4D.Folder ; *aliasName* : Text { ; *aliasType* : Integer } ) : 4D.File",
			"Params": [
				[
					"destinationFolder",
					"4D.Folder",
					"->",
					"Destination folder for the alias or shortcut"
				],
				[
					"aliasName",
					"Text",
					"->",
					"Name of the alias or shortcut"
				],
				[
					"aliasType",
					"Integer",
					"->",
					"Type of the alias link"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"Alias or shortcut file reference"
				]
			],
			"Summary": "creates an alias (macOS) or a shortcut (Windows)"
		},
		"delete()": {
			"Syntax": "**.delete( )**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "deletes the file"
		},
		"getAppInfo()": {
			"Syntax": "**.getAppInfo**() : Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Contents of .exe/.dll version resource or .plist file"
				]
			],
			"Summary": "returns the contents of a **.exe**, **.dll** or **.plist** file information as an object"
		},
		"moveTo()": {
			"Syntax": "**.moveTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } ) : 4D.File",
			"Params": [
				[
					"destinationFolder",
					"4D.Folder",
					"->",
					"Destination folder"
				],
				[
					"newName",
					"Text",
					"->",
					"Full name for the moved file"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"Moved file"
				]
			],
			"Summary": "moves or renames the `File` object into the specified *destinationFolder*"
		},
		"rename()": {
			"Syntax": "**.rename**( *newName* : Text ) : 4D.File",
			"Params": [
				[
					"newName",
					"Text",
					"->",
					"New full name for the file"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"Renamed file"
				]
			],
			"Summary": "renames the file with the name you passed in *newName* and returns the renamed `File` object"
		},
		"setAppInfo()": {
			"Syntax": "**.setAppInfo**( *info* : Object )",
			"Params": [
				[
					"info",
					"Object",
					"->",
					"Properties to write in .exe/.dll version resource or .plist file"
				]
			],
			"Summary": "writes the *info* properties as information contents of a **.exe**, **.dll** or **.plist** file"
		},
		"setContent()": {
			"Syntax": "**.setContent** ( *content* : Blob )",
			"Params": [
				[
					"content",
					"BLOB",
					"->",
					"New contents for the file"
				]
			],
			"Summary": "rewrites the entire content of the file using the data stored in the *content* BLOB"
		},
		"setText()": {
			"Syntax": "**.setText** ( *text* : Text {; *charSetName* : Text { ; *breakMode* : Integer } } )<br>**.setText** ( *text* : Text {; *charSetNum* : Integer { ; *breakMode* : Integer } } )",
			"Params": [
				[
					"text",
					"Text",
					"->",
					"Text to store in the file"
				],
				[
					"charSetName",
					"Text",
					"->",
					"Name of character set"
				],
				[
					"charSetNum",
					"Integer",
					"->",
					"Number of character set"
				],
				[
					"breakMode",
					"Integer",
					"->",
					"Processing mode for line breaks"
				]
			],
			"Summary": "writes *text* as the new contents of the file"
		},
		"_inheritedFrom_": "Document"
	},
	"Folder": {
		"create()": {
			"Syntax": "**.create()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if the folder was created successfully, false otherwise"
				]
			],
			"Summary": "creates a folder on disk according to the properties of the `Folder` object"
		},
		"createAlias()": {
			"Syntax": "**.createAlias**( *destinationFolder* : 4D.Folder ; *aliasName* : Text { ; *aliasType* : Integer } ) : 4D.File",
			"Params": [
				[
					"destinationFolder",
					"4D.Folder",
					"->",
					"Destination folder for the alias or shortcut"
				],
				[
					"aliasName",
					"Text",
					"->",
					"Name of the alias or shortcut"
				],
				[
					"aliasType",
					"Integer",
					"->",
					"Type of the alias link"
				],
				[
					"Result",
					"4D.File",
					"<-",
					"Alias or shortcut reference"
				]
			],
			"Summary": "creates an alias (macOS) or a shortcut (Windows)"
		},
		"delete()": {
			"Syntax": "**.delete**( { *option* : Integer } )",
			"Params": [
				[
					"option",
					"Integer",
					"->",
					"Folder deletion option"
				]
			],
			"Summary": "deletes the folder"
		},
		"moveTo()": {
			"Syntax": "**.moveTo**( *destinationFolder* : 4D.Folder { ; *newName* : Text } ) : 4D.Folder",
			"Params": [
				[
					"destinationFolder",
					"4D.Folder",
					"->",
					"Destination folder"
				],
				[
					"newName",
					"Text",
					"->",
					"Full name for the moved folder"
				],
				[
					"Result",
					"4D.Folder",
					"<-",
					"Moved folder"
				]
			],
			"Summary": "moves or renames the `Folder` object (source folder) into the specified *destinationFolder*"
		},
		"rename()": {
			"Syntax": "**.rename**( *newName* : Text ) : 4D.Folder",
			"Params": [
				[
					"newName",
					"Text",
					"->",
					"New full name for the folder"
				],
				[
					"Result",
					"4D.Folder",
					"<-",
					"Renamed folder"
				]
			],
			"Summary": "renames the folder with the name you passed in *newName* and returns the renamed `Folder` object"
		},
		"_inheritedFrom_": "Directory"
	},
	"IMAPTransporter": {
		"addFlags()": {
			"Syntax": "**.addFlags**( *msgIDs* : Collection ; *keywords* :  Object ) : Object<br>**.addFlags**( *msgIDs* : Text ; *keywords* :  Object ) : Object<br>**.addFlags**( *msgIDs* : Longint  ; *keywords* :  Object ) : Object",
			"Params": [
				[
					"msgIDs",
					"Collection",
					"->",
					"Collection of strings: Message unique IDs (text)<br>Text: Unique ID of a message<br>Longint (IMAP all): All messages in the selected mailbox"
				],
				[
					"keywords",
					"Object",
					"->",
					"Keyword flags to add"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the addFlags operation"
				]
			],
			"Summary": "adds flags to the `msgIDs` for the specified `keywords`"
		},
		"append()": {
			"Syntax": "**.append**( *mailObj* : Object ; *destinationBox* : Text ; *options* : Object ) : Object",
			"Params": [
				[
					"mailObj",
					"Object",
					"->",
					"Email object"
				],
				[
					"destinationBox",
					"Text",
					"->",
					"Mailbox to receive Email object"
				],
				[
					"options",
					"Object",
					"->",
					"Object containing charset info"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the append operation"
				]
			],
			"Summary": "appends a `mailObj` to the `destinationBox`"
		},
		"checkConnectionDelay": {
			"Syntax": "**.checkConnectionDelay** : Integer",
			"Summary": "the maximum time (in seconds) allowed prior to checking the connection to the server"
		},
		"copy()": {
			"Syntax": "**.copy**( *msgsIDs* : Collection ; *destinationBox* : Text ) : Object<br>**.copy**( *allMsgs* : Integer ; *destinationBox* : Text ) : Object",
			"Params": [
				[
					"msgsIDs",
					"Collection",
					"->",
					"Collection of message unique IDs (strings)"
				],
				[
					"allMsgs",
					"Integer",
					"->",
					"`IMAP all`: All messages in the selected mailbox"
				],
				[
					"destinationBox",
					"Text",
					"->",
					"Mailbox to receive copied messages"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the copy operation"
				]
			],
			"Summary": "copies the messages defined by *msgsIDs* or *allMsgs* to the *destinationBox* on the IMAP server"
		},
		"createBox()": {
			"Syntax": "**.createBox**( *name* :  Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Name of the new mailbox"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the mailbox creation operation"
				]
			],
			"Summary": "creates a mailbox with the given `name`"
		},
		"delete()": {
			"Syntax": "**.delete**( *msgsIDs* : Collection ) : Object<br>**.delete**( *allMsgs* : Integer ) : Object",
			"Params": [
				[
					"msgsIDs",
					"Collection",
					"->",
					"Collection of message unique IDs (strings)"
				],
				[
					"allMsgs",
					"Integer",
					"->",
					"`IMAP all`: All messages in the selected mailbox"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the delete operation"
				]
			],
			"Summary": "sets the \"deleted\" flag for the messages defined in `msgsIDs` or `allMsgs`"
		},
		"deleteBox()": {
			"Syntax": "**.deleteBox**( *name* : Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Name of the mailbox to delete"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the mailbox deletion operation"
				]
			],
			"Summary": "permanently removes the mailbox with the given `name` from the IMAP server"
		},
		"expunge()": {
			"Syntax": "**.expunge()** : Object",
			"Summary": "removes all messages with the \"deleted\" flag from the IMAP mail server."
		},
		"getBoxInfo()": {
			"Syntax": "**.getBoxInfo**( { *name* : Text }) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Name of the mailbox"
				],
				[
					"Result",
					"Object",
					"<-",
					"boxInfo object"
				]
			],
			"Summary": "returns a `boxInfo` object corresponding to the mailbox *name*"
		},
		"getBoxList()": {
			"Syntax": "**.getBoxList**( { *parameters* : Object } ) : Collection",
			"Params": [
				[
					"parameters",
					"Object",
					"->",
					"Parameter object"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of mailbox objects"
				]
			],
			"Summary": "returns a collection of mailboxes describing all of the available mailboxes"
		},
		"getDelimiter()": {
			"Syntax": "**.getDelimiter()** : Text",
			"Params": [
				[
					"Result",
					"Text",
					"<-",
					"Hierarchy delimiter character"
				]
			],
			"Summary": "returns the character used to delimit levels of hierarchy in the mailbox name"
		},
		"getMail()": {
			"Syntax": "**.getMail**( *msgNumber*: Integer { ; *options* : Object } ) : Object<br>**.getMail**( *msgID*: Text { ; *options* : Object } ) : Object",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Sequence number of the message"
				],
				[
					"msgID",
					"Text",
					"->",
					"Unique ID of the message"
				],
				[
					"options",
					"Object",
					"->",
					"Message handling instructions"
				],
				[
					"Result",
					"Object",
					"<-",
					"Email object"
				]
			],
			"Summary": "returns the `Email` object corresponding to the *msgNumber* or *msgID* in the mailbox designated by the `IMAP_transporter`"
		},
		"getMails()": {
			"Syntax": "**.getMails**( *ids* : Collection { ; *options* : Object } ) : Object<br>**.getMails**( *startMsg* : Integer ; *endMsg* : Integer { ; *options* : Object } ) : Object",
			"Params": [
				[
					"ids",
					"Collection",
					"->",
					"Collection of message ID"
				],
				[
					"startMsg",
					"Integer",
					"->",
					"Sequence number of the first message"
				],
				[
					"endMsg",
					"Integer",
					"->",
					"Sequence number of the last message"
				],
				[
					"options",
					"Object",
					"->",
					"Message handling instructions"
				],
				[
					"Result",
					"Object",
					"<-",
					"Object containing:<br><ul><li>a collection of Email objects and</li><li>a collection of IDs or numbers for missing messages, if any</li></ul>"
				]
			],
			"Summary": "returns an object containing a collection of `Email` objects"
		},
		"getMIMEAsBlob()": {
			"Syntax": "**.getMIMEAsBlob**( *msgNumber* : Integer { ; *updateSeen* : Boolean } ) : Blob<br>**.getMIMEAsBlob**( *msgID* : Text { ; *updateSeen* : Boolean } ) : Blob",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Sequence number of the message"
				],
				[
					"msgID",
					"Text",
					"->",
					"Unique ID of the message"
				],
				[
					"updateSeen",
					"Boolean",
					"->",
					"If True, the message is marked \"seen\" in the mailbox. If False the message is left untouched."
				],
				[
					"Result",
					"BLOB",
					"<-",
					"Blob of the MIME string returned from the mail server"
				]
			],
			"Summary": "returns a BLOB containing the MIME contents for the message corresponding to the *msgNumber* or *msgID* in the mailbox designated by the `IMAP_transporter`"
		},
		"move()": {
			"Syntax": "**.move**( *msgsIDs* : Collection ; *destinationBox* : Text ) : Object<br>**.move**( *allMsgs* : Integer ; *destinationBox* : Text ) : Object",
			"Params": [
				[
					"msgsIDs",
					"Collection",
					"->",
					"Collection of message unique IDs (strings)"
				],
				[
					"allMsgs",
					"Integer",
					"->",
					"`IMAP all`: All messages in the selected mailbox"
				],
				[
					"destinationBox",
					"Text",
					"->",
					"Mailbox to receive moved messages"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the move operation"
				]
			],
			"Summary": "moves the messages defined by *msgsIDs* or *allMsgs* to the *destinationBox* on the IMAP server"
		},
		"numToID()": {
			"Syntax": "**.numToID**( *startMsg* : Integer ; *endMsg* : Integer ) : Collection",
			"Params": [
				[
					"startMsg",
					"Integer",
					"->",
					"Sequence number of the first message"
				],
				[
					"endMsg",
					"Integer",
					"->",
					"Sequence number of the last message"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of unique IDs"
				]
			],
			"Summary": "converts the sequence numbers to IMAP unique IDs for the messages in the sequential range designated by *startMsg* and *endMsg*"
		},
		"removeFlags()": {
			"Syntax": "**.removeFlags**( *msgIDs* : Collection ; *keywords* :  Object ) : Object<br>**.removeFlags**( *msgIDs* : Text ; *keywords* :  Object ) : Object<br>**.removeFlags**( *msgIDs* : Longint ; *keywords* :  Object ) : Object",
			"Params": [
				[
					"msgIDs",
					"Collection",
					"->",
					"Collection of strings: Message unique IDs (text)<br>Text: Unique ID of a message<br>Longint (IMAP all): All messages in the selected mailbox"
				],
				[
					"keywords",
					"Object",
					"->",
					"Keyword flags to remove"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the removeFlags operation"
				]
			],
			"Summary": "removes flags from the `msgIDs` for the specified `keywords`"
		},
		"renameBox()": {
			"Syntax": "**.renameBox**( *currentName* : Text ; *newName* : Text ) : Object",
			"Params": [
				[
					"currentName",
					"Text",
					"->",
					"Name of the current mailbox"
				],
				[
					"newName",
					"Text",
					"->",
					"New mailbox name"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the renaming operation"
				]
			],
			"Summary": "changes the name of a mailbox on the IMAP server"
		},
		"searchMails()": {
			"Syntax": "**.searchMails**( *searchCriteria* : Text ) : Collection",
			"Params": [
				[
					"searchCriteria",
					"Text",
					"->",
					"Search criteria"
				],
				[
					"Result",
					"Collection",
					"<-",
					"Collection of message numbers"
				]
			],
			"Summary": "searches for messages that match the given *searchCriteria* in the current mailbox"
		},
		"selectBox()": {
			"Syntax": "**.selectBox**( *name* : Text { ; *state* : Integer } ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Name of the mailbox"
				],
				[
					"state",
					"Integer",
					"->",
					"Mailbox access status"
				],
				[
					"Result",
					"Object",
					"<-",
					"boxInfo object"
				]
			],
			"Summary": "selects the `name` mailbox as the current mailbox"
		},
		"subscribe()": {
			"Syntax": "**.subscribe**( *name* : Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Name of the mailbox"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the subscribe operation"
				]
			],
			"Summary": "allows adding or removing of the specified mailbox to/from the IMAP server’s set of “subscribed” mailboxes"
		},
		"unsubscribe()": {
			"Syntax": "**.unsubscribe**( *name* : Text ) : Object",
			"Params": [
				[
					"name",
					"Text",
					"->",
					"Name of the mailbox"
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the unsubscribe operation"
				]
			],
			"Summary": "removes a mailbox from a set of subscribed mailboxes"
		},
		"_inheritedFrom_": "Transporter"
	},
	"POP3Transporter": {
		"delete()": {
			"Syntax": "**.delete**( *msgNumber* : Integer )",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Number of the message to delete"
				]
			],
			"Summary": "flags the *msgNumber* email for deletion from the POP3 server"
		},
		"getBoxInfo()": {
			"Syntax": "**.getBoxInfo()** : Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"boxInfo object"
				]
			],
			"Summary": "returns a `boxInfo` object corresponding to the mailbox designated by the `POP3 transporter`"
		},
		"getMail()": {
			"Syntax": "**.getMail**( *msgNumber* : Integer ) : Object",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Number of the message in the list"
				],
				[
					"Result",
					"Object",
					"<-",
					"Email object"
				]
			],
			"Summary": "returns the `Email` object corresponding to the *msgNumber* in the mailbox designated by the `POP3 transporter`"
		},
		"getMailInfo()": {
			"Syntax": "**.getMailInfo**( *msgNumber* : Integer ) : Object",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Number of the message in the list"
				],
				[
					"Result",
					"Object",
					"<-",
					"mailInfo object"
				]
			],
			"Summary": "returns a `mailInfo` object corresponding  corresponding to the *msgNumber* in the mailbox designated by the `POP3 transporter`"
		},
		"getMailInfoList()": {
			"Syntax": "**.getMailInfoList()** : Collection",
			"Params": [
				[
					"Result",
					"Collection",
					"<-",
					"Collection of `mailInfo` objects"
				]
			],
			"Summary": "returns a collection of `mailInfo` objects describing all messages in the mailbox designated by the `POP3 transporter`"
		},
		"getMIMEAsBlob()": {
			"Syntax": "**.getMIMEAsBlob**( *msgNumber* : Integer ) : Blob",
			"Params": [
				[
					"msgNumber",
					"Integer",
					"->",
					"Number of the message in the list"
				],
				[
					"Result",
					"Blob",
					"<-",
					"Blob of the MIME string returned from the mail server"
				]
			],
			"Summary": "returns a BLOB containing the MIME contents for the message corresponding to the *msgNumber* in the mailbox designated by the `POP3_transporter`"
		},
		"undeleteAll()": {
			"Syntax": "**.undeleteAll()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "removes all delete flags set on the emails in the `POP3_transporter`"
		},
		"_inheritedFrom_": "Transporter"
	},
	"Session": {
		"clearPrivileges()": {
			"Syntax": "**.clearPrivileges()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "removes all the privileges associated to the session"
		},
		"expirationDate": {
			"Syntax": "**.expirationDate** : Text",
			"Summary": "the expiration date and time of the session cookie"
		},
		"hasPrivilege()": {
			"Syntax": "**.hasPrivilege**( *privilege* : Text ) : Boolean",
			"Params": [
				[
					"privilege",
					"Text",
					"<-",
					"Name of the privilege to verify"
				],
				[
					"Result",
					"Boolean",
					"<-",
					"True if session has *privilege*, False otherwise"
				]
			],
			"Summary": "returns True if the privilege is associated to the session, and False otherwise"
		},
		"idleTimeout": {
			"Syntax": "**.idleTimeout** : Integer",
			"Summary": "the inactivity session timeout (in minutes), after which the session is automatically closed by 4D"
		},
		"isGuest()": {
			"Syntax": "**.isGuest()** : Boolean",
			"Params": [
				[
					"Result",
					"Boolean",
					"<-",
					"True if session is a Guest one, False otherwise"
				]
			],
			"Summary": "returns True if the session is a Guest session (i.e. it has no privileges)"
		},
		"setPrivileges()": {
			"Syntax": "**.setPrivileges**( *privilege* : Text )<br>**.setPrivileges**( *privileges* : Collection )<br>**.setPrivileges**( *settings* : Object )",
			"Params": [
				[
					"privilege",
					"Text",
					"->",
					"Privilege name"
				],
				[
					"privileges",
					"Collection",
					"->",
					"Collection of privilege names"
				],
				[
					"settings",
					"Object",
					"->",
					"Object with a \"privileges\" property (string or collection)"
				]
			],
			"Summary": "associates the privilege(s) defined in the parameter to the session"
		},
		"storage": {
			"Syntax": "**.storage** : Object",
			"Summary": "a shared object that can be used to store information available to all requests of the web client"
		},
		"userName": {
			"Syntax": "**.userName** : Text",
			"Summary": "the user name associated to the session"
		}
	},
	"Signal": {
		"description": {
			"Syntax": "**.description** : Text",
			"Summary": "contains a custom description for the `Signal` object."
		},
		"signaled": {
			"Syntax": "**.signaled** : Boolean",
			"Summary": "contains the current state of the `Signal` object"
		},
		"trigger()": {
			"Syntax": "**.trigger( )**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "sets the `signaled` property of the signal object to **true**"
		},
		"wait()": {
			"Syntax": "**.wait**( { *timeout* : Real } ) : Boolean",
			"Params": [
				[
					"timeout",
					"Real",
					"->",
					"Maximum waiting time for the signal in seconds"
				],
				[
					"Result",
					"Boolean",
					"<-",
					"State of the `.signaled` property"
				]
			],
			"Summary": "makes the current process wait until the `.signaled` property of the signal object to become **true** or the optional *timeout* to expire"
		}
	},
	"SMTPTransporter": {
		"keepAlive": {
			"Syntax": "**.keepAlive** : Boolean",
			"Summary": "**True** if the SMTP connection must be kept alive until the `transporter` object is destroyed"
		},
		"send()": {
			"Syntax": "**.send**( *mail* : Object ) : Object",
			"Params": [
				[
					"mail",
					"Object",
					"->",
					"Email to send"
				],
				[
					"Result",
					"Object",
					"<-",
					"SMTP status"
				]
			],
			"Summary": "sends the *mail* object to the SMTP server defined in the `transporter` object and returns a status object"
		},
		"_inheritedFrom_": "Transporter"
	},
	"Transporter": {
		"acceptUnsecureConnection": {
			"Syntax": "**.acceptUnsecureConnection** : Boolean",
			"Summary": "**True** if 4D is allowed to establish an unencrypted connection"
		},
		"authenticationMode": {
			"Syntax": "**.authenticationMode** : Text",
			"Summary": "the authentication mode used to open the session on the mail server"
		},
		"bodyCharset": {
			"Syntax": "**.bodyCharset** : Text",
			"Summary": "the charset and encoding used for the body part of the email"
		},
		"connectionTimeOut": {
			"Syntax": "**.connectionTimeOut** : Integer",
			"Summary": "the maximum wait time (in seconds) allowed to establish a connection to the server"
		},
		"headerCharset": {
			"Syntax": "**.headerCharset** : Text",
			"Summary": "the charset and encoding used for the email header"
		},
		"host": {
			"Syntax": "**.host** : Text",
			"Summary": "the name or the IP address of the host server"
		},
		"logFile": {
			"Syntax": "**.logFile** : Text",
			"Summary": "the path of the extended log file defined (if any) for the mail connection"
		},
		"port": {
			"Syntax": "**.port** : Integer",
			"Summary": "the port number used for mail transactions"
		},
		"sendTimeOut": {
			"Syntax": "**.sendTimeOut** : Integer",
			"Summary": "the maximum wait time (in seconds) of a call to `.send( )` before a timeout occurs"
		},
		"user": {
			"Syntax": "**.user** : Text",
			"Summary": "the user name used for authentication on the mail server"
		},
		"checkConnection()": {
			"Syntax": "**.checkConnection()** : Object",
			"Params": [
				[
					"Result",
					"Object",
					"<-",
					"Status of the transporter object connection"
				]
			],
			"Summary": "checks the connection using information stored in the transporter object"
		}
	},
	"WebServer": {
		"accessKeyDefined": {
			"Syntax": "**.accessKeyDefined** : Boolean",
			"Summary": "true if an access key is defined in the settings of the web server"
		},
		"certificateFolder": {
			"Syntax": "**.certificateFolder** : Text",
			"Summary": "folder where the certificate files are located"
		},
		"characterSet": {
			"Syntax": "**.characterSet** : Number<br>**.characterSet** : Text",
			"Summary": "character set that the 4D Web Server should use to communicate with browsers connecting to the application"
		},
		"cipherSuite": {
			"Syntax": "**.cipherSuite** : Text",
			"Summary": "cipher list used for the secure protocol"
		},
		"CORSEnabled": {
			"Syntax": "**.CORSEnabled** : Boolean",
			"Summary": "CORS (*Cross-origin resource sharing*) service status for the web server"
		},
		"CORSSettings": {
			"Syntax": "**.CORSSettings** : Collection",
			"Summary": "list of allowed hosts and methods for the CORS service"
		},
		"debugLog": {
			"Syntax": "**.debugLog** : Number",
			"Summary": "status of the HTTP request log file"
		},
		"defaultHomepage": {
			"Syntax": "**.defaultHomepage** : Text",
			"Summary": "name of the default home page"
		},
		"HSTSEnabled": {
			"Syntax": "**.HSTSEnabled** : Boolean",
			"Summary": "HTTP Strict Transport Security (HSTS) status"
		},
		"HSTSMaxAge": {
			"Syntax": "**.HSTSMaxAge** : Number",
			"Summary": "maximum length of time (in seconds) that HSTS is active for each new client connection"
		},
		"HTTPCompressionLevel": {
			"Syntax": "**.HTTPCompressionLevel** : Number",
			"Summary": "compression level for all compressed HTTP exchanges for the 4D HTTP server (client requests or server replies)"
		},
		"HTTPCompressionThreshold": {
			"Syntax": "**.HTTPCompressionThreshold** : Number",
			"Summary": "size threshold (bytes) for requests below which exchanges should not be compressed"
		},
		"HTTPEnabled": {
			"Syntax": "**.HTTPEnabled** : Boolean",
			"Summary": "HTTP protocol state"
		},
		"HTTPPort": {
			"Syntax": "**.HTTPPort** : Number",
			"Summary": "listening IP port number for HTTP"
		},
		"HTTPTrace": {
			"Syntax": "**.HTTPTrace** : Boolean",
			"Summary": "activation of `HTTP TRACE`"
		},
		"HTTPSEnabled": {
			"Syntax": "**.HTTPSEnabled** : Boolean",
			"Summary": "HTTPS protocol state"
		},
		"HTTPSPort": {
			"Syntax": "**.HTTPSPort** : Number",
			"Summary": "listening IP port number for HTTPS"
		},
		"inactiveProcessTimeout": {
			"Syntax": "**.inactiveProcessTimeout** : Number",
			"Summary": "life duration (in minutes) of the inactive legacy session processes"
		},
		"inactiveSessionTimeout": {
			"Syntax": "**.inactiveSessionTimeout** : Number",
			"Summary": "life duration (in minutes) of inactive legacy sessions (duration set in cookie)"
		},
		"IPAddressToListen": {
			"Syntax": "**.IPAddressToListen** : Text",
			"Summary": "IP address on which the 4D Web Server will receive HTTP requests"
		},
		"isRunning": {
			"Syntax": "**.isRunning** : Boolean",
			"Summary": "web server running state"
		},
		"keepSession": {
			"Syntax": "**.keepSession** : Boolean",
			"Summary": "True if legacy sessions are enabled in the web server, False otherwise"
		},
		"logRecording": {
			"Syntax": "**.logRecording** : Number",
			"Summary": "log requests (logweb.txt) recording value"
		},
		"maxConcurrentProcesses": {
			"Syntax": "**.maxConcurrentProcesses** : Number",
			"Summary": "maximum number of concurrent web processes supported by the web server"
		},
		"maxRequestSize": {
			"Syntax": "**.maxRequestSize** : Number",
			"Summary": "maximum size (in bytes) of incoming HTTP requests (POST) that the web server is allowed to process"
		},
		"maxSessions": {
			"Syntax": "**.maxSessions** : Number",
			"Summary": "maximum number of simultaneous legacy sessions"
		},
		"minTLSVersion": {
			"Syntax": "**.minTLSVersion** : Number",
			"Summary": "minimum TLS version accepted for connections"
		},
		"name": {
			"Syntax": "**.name** : Text",
			"Summary": "name of the web server application"
		},
		"openSSLVersion": {
			"Syntax": "**.openSSLVersion** : Text",
			"Summary": "version of the OpenSSL library used"
		},
		"perfectForwardSecrecy": {
			"Syntax": "**.perfectForwardSecrecy** : Boolean",
			"Summary": "PFS availability on the server"
		},
		"rootFolder": {
			"Syntax": "**.rootFolder** : Text",
			"Summary": "path of web server root folder"
		},
		"scalableSession": {
			"Syntax": "**.scalableSession** : Boolean",
			"Summary": "True if scalable sessions are used in the web server, and False otherwise"
		},
		"sessionCookieDomain": {
			"Syntax": "**.sessionCookieDomain** : Text",
			"Summary": "\"domain\" field of the session cookie"
		},
		"sessionCookieName": {
			"Syntax": "**.sessionCookieName** : Text",
			"Summary": "name of the cookie used for storing the session ID"
		},
		"sessionCookiePath": {
			"Syntax": "**.sessionCookiePath** : Text",
			"Summary": "\"path\" field of the session cookie"
		},
		"sessionCookieSameSite": {
			"Syntax": "**.sessionCookieSameSite** : Text",
			"Summary": "\"SameSite\" session cookie value"
		},
		"sessionIPAddressValidation": {
			"Syntax": "**.sessionIPAddressValidation** : Boolean",
			"Summary": "IP address validation for session cookies"
		},
		"start()": {
			"Syntax": "**.start**() : Object<br>**.start**( *settings* : Object ) : Object",
			"Params": [
				[
					"settings",
					"Object",
					"->",
					"Web server settings to set at startup",
					""
				],
				[
					"Result",
					"Object",
					"<-",
					"Status of the web server startup"
				]
			],
			"Summary": "starts the web server on which it is applied"
		},
		"stop()": {
			"Syntax": "**.stop()**",
			"Params": [
				[
					"",
					"",
					"",
					"Does not require any parameters"
				]
			],
			"Summary": "stops the web server on which it is applied"
		}
	},
	"ZipArchive": {
		"root": {
			"Syntax": "**.root** : 4D.ZipFolder",
			"Summary": "a virtual folder providing access to the contents of the ZIP archive"
		}
	},
	"ZipFile": {
		"_inheritedFrom_": "Document"
	},
	"ZipFolder": {
		"_inheritedFrom_": "Directory"
	}
}