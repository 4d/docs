---
id: verify-data-file
title: VERIFY DATA FILE
slug: /commands/verify-data-file
displayed_sidebar: docs
---

<!--REF #_command_.VERIFY DATA FILE.Syntax-->**VERIFY DATA FILE** ( *structurePath* ; *dataPath* ; *objects* ; *options* ; *method* {; *tablesArray* {; *fieldsArray*}} )<!-- END REF-->
<!--REF #_command_.VERIFY DATA FILE.Params-->
| 引数 | 型 |  | 説明 |
| --- | --- | --- | --- |
| structurePath | Text | &#8594;  | 検証する4Dストラクチャファイルのパス名 |
| dataPath | Text | &#8594;  | 検証する4Dデータファイルのパス名 |
| objects | Integer | &#8594;  | 検証するオブジェクト |
| options | Integer | &#8594;  | 検証オプション |
| method | Text | &#8594;  | 4Dコールバックメソッド名 |
| tablesArray | Integer array | &#8594;  | 検証するテーブル番号 |
| fieldsArray | 2D Integer array, 2D Integer array, 2D Real array | &#8594;  | 検証するインデックス番号 |

<!-- END REF-->

#### 説明 

<!--REF #_command_.VERIFY DATA FILE.Summary-->**VERIFY DATA FILE**コマンドは、*structurePath*と*dataPath*で指定したデータファイル中にあるオブジェクトの構造的な検証を行います。<!-- END REF-->

**注:** データ検証に関する詳細は、Design Referenceマニュアルを参照してください。

*structurePath*は、 検証するデータファイルに対応するストラクチャーファイル (コンパイル済みまたはインタプリター) を指定します。開かれたストラクチャーや他のストラクチャーを指定できます。OSに対応した完全パス名を指定しなければなりません。空の文字列を渡すと標準のファイルを開くダイアログボックスが表示され、使用するストラクチャーファイルをユーザーが指定できます。

*dataPath* は4Dデータファイル (.4DD) を指定します。データファイルは*structurePath*引数で指定されたストラクチャーファイルに対応していなければなりません。カレントストラクチャーファイルを指定することができますが、カレントのデータファイルは指定できない (開かれていてはいけない) ことに注意してください。現在開かれているデータファイルを検証するためには [VERIFY CURRENT DATA FILE](verify-current-data-file.md) コマンドを使用します。**VERIFY DATA FILE**でカレントのデータファイルを検証しようとすると、エラーが生成されます。

指定されたデータファイルは読み込みのみで開かれます。他のアプリケーションが書き込み可能でこのファイルにアクセスしないようにしなければなりません。そうでなければ検証結果は正しくないものになります。  
*dataPath* 引数に空の文字列、ファイル名、またはOSのシンタックスに対応した完全パス名を渡すことができます。空の文字列を渡すと標準のファイルを開くダイアログ ボックスが表示され、検証するファイルをユーザーが選択できます。カレントのデータファイルを選択できないことに注意してください。データファイル名のみを渡した場合、4Dは指定されたストラクチャファイルと同階層にあるデータファイルを探します。

*objects* 引数は検証するオブジェクトを指定するために使用します。2つのタイプのオブジェクト、レコードとインデックスを検証できます。*Data File Maintenance*テーマの以下の定数を使用できます:  

| 定数             | 型    | 値  | コメント                                                                                                                                                    |
| -------------- | ---- | -- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Verify all     | 倍長整数 | 16 |                                                                                                                                                         |
| Verify indexes | 倍長整数 | 8  | このオプションを使用すると、インデックスの物理的な整合性を検証しますが、データとのリンクは考慮されません。この検証は無効なキーを検知しますが、重複キー (同じレコードを参照する2つのインデックス) を検出することはできません。この検証を行うにはVerify Allオプションを使用しなければなりません。 |
| Verify records | 倍長整数 | 4  |                                                                                                                                                         |

レコードとインデックス両方を検証するにはVerify Records+Verify Indexesを渡します。0を渡しても同じ結果が得られます。Verify Allオプションを指定すると内部的な検証が完全に行われます。この検証はログの作成と互換性があります。

*options* 引数は検証オプションを設定するために使用します。オプションは *Data File Maintenance* テーマの中から指定できます:  

| 定数                      | 型    | 値      | コメント                                                                                                                                                              |
| ----------------------- | ---- | ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Do not create log file  | 倍長整数 | 16384  | 通常このコマンドはXMLフォーマットのログファイルを作成します。このオプションを使用すればログファイルは作成されません。                                                                                                      |
| Timestamp log file name | 倍長整数 | 262144 | このオプションが渡された場合、生成されたログファイルの名前は作成された日時を含みます。結果として、以前に生成されていたログファイルをどれも上書きする事はありません。このオプションが渡されていなかった場合、デフォルトではログファイル名はタイムスタンプされることはなく、生成されたログファイルはそれぞれ古いものを上書きします。 |

通常、**VERIFY DATA FILE** コマンドは XMLフォーマットのログファイルを作成します (このコマンドの最後の説明を参照してください)。このオプションを指定して、ログの作成をキャンセルできます。ログファイルを作成するには、*options*に0を渡します。

*method* 引数には、検証中定期的に呼び出されるコールバックメソッドを設定するために使用します。空の文字列あるいは無効なメソッド名を渡した場合、この引数は無視されます(メソッドは呼び出されません)。コールバックメソッドが呼び出されるときは、検証されるオブジェクトのタイプおよび呼び出し元のイベントタイプにより最大で5つの引数が渡されます(以下の表を参照してください)。コールバックメソッドではこれらの引数を宣言しなければなりません:

| $1 | 倍長整数 | メッセージタイプ (表参照) |
| -- | ---- | -------------- |
| $2 | 倍長整数 | オブジェクトタイプ      |
| $3 | テキスト | メッセージ          |
| $4 | 倍長整数 | テーブル番号         |
| $5 | 倍長整数 | 予約             |

以下の表は、イベントタイプごとの引数の内容を示しています:

| **イベント**  | **$1 (Longint)** | **$2 (Longint)** | **$3 (Text)** | **$4 (Longint)** | **$5 (Longint)** |
| --------- | ---------------- | ---------------- | ------------- | ---------------- | ---------------- |
| メッセージ     | 1                | 0                | 進行状況          | 処理率              | 予約               |
| メッセージ     | (0-100%)         |                  |               |                  |                  |
| 検証終了 (\*) | 2                | オブジェクトタイプ (\*\*) | OKメッセージ       | テーブルまたはインデックス    | 予約               |
| テスト       | 番号               |                  |               |                  |                  |
| エラー       | 3                | オブジェクトタイプ (\*\*) | エラーテキスト-      | テーブルまたはインデックス    | 予約               |
| メッセージ     | 番号               |                  |               |                  |                  |
| 実行終了      | 4                | 0                | 終了            | 0                | 予約               |
| 警告        | 5                | オブジェクトタイプ (\*\*) | エラーテキスト       | テーブルまたはインデックス    | 予約               |
| メッセージ     | 番号               |                  |               |                  |                  |

(\*) モードがVerify Allであるとき、検証終了 ($1=2) が返されることはありません。このメッセージはVerify Records または Verify Indexes モードでのみ使用されます。  
(\*\*) *Object type*: オブジェクトタイプ: オブジェクトが検証されると、OKメッセージ ($1=2)、エラー ($1=3)、警告 ($1=5) が送信されます。$2に返されるオブジェクトタイプは以下のうちのいずれかになります:

* 0 = 不明
* 4 = レコード
* 8 = インデックス
* 16 = ストラクチャオブジェクト (データファイルの予備検証)

特別なケース: $1が2、3、または5のとき、$4が0ならば、それはメッセージがテーブルやインデックスについてではなく、データファイル全体に関するものであることを示します。

コールバックメソッドは$0に倍長整数値を返さなくてはなりません。これは処理の実行をチェックするために使用されます:

* $0 = 0の時、処理は通常通り続行されます。
* $0 = -128の時、処理は停止されますが、エラーは生成されません。
* $0 = 他の値の時、処理が停止され、$0に返された値をエラー番号としてエラーを生成します。このエラーはエラーハンドラメソッドでとらえることができます。

**注:** 実行終了イベント ($4=1) が生成された後、$0を使用して実行を中断させることはできません。

2つのオプションの配列をこのコマンドで利用できます:

* *tablesArray* 配列にはテーブル番号が含まれ、レコードを検証するテーブルを指定するために使用します。この引数は検証するテーブルを制限するために使用します。この引数を渡さないか配列が空の場合で、*objects*引数にVerify Recordsが指定されている場合、すべてのテーブルが検証されます。
* *fieldsArray* 配列には検証対象とするインデックス付きフィールドの番号を渡します。

この引数が渡されないか配列が空の場合で、*objects*引数にVerify Indexesが指定されている場合、すべてのインデックスが検証されます。コマンドはインデックスの無いフィールドを無視します。フィールドに複数のインデックスが含まれる場合、すべてが検証されます。フィールドが複合インデックスの一部である場合、インデックス全体が検証されます。  
*fieldsArray*には二次元配列を渡します。配列の内容は以下の通りです:  
\- 要素 {0} にはテーブル番号が含まれます。  
\- 他の要素 {1...x} にはフィールド番号が含まれます。

デフォルトで**VERIFY DATA FILE**コマンドは、(*options*引数にDo not create log fileオプションが指定されていなければ) XMLフォーマットのログファイルを作成します。このファイルはデータベースの**Logs**フォルダに作成され、名前もカレントデータベースのストラクチャーファイルに基づいたものがつけられます。例えば、“myDB.4db”という名前のストラクチャーファイルに対しては、ログファイルは“myDB\_Verify\_Log.xml”という名前が付けられます。Timestamp log file nameオプションを渡していた場合、ログファイル名には"YYYY-MM-DD HH-MM-SS"という形式で作成時の日時の情報が含まれます。ファイル名は例として次のような形になります:“myDB\_Verify\_Log\_2015-09-27 15-20-35.xml” これはつまりそれぞれの新しいログファイルは以前のものを置き換える事はない一方、不要なファイルを削除するためにはいくつかのファイルを手動で削除しなければならない可能性があることを意味します。  
選択されたオプションに関わらず、ログファイルが生成されるとそのファイルへのパスはコマンド実行後に*Document*システム変数へと返されます。

#### 例題 1 

データとインデックスの検証:

```4d
 VERIFY DATA FILE($StructName;$DataName;Verify indexes+Verify records;Do not create log file;"")
```

#### 例題 2 

完全な検証を行い、ログを作成する:

```4d
 VERIFY DATA FILE($StructName;$DataName;Verify all;0;"")
```

#### 例題 3 

レコードのみの検証:

```4d
 VERIFY DATA FILE($StructName;$DataName;Verify records;0;"")
```

#### 例題 4 

テーブル3と7のレコードのみを検証:  

```4d
 ARRAY LONGINT($arrTableNums;2)
 $arrTableNums{1}:=3
 $arrTableNums{2}:=7
 VERIFY DATA FILE($StructName;$DataName;Verify records;0;"FollowScan";$arrTableNums)
```

#### 例題 5 

特定のインデックスを検証 (\[table4\]field1、\[table5\]field2とfield3):

```4d
 ARRAY LONGINT($arrTableNums;0) //使用しないが必須
 ARRAY LONGINT($arrIndex;2;0) //2行 (列は後で追加)
 $arrIndex{1}{0}:=4 // 要素0にテーブル番号
 APPEND TO ARRAY($arrIndex{1};1) //検証する1番目のフィールド番号
 $arrIndex{2}{0}:=5 // 要素0にテーブル番号
 APPEND TO ARRAY($arrIndex{2};2) // 検証する1番目のフィールド番号
 APPEND TO ARRAY($arrIndex{2};3) // 検証する2番目のフィールド番号
 VERIFY DATA FILE($StructName;$DataName;Verify indexes;0;"FollowScan";$arrTableNums;$arrIndex)
```

#### 例題 6 

データファイルの検証と、ログファイルの作成および表示:

```4d
 VERIFY DATA FILE(Structure file;Data file;Verify all;0;"")
 SHOW ON DISK(File(Verification log file).platformPath)
```

#### システム変数およびセット 

コールバックメソッドが存在しない場合、検証は実行されず、エラーが生成され、OKシステム変数には0が設定されます。ログファイルが生成されていた場合、その完全パス名がDocumentシステム変数へと返されます。

#### 参照 

[VERIFY CURRENT DATA FILE](verify-current-data-file.md)  