---
id: c-collection
title: C_COLLECTION
slug: /commands/c-collection
displayed_sidebar: docs
---

<!--REF #_command_.C_COLLECTION.Syntax-->**C_COLLECTION** ( {*method* ;} *variable* {; *variable2* ; ... ; *variableN*} )<!-- END REF-->
<!--REF #_command_.C_COLLECTION.Params-->
| 引数 | 型 |  | 説明 |
| --- | --- | --- | --- |
| method | メソッド | &#x1F852; | メソッド名 |
| variable | 変数 | &#x1F852; | 宣言する変数、あるいは${...}引数の名前 |

<!-- END REF-->

#### 説明 

<!--REF #_command_.C_COLLECTION.Summary-->**C\_COLLECTION** コマンドは、指定された全ての変数をCollection 型へと割り当てます

Collection 型はv16 R4以降の4Dにおいてサポートされています。<!-- END REF-->この型の変数は、JSON配列として保存された、属性値の並び替えされた一覧を、属性値の型に関係なく格納することができます。

コマンドの第1シンタックス(*method* 引数を渡さない)を使用すると、任意の型のローカル、プロセス、あるいはインタープロセス変数を宣言することができます。このシンタックスはインタープリタモードのデータベースで使用することができます。

コマンドの第2シンタックス(*method* 引数を渡す)を使用すると、メソッドの結果と引数($0、$1、$2、など)を先にコンパイラに対して宣言することができます。データベースのコンパイル時に変数の型指定フェーズを飛ばしたい場合には、こちらのシンタックスを使用する必要があります。

**警告:** 第2シンタックスはインタープリタモードで実行することはできません。そのため、このシンタックスを使用するには、これをインタープリタモードでは実行されない、"COMPILER"で始まる名前を持つメソッドに入れる必要があります。

##### 上級者向け用法 

**C\_COLLECTION**(${...}) のシンタックスを使用すると、同じ型の不定数の引数を宣言することができます。ただしこれらの引数はメソッドの最後の引数でなければなりません。例えば、**C\_COLLECTION**(${5}) という宣言は、4D とコンパイラに対して、5番目の引数以降、メソッドはその型の引数を不定数受け付けることができることを伝えます。詳細な情報については、*引数の間接参照*の章を参照して下さい。

#### 例題 

コレクション型のプロセス変数を宣言し、それを新しいコレクションで満たしたい場合を考えます:

```4d
 C_COLLECTION(myCol)
  //ここでは myCol の値はnull
 myCol:=New collection("Green";100;"Orange";200;"Red";300)
  //myCol= ["Green",100,"Orange",200,"Red",300]
```

#### 参照 

[New collection](new-collection.md)  
*コレクション*  