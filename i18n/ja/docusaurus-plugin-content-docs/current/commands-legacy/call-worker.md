---
id: call-worker
title: CALL WORKER
slug: /commands/call-worker
displayed_sidebar: docs
---

<!--REF #_command_.CALL WORKER.Syntax-->**CALL WORKER** ( *process* ; *formula* {; *param*}{; *param2* ; ... ; *paramN*} )<!-- END REF-->
<!--REF #_command_.CALL WORKER.Params-->
| 引数 | 型 |  | 説明 |
| --- | --- | --- | --- |
| process | Text, Integer | &#8594;  | プロセス番号、またはプロセス名 |
| formula | Object, Text | &#8594;  | 実行するプロジェクトメソッドの名前、または Formulaオブジェクト |
| param | Expression | &#8594;  | メソッドに渡す引数 |

<!-- END REF-->

#### 説明 

<!--REF #_command_.CALL WORKER.Summary-->**CALL WORKER** コマンドは、*process* に受け渡した名称または ID のワーカープロセスを作成、または呼び出して、任意の *param* パラメーターを使って *formula* 引数で指定されたコードの実行をそのコンテキスト内において要求します。<!-- END REF-->

**CALL WORKER** コマンドは *params* をカプセル化し、メッセージの形でワーカーが持つメッセージボックスに受け渡します。ワーカープロセスについての詳細は*ワーカーについて* を参照ください。

*process* パラメーターに指定するプロセス名またはプロセス番号により、ワーカーは特定されます:

* プロセス番号で指定したプロセスが存在しない場合、またはそのプロセスが **CALL WORKER** によって 4Dが作成したものでない場合 (例えばメインのアプリケーションプロセスなど)、**CALL WORKER** は何もしません。
* プロセス名で指定したプロセスが存在しない場合には、新規のワーカープロセスが作成されます。

**注:** ユーザーインターフェースやアプリケーションモードのためにデータベース起動時に4D によって作成されるメイン・プロセスは、**CALL WORKER** によってコールすることのできるワーカープロセスです。ただし、メイン・プロセスのプロセス名は 4D の言語環境により異なるため、**CALL WORKER** を使用する場合にはプロセス番号 (常に 1) で指定することが推奨されます。

ワーカープロセスはランタイムエクスプローラーのプロセスリストに表示されます。また、[Process info](../commands/process-info.md) コマンドはワーカープロセスも対象に実行できます。

*formula* 引数には、ワーカープロセスのコンテキストで実行する4D コードを指定します。以下のいずれかを指定することができます:

* **フォーミュラオブジェクト**(*Formula オブジェクト* を参照のこと)。フォーミュラオブジェクトは実行可能な式であればどんな式も格納することができます。これには関数やプロジェクトメソッドなども含まれます。
* プロジェクトメソッド名を格納した**文字列**。ここで空の文字列を渡すことができます。この場合、ワーカーは元々自身のプロセスを開始するのに使用されたメソッド(あれば)を実行します(言い換えると、ワーカーのスタートアップメソッドを実行します)。注意: コマンドがメインプロセス(プロセス番号1)を呼び出した場合に*formula* 引数に空の文字列を入れることはできません。この場合、プロジェクトメソッドを使用してメインプロセスが開始されたわけではないからです。結果として、 **CALL WORKER* (1;"")* は何もしません。

また*formula* 引数で指定したフォーミュラへの引数を*param* 引数に1つ以上渡すことができます。*順番引数* を使用することもできますし、フォーミュラの式が関数またはプロジェクトメソッドの場合には*名前付き引数* を使用することもできます。プロセスのコンテキスト内で実行が開始されたとき、プロセスフォーミュラは引数の値を名前付きで受け取るか、 *$1*、 *$2*、 の順番に受け取ります。配列は引数としては渡せないという点に注意して下さい。それに加えて**CALL WORKER** コマンドのコンテキストにおいては、以下の追加の制約についても注意する必要があります:

* テーブルまたはフィールドへのポインターは使用できます。
* 変数へのポインター、具体的にはローカル変数またはプロセス変数へのポインターは推奨されていません。これらの値はプロセスメソッドによってアクセスされた瞬間には未定義である可能性があるからです。
* 標準のオブジェクトまたはコレクションについては、その**コピー**が渡されます。つまり4D は、ワーカーのプロセスが**CALL WORKER** コマンドを呼び出したプロセスとは別のプロセスである場合には、指定先のプロセス内においてそのオブジェクトまたはコレクションのコピーを作成します。このコンテキストにおいては、オブジェクトまたはコレクション引数を**参照**として渡したい場合には、共有オブジェクトまたはコレクションを使用する必要があります(*共有オブジェクトと共有コレクション* 参照)。

ワーカープロセスは、アプリケーションが終了するか、あるいは [KILL WORKER](kill-worker.md) をコールされるまで存続します。必要ないワーカーにはこのコマンドを使い、メモリを解放するのがよいでしょう。

#### 例題 

フォーム上に、選択年の統計などの算出をおこなうボタンを設置します。

ボタンはワーカープロセスを作成、あるいは呼び出します。演算はワーカーがおこなうため、ユーザーはフォームの操作を続行できます。

ボタンのメソッドは次のとおりです:

```4d
  // ワーカー myWorker をコールし、実行メソッドと引数を指定します
 var $vYear: Integer
 $vYear:=2015 // この値はフォーム上でユーザーが選択したかもしれません
 CALL WORKER("myWorker";Formula(workerMethod);$vYear;Current form window)
```

*workerMethod* のコードは次のとおりです:

```4d
  // ワーカーが実行するメソッドです
  // プリエンプティブでもコオペラティブでも可能です
 #DECLARE($vYearInteger;$windowInteger) //year and window reference
 ... // 統計データを算出します
  // 終了後、ワーカーはフォームをコールして、結果を渡します
  // $vStatResults でフォーム上に結果を表示します
 CALL FORM($window;Formula(displayStats);$vStatResults)
```

#### 参照 

[CALL FORM](call-form.md)  
[Current process name](current-process-name.md)  
[KILL WORKER](kill-worker.md)  
*ワーカーについて*  