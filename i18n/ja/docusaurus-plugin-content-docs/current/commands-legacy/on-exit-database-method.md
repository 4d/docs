---
id: on-exit-database-method
title: On Exit database method
slug: /commands/on-exit-database-method
displayed_sidebar: docs
---

<!--REF #_command_.On Exit database method.Syntax-->**On Exitデータベースメソッド**<!-- END REF-->
<!--REF #_command_.On Exit database method.Params-->
| このコマンドは引数を必要としません |  |
| --- | --- |

<!-- END REF-->

*このコマンドはスレッドセーフではないため、プリエンプティブなコードには使えません。*


#### 

<!--REF #_command_.On Exit database method.Summary-->**On Exitデータベースメソッド**は、データベースを終了すると一回呼び出されます。<!-- END REF-->

このメソッドは、以下の4D環境で使用されます:

* ローカルモードの4D
* リモートモードの4D
* コンパイルし、4D VolumeDesktopを組み込んだ4Dアプリケーション

**Note**: **On Exitデータベースメソッド**は、4D Serverでは起動されません。 このコンテキストにおいては[On Server Shutdownデータベースメソッド](on-server-shutdown-database-method.md) を使用してください。

**On Exitデータベースメソッド**は4Dによって自動的に起動されます。プロジェクトメソッドとは異なり、プログラムからデータベースメソッドを呼び出すことはできません。しかしメソッドエディタから実行することはできます。またサブルーチンを使用できます。

データベースは、以下のうちいずれかが発生すると終了します:

* ユーザがデザインモードの**ファイル**メニュー**終了**メニューを、またはアプリケーションモードで終了標準アクション付きのメニューやボタンを選択した場合
* [QUIT 4D](quit-4d.md) コマンドへの呼び出しが実行された場合
* 4Dプラグインから[QUIT 4D](quit-4d.md) エントリポイントへの呼び出しが実行された場合

データベースの終了がどのような方法で行われたかに関わらず、4Dは以下のような処理を実行します:

* **On Exitデータベースメソッド**がない場合、4Dは実行プロセスそれぞれを区別せずに1つずつアボートします。ユーザがデータ入力を実行している場合には、レコードはキャンセルされ、保存されません。
* **On Exitデータベースメソッド**がある場合、4Dは新しく作成したローカルプロセスの中でこのメソッドの実行を開始します。したがって、このデータベースメソッドを使用し、インタープロセス間通信を通じて、（データ入力を）終了したり、処理の実行を中止したりしなければならないことを、他のプロセスに通知することができます。4Dは、いずれ終了するということに注意してください。**On Exitデータベースメソッド**は、必要なクリーンアップや終了の処理を実行することができますが、アプリケーションの終了を拒否できず、ある時点で終了することになります。

4D が終了しようとしているとき、プログラムは内部的に以下のようなことをします:

* 実行中のプロセスに可及的速やかにその実行を中止するように指示します(これは4D コードを実行しているプロセスにのみ適用されます)。
* それらのプロセスの"プロセス中止"フラグを設定します。
* コマンドや他の手段によって停止・遅延されているプロセスを起こします。

4D は生きているプロセスがある限り、プロセスをループし続けます。これは最大13秒間続きます。終了アクションに対応するためには、On Exitデータベースメソッド またはカスタムの終了メソッド内において(例えば[Storage](storage.md) オブジェクトへのエントリーなど)フラグを設定することが推奨されます。実行中のプロセスが終了アクションに対応し、プロセス自身を適切に終了させる時間を稼ぐためには、このメソッド内において(最大10秒間の)ループを行うのが理にかなっていると言えます。10秒以上待つことは推奨されておらず、この場合には4D はプロセスを強制終了させるか、あるいはOS がアプリケーション全体を強制終了させます。

**On Exitデータベースメソッド**は、以下のような処理を実行するには最適です:

* データベースを開いた時に自動的に開始されたプロセスを停止する。
* 次回のセッションの始めにで再利用するため、必要な環境設定や初期設定などの情報をローカルディスクなどに保存する。
* データベースを終了する度に実行したい処理が他にあれば、それを実行する。

**注:** **On Exitデータベースメソッド**がローカル/クライアントプロセスであり、データファイルにアクセスできないことを覚えておいてください。つまり、リモートモードで4Dを使用している時、**On Exitデータベースメソッド**で検索やソートを実行すると、4Dは "フリーズ" し、実際には終了しません。アプリケーションを終了するとき、リモートモードの4Dからデータにアクセスする必要があるならば、**On Exitデータベースメソッド**内から、新しいグローバルプロセスを作成してください。このグローバルプロセスはデータファイルにアクセスできます。この場合**On Exitデータベースメソッド**の終了前に、新しいプロセスが正しく終了されたことを ([Storage](storage.md) を使用するなどして) 確認してください。

**注:** クライアント/サーバー環境においては、ユーザーが手動で(**終了**メニューコマンドか[QUIT 4D](quit-4d.md) コマンドを呼び出すかで)終了するか、4D Server がシャットダウン(その結果全てのクライアントが強制終了)するかによって、振る舞いが異なります。  
4D Server が終了してカットオフタイム(例:10分)の間待つ場合、接続された各クライアントには警告メッセージが表示され、もしユーザーが与えられた時間内に4Dを終了すれば、**On Exitデータベースメソッド** は通常どおり実行されます。しかしながら、他の場合(例えばユーザーが時間内に反応しなかった、サーバーが即時終了するようリクエストしてきた、クライアントが管理者によって手動で接続解除された、などの場合)、**On Exitデータベースメソッド** はサーバーへの接続が閉じられたのと同時に実行されます。結果として、**On Exitデータベースメソッド** は他のローカル、あるいはサーバープロセスをローンチさせることはできませんし、他のプロセスがキャンセルされるのを待つこともできません(またこれらのプロセスはサーバーに接続しつづけることもできません)。接続しようとした場合、ネットワークエラー(10001あるいは10002)が生成されます。サーバーへの接続はすでに閉じられているからです。

#### 注 

以下の例は、[On Startupデータベースメソッド](on-startup-database-method.md) (あるいは[On Server Startupデータベースメソッド](on-server-startup-database-method.md)) 内において、無限に実行し続ける1つまたは複数のバックグラウンドプロセスを立ち上げるような場合の典型例を考えます。アプリケーション内の[Storage](storage.md) オブジェクト内にあるフラグを使用して、これらのプロセスに終了することを伝えると同時に、きちんと終了したかどうかをチェックするようになっています。

* [On Startupデータベースメソッド](on-startup-database-method.md) 内

```4d
 Use(Storage)
    Storage.global:=New shared object("ExitNow";False)
 End use
 $p:=New process("Serverjob";0;"Background job#1")
 $p1:=New process("Check_Invoices";0;"Background job#2")
```

* バックグラウンドメソッドの一例:

```4d
  // サーバー上で通常のバックグラウンドジョブを行う
 While(Not(Bool(Storage.global.ExitNow)))
  // 会計処理、データ計算などを行う
  // ...
    DELAY PROCESS(Current process;60*60) // 1分間プロセスをスリープさせ、ループを繰り返す
 End while
```

* **On Exitデータベースメソッド** 内:

```4d
 Use(Storage.global)
    Storage.global.ExitNow:=True // 全てのバックグラウンドワーカーに終了するよう伝える
 End use
 
 $time:=Current time
 $finished:=False
 While((($time+10)>(Current time+0))&(Not($finished))) // 上限 10 秒
    $list:=Get process activity(Processes only) // 全てのプロセスの一覧を取得
    $sublist:=$list.processes.query("name='Background job@' and state >=0") // まだ実行中のバックグラウンド処理があるかチェック
    $finished:=($sublist.length=0)
    If($sublist.length>0)
       For each($job;$sublist)
          RESUME PROCESS($job.number) // 全てのプロセスが起きているようにする
       End for each
    End if
 End while
```

#### 参照 

[On Startupデータベースメソッド](on-startup-database-method.md)  
[QUIT 4D](quit-4d.md)  